// EDEN ENGINE - Gateway Editor v1
// Features: ImGui, Programmatic Cube, FPS Camera, Frame Control

// Include EDEN Engine standard library
include "stdlib/eden.hd";

fn main(): void {
    // Visibility constants
    let VISIBLE: i32 = 1;
    let INVISIBLE: i32 = 0;
    print("Initializing GLFW...\n");
    if heidic_glfw_init() == 0 {
        return;
    }
    
    heidic_glfw_vulkan_hints();
    let window: GLFWwindow = heidic_create_window(1280, 720, "EDEN ENGINE - Gateway Editor v1");
    
    if heidic_init_renderer(window) == 0 {
        heidic_glfw_terminate();
        return;
    }
    
    // Load ImGui layout on startup
    heidic_imgui_load_layout("");
    
    // Start in windowed mode (1 = windowed)
    // Video mode: 0 = fullscreen, 1 = windowed
    
    // Player (Cube) Transform - using Vec3 for position and rotation
    // Spawn player away from the reference cubes (3000 units = 30 meters away)
    let player_pos: Vec3 = heidic_vec3(3000.0, 100.0, 3000.0); // 30m away, 1m above ground
    let player_rot: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
    
    // Camera Transform - will follow player with offset
    // Initial position will be set in loop with offset
    let camera_pos: Vec3 = heidic_vec3(0.0, 100.0, 0.0); // Will be updated in loop
    let camera_rot: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
    
    // Legacy variables for drawing (will be updated from Vec3)
    let cube_x: f32 = 0.0;
    let cube_y: f32 = 0.0;
    let cube_z: f32 = 0.0;
    let cube_rx: f32 = 0.0;
    let cube_ry: f32 = 0.0;
    let cube_rz: f32 = 0.0;
    
    // Cube Size (100 cm = 1 meter)
    let cube_sx: f32 = 100.0;
    let cube_sy: f32 = 100.0;
    let cube_sz: f32 = 100.0;
    
    // Movement Speed (cm per frame)
    let move_speed: f32 = 5.0;
    
    // Rotation Speed (degrees per frame) - for Q/E keys (optional, mouse look is primary)
    let rot_speed: f32 = 2.0;
    
    // Mouse Look Sensitivity (degrees per pixel)
    let mouse_sensitivity: f32 = 0.1;
    
    // Pitch clamp limits (for camera rotation)
    let pitch_max: f32 = 90.0;
    let pitch_min: f32 = -90.0;
    
    // Debug UI State
    let show_debug: i32 = 1;
    let f1_was_pressed: i32 = 0;
    
    // Camera Mode: 0 = Top-Down, 1 = FPS
    let camera_mode: i32 = 0; // Start in Top-Down mode
    let c_was_pressed: i32 = 0;
    
    // Player cube visibility: INVISIBLE in walk mode, VISIBLE in top-down mode
    let player_cube_visible: i32 = VISIBLE;
    
    // Mouse mode: 0 = disabled (cursor captured, mouse look/dolly enabled), 1 = enabled (cursor visible, picking enabled)
    let mouse_mode: i32 = 1; // Start with mouse enabled (visible cursor) for top-down mode
    let mouse_mode_left_was_pressed: i32 = 0;
    let mouse_mode_right_was_pressed: i32 = 0;
    
    // Set cursor mode based on initial mouse mode
    heidic_set_cursor_mode(window, 0); // 0 = normal (visible) for top-down mode
    
    // Grid visibility toggle
    let show_grid: i32 = 1; // Start with grid visible
    let g_was_pressed: i32 = 0;
    
    // Video Mode: 0 = fullscreen, 1 = windowed
    let video_mode: i32 = 1; // Start in windowed mode
    let shift_enter_was_pressed: i32 = 0;
    
    // Selection state
    let selected_cube_x: f32 = 0.0;
    let selected_cube_y: f32 = 0.0;
    let selected_cube_z: f32 = 0.0;
    let selected_cube_sx: f32 = 0.0;
    let selected_cube_sy: f32 = 0.0;
    let selected_cube_sz: f32 = 0.0;
    let has_selection: i32 = 0; // 0 = no selection, 1 = has selection
    let selected_cube_index: f32 = -1.0; // -1.0 = none, 0.0 = player, >= 2.0 = created cubes
    
    // Ground detection
    let is_grounded: i32 = 0;
    
    // Mouse button state tracking
    let mouse_left_was_pressed: i32 = 0;
    let mouse_middle_was_pressed: i32 = 0;
    
    // Delete key state tracking
    let delete_was_pressed: i32 = 0;
    
    // Level name buffer for input (managed by C++ side)
    // We'll use heidic_get_level_name() to get the current name
    
    // Top-down camera position (high up, looking down)
    let topdown_cam_height: f32 = 10000.0; // 100 meters up (zoom level)
    let topdown_cam_pan_x: f32 = 0.0; // Pan offset X
    let topdown_cam_pan_z: f32 = 0.0; // Pan offset Z
    let topdown_cam_pos: Vec3 = heidic_vec3(0.0, topdown_cam_height, 0.0); // 100 meters up
    let topdown_cam_rot: Vec3 = heidic_vec3(-90.0, 0.0, 0.0); // Looking straight down
    
    // Dolly orbit state (for orbiting around selected object)
    let dolly_orbit_azimuth: f32 = 0.0; // Horizontal angle around target
    let dolly_orbit_elevation: f32 = 45.0; // Vertical angle (0 = horizontal, 90 = straight up)
    let dolly_orbit_distance: f32 = 2000.0; // Distance from target (reduced from 5000 to 20 meters)
    let in_orbit_mode: i32 = 0; // Flag to prevent pan from overwriting orbit position
    let alt_was_pressed: i32 = 0; // Track Alt key state to detect when dolly starts
    
    // Reference Cube 1 removed - all cubes are now created dynamically
    
    // Spacebar state
    let space_was_pressed: i32 = 0;
    
    // Created cube size (2 meters = 200 units)
    let created_cube_size: f32 = 200.0;
    
    print("Starting loop...\n");
    
    while heidic_window_should_close(window) == 0 {
        heidic_poll_events();
        
        if heidic_is_key_pressed(window, 256) == 1 { // ESC
            heidic_set_window_should_close(window, 1);
        }
        
        // F1 Toggle Logic (290 is F1)
        let f1_is_pressed: i32 = heidic_is_key_pressed(window, 290);
        if f1_is_pressed == 1 {
            if f1_was_pressed == 0 {
                if show_debug == 1 {
                    show_debug = 0;
                } else {
                    show_debug = 1;
                }
                f1_was_pressed = 1;
            }
        } else {
            f1_was_pressed = 0;
        }
        
        // C Key Toggle Logic (67 is C) - Switch between Top-Down and FPS camera
        let c_is_pressed: i32 = heidic_is_key_pressed(window, 67);
        if c_is_pressed == 1 {
            if c_was_pressed == 0 {
                if camera_mode == 0 {
                    camera_mode = 1; // Switch to FPS
                    // Set cursor mode based on mouse_mode
                    if mouse_mode == 0 {
                        heidic_set_cursor_mode(window, 2); // 2 = disabled (captured)
                    } else {
                        heidic_set_cursor_mode(window, 0); // 0 = normal (visible)
                    }
                } else {
                    camera_mode = 0; // Switch to Top-Down
                    // Set cursor mode based on mouse_mode
                    if mouse_mode == 0 {
                        heidic_set_cursor_mode(window, 1); // 1 = hidden
                    } else {
                        heidic_set_cursor_mode(window, 0); // 0 = normal (visible)
                    }
                }
                c_was_pressed = 1;
            }
        } else {
            c_was_pressed = 0;
        }
        
        // Alt + Mouse Drag for Camera Dolly (works in both modes)
        // Left Alt = 342, Right Alt = 346
        let left_alt_pressed: i32 = heidic_is_key_pressed(window, 342);
        let right_alt_pressed: i32 = heidic_is_key_pressed(window, 346);
        let alt_pressed: i32 = 0;
        if left_alt_pressed == 1 {
            alt_pressed = 1;
        }
        if right_alt_pressed == 1 {
            alt_pressed = 1;
        }
        
        // Only allow dolly/look when mouse_mode is disabled
        if alt_pressed == 1 && mouse_mode == 0 {
            // Dolly orbit around selected object (if there's a selection)
            if has_selection == 1 {
                // Initialize orbit angles from current camera position when Alt is first pressed
                if alt_was_pressed == 0 {
                    // Calculate current camera position relative to target
                    let target_pos: Vec3 = heidic_vec3(selected_cube_x, selected_cube_y, selected_cube_z);
                    let current_cam_pos: Vec3 = camera_pos;
                    let to_camera: Vec3 = heidic_vec3_sub(current_cam_pos, target_pos);
                    let dist: f32 = heidic_vec3_distance(current_cam_pos, target_pos);
                    
                    if dist > 0.001 {
                        // Normalize direction vector
                        let dir_x: f32 = to_camera.x / dist;
                        let dir_y: f32 = to_camera.y / dist;
                        let dir_z: f32 = to_camera.z / dist;
                        
                        // Calculate azimuth from XZ components (horizontal angle)
                        let azimuth_rad: f32 = heidic_atan2(dir_x, dir_z);
                        dolly_orbit_azimuth = heidic_convert_radians_to_degrees(azimuth_rad);
                        
                        // Calculate elevation from Y component (vertical angle)
                        let elevation_rad: f32 = heidic_asin(dir_y);
                        dolly_orbit_elevation = heidic_convert_radians_to_degrees(elevation_rad);
                        
                        // Update distance to match current camera distance
                        if dist > 10.0 && dist < 100000.0 {
                            dolly_orbit_distance = dist;
                        }
                    }
                }
                
                // Get mouse delta for orbit movement
                let dolly_delta_x: f32 = heidic_get_mouse_delta_x(window);
                let dolly_delta_y: f32 = heidic_get_mouse_delta_y(window);
                
                // Orbit sensitivity (degrees per pixel) - LearnOpenGL style
                let orbit_sensitivity: f32 = 0.3; // Reduced for smoother feel
                
                // Update orbit angles (Track/Orbit)
                dolly_orbit_azimuth = dolly_orbit_azimuth - dolly_delta_x * orbit_sensitivity; // Horizontal rotation (yaw)
                dolly_orbit_elevation = dolly_orbit_elevation + dolly_delta_y * orbit_sensitivity; // Vertical rotation (pitch)
                
                // Clamp elevation to prevent gimbal lock (LearnOpenGL standard)
                if dolly_orbit_elevation > 89.0 {
                    dolly_orbit_elevation = 89.0;
                }
                if dolly_orbit_elevation < -89.0 {
                    dolly_orbit_elevation = -89.0;
                }
                
                // Target position (selected object)
                let target_pos: Vec3 = heidic_vec3(selected_cube_x, selected_cube_y, selected_cube_z);
                
                // Calculate camera position using spherical coordinates (Y-up system)
                // Standard spherical coordinates for orbit camera:
                // - Azimuth: rotation around Y axis (horizontal)
                // - Elevation: angle from horizontal plane (vertical, -90 to +90)
                let azimuth_rad: f32 = heidic_convert_degrees_to_radians(dolly_orbit_azimuth);
                let elevation_rad: f32 = heidic_convert_degrees_to_radians(dolly_orbit_elevation);
                
                // Spherical to Cartesian conversion (Y-up, right-handed)
                // When elevation = 0: camera is at same Y as target (horizontal)
                // When elevation = 90: camera is directly above target
                // When elevation = -90: camera is directly below target
                // X = distance * cos(elevation) * sin(azimuth)
                // Y = distance * sin(elevation)  [This allows negative Y when elevation < 0]
                // Z = distance * cos(elevation) * cos(azimuth)
                let cos_elev: f32 = heidic_cos(elevation_rad);
                let sin_elev: f32 = heidic_sin(elevation_rad);
                let cos_azim: f32 = heidic_cos(azimuth_rad);
                let sin_azim: f32 = heidic_sin(azimuth_rad);
                
                let offset_x: f32 = dolly_orbit_distance * cos_elev * sin_azim;
                let offset_y: f32 = dolly_orbit_distance * sin_elev;  // Can be negative!
                let offset_z: f32 = dolly_orbit_distance * cos_elev * cos_azim;
                
                let offset: Vec3 = heidic_vec3(offset_x, offset_y, offset_z);
                let new_cam_pos: Vec3 = heidic_vec3_add(target_pos, offset);
                
                // NO Y RESTRICTIONS - camera can go anywhere in 3D space
                
                // Track that we're in orbit mode (prevent pan update from overwriting)
                in_orbit_mode = 1;
                
                if camera_mode == 0 {
                    // Top-Down Mode: Update camera position and look at target
                    topdown_cam_pos = new_cam_pos;
                    camera_pos = new_cam_pos;
                    
                    // Calculate direction vector from camera to target
                    let to_target: Vec3 = heidic_vec3_sub(target_pos, new_cam_pos);
                    let dist_to_target: f32 = heidic_vec3_distance(new_cam_pos, target_pos);
                    
                    // Calculate yaw and pitch from direction vector to ensure camera always faces target
                    if dist_to_target > 0.001 {
                        // Normalize direction (we'll calculate components manually)
                        let dir_x: f32 = to_target.x / dist_to_target;
                        let dir_y: f32 = to_target.y / dist_to_target;
                        let dir_z: f32 = to_target.z / dist_to_target;
                        
                        // Yaw: rotation around Y axis (horizontal)
                        // atan2(x, z) gives angle in XZ plane (0° = +Z, 90° = +X)
                        let yaw_rad: f32 = heidic_atan2(dir_x, dir_z);
                        let yaw_deg: f32 = heidic_convert_radians_to_degrees(yaw_rad);
                        
                        // Pitch: rotation around X axis (vertical)
                        // asin(y) gives elevation angle (-90° to +90°)
                        let pitch_rad: f32 = heidic_asin(dir_y);
                        let pitch_deg: f32 = heidic_convert_radians_to_degrees(pitch_rad);
                        
                        topdown_cam_rot.x = pitch_deg;   // Pitch (vertical)
                        topdown_cam_rot.y = yaw_deg;     // Yaw (horizontal)
                        topdown_cam_rot.z = 0.0;         // Roll (no roll)
                    } else {
                        // Too close, use fallback angles
                        topdown_cam_rot.x = -dolly_orbit_elevation;
                        topdown_cam_rot.y = dolly_orbit_azimuth + 180.0;
                        topdown_cam_rot.z = 0.0;
                    }
                    camera_rot = topdown_cam_rot;
                } else {
                    // FPS Mode: Update player position to orbit around target
                    player_pos = new_cam_pos;
                    
                    // Calculate direction vector from camera to target
                    let to_target: Vec3 = heidic_vec3_sub(target_pos, new_cam_pos);
                    let dist_to_target: f32 = heidic_vec3_distance(new_cam_pos, target_pos);
                    
                    // Calculate yaw and pitch from direction vector
                    if dist_to_target > 0.001 {
                        let dir_x: f32 = to_target.x / dist_to_target;
                        let dir_y: f32 = to_target.y / dist_to_target;
                        let dir_z: f32 = to_target.z / dist_to_target;
                        
                        let yaw_rad: f32 = heidic_atan2(dir_x, dir_z);
                        let yaw_deg: f32 = heidic_convert_radians_to_degrees(yaw_rad);
                        
                        let pitch_rad: f32 = heidic_asin(dir_y);
                        let pitch_deg: f32 = heidic_convert_radians_to_degrees(pitch_rad);
                        
                        player_rot.y = yaw_deg;   // Yaw (horizontal)
                        player_rot.x = pitch_deg;  // Pitch (vertical)
                    } else {
                        // Fallback
                        player_rot.y = dolly_orbit_azimuth + 180.0;
                        player_rot.x = -dolly_orbit_elevation;
                    }
                }
            } else {
                // No selection: use general dolly (same logic as walk mode)
                let dolly_delta_x: f32 = heidic_get_mouse_delta_x(window);
                let dolly_delta_y: f32 = heidic_get_mouse_delta_y(window);
                let dolly_speed: f32 = 20.0;
                
                if camera_mode == 0 {
                    // Top-down editor camera: use same dolly logic as walk mode
                    // Calculate forward/right vectors from camera yaw rotation
                    let yaw_rad: f32 = heidic_convert_degrees_to_radians(topdown_cam_rot.y);
                    let forward_x: f32 = heidic_sin(yaw_rad);
                    let forward_z: f32 = heidic_cos(yaw_rad);
                    let right_x: f32 = heidic_cos(yaw_rad);
                    let right_z: f32 = -heidic_sin(yaw_rad);
                    let move_x: f32 = right_x * dolly_delta_x * dolly_speed + forward_x * dolly_delta_y * dolly_speed;
                    let move_z: f32 = right_z * dolly_delta_x * dolly_speed + forward_z * dolly_delta_y * dolly_speed;
                    // Move camera position (pan offset) based on calculated movement
                    topdown_cam_pan_x = topdown_cam_pan_x + move_x;
                    topdown_cam_pan_z = topdown_cam_pan_z + move_z;
                } else {
                    // Walk mode: keep existing perfect dolly logic (DO NOT CHANGE)
                    let yaw_rad: f32 = heidic_convert_degrees_to_radians(player_rot.y);
                    let forward_x: f32 = heidic_sin(yaw_rad);
                    let forward_z: f32 = heidic_cos(yaw_rad);
                    let right_x: f32 = heidic_cos(yaw_rad);
                    let right_z: f32 = -heidic_sin(yaw_rad);
                    let move_x: f32 = right_x * dolly_delta_x * dolly_speed + forward_x * dolly_delta_y * dolly_speed;
                    let move_z: f32 = right_z * dolly_delta_x * dolly_speed + forward_z * dolly_delta_y * dolly_speed;
                    player_pos.x = player_pos.x + move_x;
                    player_pos.z = player_pos.z + move_z;
                }
            }
            alt_was_pressed = 1; // Mark Alt as pressed
        } else {
            alt_was_pressed = 0; // Reset when Alt is released
        }
        
        // Mouse Look (only in FPS mode, only when mouse_mode is disabled, and only when Alt is NOT pressed)
        if camera_mode == 1 && mouse_mode == 0 && alt_pressed == 0 {
            // Get mouse delta
            let mouse_delta_x: f32 = heidic_get_mouse_delta_x(window);
            let mouse_delta_y: f32 = heidic_get_mouse_delta_y(window);
            
            // Update yaw (horizontal rotation) - rotate around Y axis
            // Reversed: mouse right = turn right (natural FPS feel)
            player_rot.y = player_rot.y - mouse_delta_x * mouse_sensitivity;
            
            // Update pitch (vertical rotation) - rotate around X axis
            // Clamp pitch to prevent flipping (typically -90 to +90 degrees)
            player_rot.x = player_rot.x - mouse_delta_y * mouse_sensitivity;
            
            // Clamp pitch to prevent camera flipping
            if player_rot.x > pitch_max {
                player_rot.x = pitch_max;
            }
            // Clamp minimum pitch (check if pitch_min is greater than current - inverted logic)
            let pitch_check: f32 = pitch_min - player_rot.x;
            if pitch_check > 0.0 {
                player_rot.x = pitch_min;
            }
        }
        
        // G Key Toggle Logic (71 is G) - Toggle ground plane grid visibility
        let g_is_pressed: i32 = heidic_is_key_pressed(window, 71);
        if g_is_pressed == 1 {
            if g_was_pressed == 0 {
                if show_grid == 1 {
                    show_grid = 0; // Hide grid
                } else {
                    show_grid = 1; // Show grid
                }
                g_was_pressed = 1;
            }
        } else {
            g_was_pressed = 0;
        }
        
        // Spacebar (32) - Create new cube at mouse ray hit point
        // Works in any mode - always uses mouse ray to find placement position
        // Also try key code 57 as fallback (some systems use different codes)
        let space_is_pressed: i32 = heidic_is_key_pressed(window, 32);
        // Fallback: try key code 57 if 32 doesn't work
        if space_is_pressed == 0 {
            space_is_pressed = heidic_is_key_pressed(window, 57);
        }
        
        if space_is_pressed == 1 {
            if space_was_pressed == 0 {
                print("SPACEBAR PRESSED! Creating cube at ray hit point\n");
                
                // Default cube size (1 meter = 100 units)
                let default_cube_size: f32 = 100.0;
                
                // Always use mouse ray to find where to place the cube
                let create_ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
                let create_ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
                
                // First, check if ray hits any existing cubes (find closest hit)
                let create_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
                let found_hit: i32 = 0;
                let closest_dist: f32 = 100000000000.0; // Very large distance
                let hit_cube_x: f32 = 0.0;
                let hit_cube_y: f32 = 0.0;
                let hit_cube_z: f32 = 0.0;
                let hit_cube_sx: f32 = 0.0;
                let hit_cube_sy: f32 = 0.0;
                let hit_cube_sz: f32 = 0.0;
                let hit_point: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
                let is_ground_plane: i32 = 0;
                
                // FIRST: Test the big grey ground plane cube (100m x 100m x 1m at y = -500)
                // This is important geometry and needs to be pickable!
                let ground_cube_x: f32 = 0.0;
                let ground_cube_y: f32 = -500.0;
                let ground_cube_z: f32 = 0.0;
                let ground_cube_sx: f32 = 10000.0; // 100 meters
                let ground_cube_sy: f32 = 100.0;   // 1 meter thick
                let ground_cube_sz: f32 = 10000.0; // 100 meters
                
                let ground_cube_hit: i32 = heidic_raycast_cube_hit(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                if ground_cube_hit == 1 {
                    let ground_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                    let ground_cube_dist: f32 = (ground_cube_hit_point.x - create_ray_origin.x) * (ground_cube_hit_point.x - create_ray_origin.x) + (ground_cube_hit_point.y - create_ray_origin.y) * (ground_cube_hit_point.y - create_ray_origin.y) + (ground_cube_hit_point.z - create_ray_origin.z) * (ground_cube_hit_point.z - create_ray_origin.z);
                    if ground_cube_dist < closest_dist {
                        closest_dist = ground_cube_dist;
                        create_pos = ground_cube_hit_point;
                        hit_point = ground_cube_hit_point;
                        hit_cube_x = ground_cube_x;
                        hit_cube_y = ground_cube_y;
                        hit_cube_z = ground_cube_z;
                        hit_cube_sx = ground_cube_sx;
                        hit_cube_sy = ground_cube_sy;
                        hit_cube_sz = ground_cube_sz;
                        is_ground_plane = 1;
                        found_hit = 1;
                    }
                }
                
                // Test all created cubes to find closest hit
                let cube_test_index: i32 = 0;
                let total_cubes_test: i32 = heidic_get_cube_total_count();
                while cube_test_index < total_cubes_test {
                    if heidic_get_cube_active(cube_test_index) == 1 {
                        let test_cube_x: f32 = heidic_get_cube_x(cube_test_index);
                        let test_cube_y: f32 = heidic_get_cube_y(cube_test_index);
                        let test_cube_z: f32 = heidic_get_cube_z(cube_test_index);
                        let test_cube_sx: f32 = heidic_get_cube_sx(cube_test_index);
                        let test_cube_sy: f32 = heidic_get_cube_sy(cube_test_index);
                        let test_cube_sz: f32 = heidic_get_cube_sz(cube_test_index);
                        
                        let cube_hit: i32 = heidic_raycast_cube_hit(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                        if cube_hit == 1 {
                            let test_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                            let dist: f32 = (test_hit_point.x - create_ray_origin.x) * (test_hit_point.x - create_ray_origin.x) + (test_hit_point.y - create_ray_origin.y) * (test_hit_point.y - create_ray_origin.y) + (test_hit_point.z - create_ray_origin.z) * (test_hit_point.z - create_ray_origin.z);
                            if dist < closest_dist {
                                closest_dist = dist;
                                create_pos = test_hit_point;
                                // Store the hit cube's position, size, and hit point for face detection
                                hit_point = test_hit_point;
                                hit_cube_x = test_cube_x;
                                hit_cube_y = test_cube_y;
                                hit_cube_z = test_cube_z;
                                hit_cube_sx = test_cube_sx;
                                hit_cube_sy = test_cube_sy;
                                hit_cube_sz = test_cube_sz;
                                is_ground_plane = 0;
                                found_hit = 1;
                            }
                        }
                    }
                    cube_test_index = cube_test_index + 1;
                }
                
                if found_hit == 1 {
                    // Ray hit a cube or ground plane - determine which face was hit and stack accordingly
                    if is_ground_plane == 1 {
                        // Ground plane: always stack on top
                        let hit_top_y: f32 = hit_cube_y + hit_cube_sy / 2.0;
                        create_pos.y = hit_top_y + default_cube_size / 2.0;
                        create_pos.x = hit_point.x;
                        create_pos.z = hit_point.z;
                        print("Hit ground plane! Stacking on top\n");
                    } else {
                        // Regular cube: determine which face was hit
                        // Calculate cube bounds
                        let cube_min_x: f32 = hit_cube_x - hit_cube_sx / 2.0;
                        let cube_max_x: f32 = hit_cube_x + hit_cube_sx / 2.0;
                        let cube_min_y: f32 = hit_cube_y - hit_cube_sy / 2.0;
                        let cube_max_y: f32 = hit_cube_y + hit_cube_sy / 2.0;
                        let cube_min_z: f32 = hit_cube_z - hit_cube_sz / 2.0;
                        let cube_max_z: f32 = hit_cube_z + hit_cube_sz / 2.0;
                        
                        // Calculate distances from hit point to each face
                        let dist_to_left: f32 = hit_point.x - cube_min_x;
                        let dist_to_right: f32 = cube_max_x - hit_point.x;
                        let dist_to_bottom: f32 = hit_point.y - cube_min_y;
                        let dist_to_top: f32 = cube_max_y - hit_point.y;
                        let dist_to_back: f32 = hit_point.z - cube_min_z;
                        let dist_to_front: f32 = cube_max_z - hit_point.z;
                        
                        // Find the closest face (smallest distance)
                        let min_dist: f32 = dist_to_left;
                        let hit_face: i32 = 0; // 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
                        
                        if dist_to_right < min_dist {
                            min_dist = dist_to_right;
                            hit_face = 1;
                        }
                        if dist_to_bottom < min_dist {
                            min_dist = dist_to_bottom;
                            hit_face = 2;
                        }
                        if dist_to_top < min_dist {
                            min_dist = dist_to_top;
                            hit_face = 3;
                        }
                        if dist_to_back < min_dist {
                            min_dist = dist_to_back;
                            hit_face = 4;
                        }
                        if dist_to_front < min_dist {
                            min_dist = dist_to_front;
                            hit_face = 5;
                        }
                        
                        // Place new cube adjacent to the hit face
                        if hit_face == 0 {
                            // Left face (negative X) - stack to the left
                            create_pos.x = cube_min_x - default_cube_size / 2.0;
                            create_pos.y = hit_cube_y;
                            create_pos.z = hit_cube_z;
                            print("Hit left face! Stacking to the left\n");
                        } else {
                            if hit_face == 1 {
                                // Right face (positive X) - stack to the right
                                create_pos.x = cube_max_x + default_cube_size / 2.0;
                                create_pos.y = hit_cube_y;
                                create_pos.z = hit_cube_z;
                                print("Hit right face! Stacking to the right\n");
                            } else {
                                if hit_face == 2 {
                                    // Bottom face (negative Y) - stack below
                                    create_pos.x = hit_cube_x;
                                    create_pos.y = cube_min_y - default_cube_size / 2.0;
                                    create_pos.z = hit_cube_z;
                                    print("Hit bottom face! Stacking below\n");
                                } else {
                                    if hit_face == 3 {
                                        // Top face (positive Y) - stack on top
                                        create_pos.x = hit_cube_x;
                                        create_pos.y = cube_max_y + default_cube_size / 2.0;
                                        create_pos.z = hit_cube_z;
                                        print("Hit top face! Stacking on top\n");
                                    } else {
                                        if hit_face == 4 {
                                            // Back face (negative Z) - stack to the back
                                            create_pos.x = hit_cube_x;
                                            create_pos.y = hit_cube_y;
                                            create_pos.z = cube_min_z - default_cube_size / 2.0;
                                            print("Hit back face! Stacking to the back\n");
                                        } else {
                                            // Front face (positive Z) - stack to the front
                                            create_pos.x = hit_cube_x;
                                            create_pos.y = hit_cube_y;
                                            create_pos.z = cube_max_z + default_cube_size / 2.0;
                                            print("Hit front face! Stacking to the front\n");
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // No hit - place cube 5 meters (500 units) along the ray
                    create_pos = heidic_vec3_add(create_ray_origin, heidic_vec3_mul_scalar(create_ray_dir, 500.0));
                    print("No hit, placing cube along ray\n");
                }
                
                // Generate random color for the new cube
                let cube_r: f32 = heidic_random_float();
                let cube_g: f32 = heidic_random_float();
                let cube_b: f32 = heidic_random_float();
                
                // Create cube using dynamic storage system with random color
                let cube_index: i32 = heidic_create_cube_with_color(create_pos.x, create_pos.y, create_pos.z, default_cube_size, default_cube_size, default_cube_size, cube_r, cube_g, cube_b);
                
                if cube_index >= 0 {
                    print("Created cube at index: ");
                    print(cube_index);
                    print("\n");
                    
                    // Select the newly created cube
                    has_selection = 1;
                    // Convert index to float and add 2.0 offset
                    selected_cube_index = heidic_int_to_float(cube_index) + 2.0;
                    // Update selected cube properties for gizmo
                    selected_cube_x = create_pos.x;
                    selected_cube_y = create_pos.y;
                    selected_cube_z = create_pos.z;
                    selected_cube_sx = default_cube_size;
                    selected_cube_sy = default_cube_size;
                    selected_cube_sz = default_cube_size;
                } else {
                    print("Failed to create cube\n");
                }
                
                space_was_pressed = 1;
            }
        } else {
            space_was_pressed = 0;
        }
        
        // Delete key (261) - Delete selected cube
        let delete_is_pressed: i32 = heidic_is_key_pressed(window, 261);
        if delete_is_pressed == 1 {
            if delete_was_pressed == 0 {
                // Only delete if we have a selection and it's a created cube (not player)
                if has_selection == 1 && selected_cube_index >= 2.0 {
                    // Convert float index to int (created cubes: index = vector_index + 2.0)
                    let cube_vector_index: i32 = heidic_float_to_int(selected_cube_index - 2.0);
                    heidic_delete_cube(cube_vector_index);
                    print("Deleted cube at index ");
                    print("\n");
                    
                    // Clear selection after deletion
                    has_selection = 0;
                    selected_cube_index = -1.0;
                }
                delete_was_pressed = 1;
            }
        } else {
            delete_was_pressed = 0;
        }
        
        // Shift+Enter Toggle Logic - Switch between Fullscreen and Windowed
        // Enter = 257, Left Shift = 340, Right Shift = 344
        let enter_is_pressed: i32 = heidic_is_key_pressed(window, 257);
        let left_shift_is_pressed: i32 = heidic_is_key_pressed(window, 340);
        let right_shift_is_pressed: i32 = heidic_is_key_pressed(window, 344);
        let shift_is_pressed: i32 = 0;
        if left_shift_is_pressed == 1 {
            shift_is_pressed = 1;
        }
        if right_shift_is_pressed == 1 {
            shift_is_pressed = 1;
        }
        
        if enter_is_pressed == 1 && shift_is_pressed == 1 {
            if shift_enter_was_pressed == 0 {
                if video_mode == 1 {
                    video_mode = 0; // Switch to fullscreen
                    heidic_set_video_mode(0);
                } else {
                    video_mode = 1; // Switch to windowed
                    heidic_set_video_mode(1);
                }
                shift_enter_was_pressed = 1;
            }
        } else {
            shift_enter_was_pressed = 0;
        }
        
        // Calculate forward and right direction vectors based on Y rotation
        // Forward should follow the yellow line (Z-axis) direction
        // At 0°: forward = (0, 0, -1) = negative Z (model's forward at start)
        let rot_y_rad: f32 = heidic_convert_degrees_to_radians(player_rot.y);
        // Forward follows the rotated negative Z-axis (yellow line direction)
        // Try: forward = (-sin(angle), 0, -cos(angle))
        let forward_x: f32 = -heidic_sin(rot_y_rad);
        let forward_z: f32 = -heidic_cos(rot_y_rad);
        // Right = (cos(angle), 0, -sin(angle))
        let right_x: f32 = heidic_cos(rot_y_rad);
        let right_z: f32 = -heidic_sin(rot_y_rad);
        
        // WASD Movement Controls (relative to rotation)
        // W = 87: move forward (in direction player is facing)
        if heidic_is_key_pressed(window, 87) == 1 {
            player_pos.x = player_pos.x + forward_x * move_speed;
            player_pos.z = player_pos.z + forward_z * move_speed;
        }
        // S = 83: move backward (opposite of forward)
        if heidic_is_key_pressed(window, 83) == 1 {
            player_pos.x = player_pos.x - forward_x * move_speed;
            player_pos.z = player_pos.z - forward_z * move_speed;
        }
        // A = 65: move left (negative right direction)
        if heidic_is_key_pressed(window, 65) == 1 {
            player_pos.x = player_pos.x - right_x * move_speed;
            player_pos.z = player_pos.z - right_z * move_speed;
        }
        // D = 68: move right (positive right direction)
        if heidic_is_key_pressed(window, 68) == 1 {
            player_pos.x = player_pos.x + right_x * move_speed;
            player_pos.z = player_pos.z + right_z * move_speed;
        }
        
        // Q = 81: Raise player (move up in Y)
        if heidic_is_key_pressed(window, 81) == 1 {
            player_pos.y = player_pos.y + move_speed;
        }
        // E = 69: Lower player (move down in Y)
        if heidic_is_key_pressed(window, 69) == 1 {
            player_pos.y = player_pos.y - move_speed;
        }
        
        // Update camera based on mode
        if camera_mode == 1 {
            // FPS Mode: Make camera follow player with offset
            // Add offset to player position (100 units above player = eye height)
            let offset: Vec3 = heidic_vec3(0.0, 100.0, 0.0);
            let offset_pos: Vec3 = heidic_vec3_add(player_pos, offset);
            
            // Copy offset position to camera position
            camera_pos = heidic_attach_camera_translation(offset_pos);
            // Copy player rotation to camera rotation
            camera_rot = heidic_attach_camera_rotation(player_rot);
        } else {
            // Top-Down Mode: Use fixed top-down camera with zoom and pan
            // Ctrl+RMB drag for zoom (ZBrush style)
            // Left Ctrl = 341, Right Ctrl = 345, Right Mouse Button = 1
            let left_ctrl_pressed: i32 = heidic_is_key_pressed(window, 341);
            let right_ctrl_pressed: i32 = heidic_is_key_pressed(window, 345);
            let ctrl_pressed: i32 = 0;
            if left_ctrl_pressed == 1 {
                ctrl_pressed = 1;
            }
            if right_ctrl_pressed == 1 {
                ctrl_pressed = 1;
            }
            
            let right_mouse_pressed: i32 = heidic_is_mouse_button_pressed(window, 1);
            
            if ctrl_pressed == 1 && right_mouse_pressed == 1 {
                // Get mouse delta Y for zoom/dolly
                let mouse_delta_y: f32 = heidic_get_mouse_delta_y(window);
                if mouse_delta_y != 0.0 {
                    // If actively orbiting (Alt pressed) AND has selection: Adjust dolly distance
                    // Otherwise: Always adjust zoom (camera height) - zoom should always work
                    if alt_pressed == 1 && has_selection == 1 {
                        // Dolly: Adjust distance to target (only when actively orbiting)
                        // Negative delta = move closer (dolly in), positive = move away (dolly out)
                        let dolly_speed: f32 = 50.0; // Units per pixel
                        dolly_orbit_distance = dolly_orbit_distance - mouse_delta_y * dolly_speed;
                        
                        // Clamp distance to reasonable range (allow very close and very far)
                        if dolly_orbit_distance < 10.0 {
                            dolly_orbit_distance = 10.0; // Min: 10cm (very close)
                        }
                        if dolly_orbit_distance > 100000.0 {
                            dolly_orbit_distance = 100000.0; // Max: 1km
                        }
                    } else {
                        // Zoom: Adjust camera height (FOV-style zoom for top-down) - ALWAYS available
                        // Speed proportional to camera height for consistent feel
                        let zoom_speed_factor: f32 = topdown_cam_height / 10000.0; // Normalize to base height
                        let zoom_speed: f32 = 50.0 * zoom_speed_factor; // Base speed multiplier
                        topdown_cam_height = topdown_cam_height - mouse_delta_y * zoom_speed;
                        
                        // Clamp zoom level (allow going below ground if needed, but reasonable limits)
                        if topdown_cam_height < 10.0 {
                            topdown_cam_height = 10.0; // Min: 10cm (very close)
                        }
                        if topdown_cam_height > 100000.0 {
                            topdown_cam_height = 100000.0; // Max: 1km
                        }
                    }
                }
            }
            
            // [ and ] keys for zoom (backup/alternative)
            // [ = zoom in (lower height), ] = zoom out (higher height)
            if heidic_is_key_pressed(window, 91) == 1 {
                // Zoom in
                let zoom_speed: f32 = 100.0; // Reduced speed for finer control
                topdown_cam_height = topdown_cam_height - zoom_speed;
                
                // Clamp zoom level (min 100 units = 1 meter, max 50000 units = 500 meters)
                if topdown_cam_height < 100.0 {
                    topdown_cam_height = 100.0;
                }
            }
            if heidic_is_key_pressed(window, 93) == 1 {
                // Zoom out
                let zoom_speed: f32 = 100.0; // Reduced speed for finer control
                topdown_cam_height = topdown_cam_height + zoom_speed;
                
                // Clamp zoom level (min 1000 units = 10 meters, max 50000 units = 500 meters)
                if topdown_cam_height > 50000.0 {
                    topdown_cam_height = 50000.0;
                }
            }
            
            // MMB button press + drag for panning (translating camera across XZ plane)
            let mouse_middle_pressed: i32 = heidic_is_mouse_button_pressed(window, 2);
            if mouse_middle_pressed == 1 {
                // Get mouse delta for panning
                let mouse_delta_x: f32 = heidic_get_mouse_delta_x(window);
                let mouse_delta_y: f32 = heidic_get_mouse_delta_y(window);
                
                if mouse_delta_x != 0.0 || mouse_delta_y != 0.0 {
                    // Pan speed proportional to camera height for consistent feel
                    // Higher camera = move faster, lower camera = move slower
                    let pan_speed_factor: f32 = topdown_cam_height / 10000.0; // Normalize to base height
                    let pan_speed: f32 = 4.0 * pan_speed_factor; // Increased base speed to 4.0
                    
                    // Mouse X moves camera X (reversed: drag right = move left, drag left = move right)
                    topdown_cam_pan_x = topdown_cam_pan_x - mouse_delta_x * pan_speed;
                    // Mouse Y moves camera Z (reversed: drag down = move forward, drag up = move back)
                    topdown_cam_pan_z = topdown_cam_pan_z - mouse_delta_y * pan_speed;
                }
                mouse_middle_was_pressed = 1;
            } else {
                mouse_middle_was_pressed = 0;
            }
            
            // Update top-down camera position with new height and pan offset
            // BUT: Skip this if we're in orbit mode (orbit code already set camera_pos)
            if in_orbit_mode == 0 {
                topdown_cam_pos = heidic_vec3(topdown_cam_pan_x, topdown_cam_height, topdown_cam_pan_z);
                camera_pos = topdown_cam_pos;
                camera_rot = topdown_cam_rot;
            }
            // Reset orbit flag for next frame
            in_orbit_mode = 0;
        }
        
        // Update legacy variables for drawing
        cube_x = player_pos.x;
        cube_y = player_pos.y;
        cube_z = player_pos.z;
        cube_rx = player_rot.x;
        cube_ry = player_rot.y;
        cube_rz = player_rot.z;
        
        heidic_begin_frame();
        
        // Setup dockspace (enables docking for all windows)
        heidic_imgui_setup_dockspace();
        
        // Main Menu Bar
        if heidic_imgui_begin_main_menu_bar() == 1 {
            if heidic_imgui_begin_menu("File") == 1 {
                if heidic_imgui_menu_item("Save Level As...") == 1 {
                    // Show native save dialog
                    let save_result: i32 = heidic_show_save_dialog();
                    if save_result == 1 {
                        // Success - level saved via dialog
                    }
                }
                if heidic_imgui_menu_item("Open Level...") == 1 {
                    // Show native open dialog
                    let load_result: i32 = heidic_show_open_dialog();
                    if load_result == 1 {
                        // Success - level loaded via dialog
                    }
                }
                heidic_imgui_separator();
                if heidic_imgui_menu_item("Exit") == 1 {
                    heidic_set_window_should_close(window, 1);
                }
                heidic_imgui_end_menu();
            }
            if heidic_imgui_begin_menu("Object") == 1 {
                if heidic_imgui_menu_item("Add Cube") == 1 {
                    // Create cube at origin (0, 0, 0) with default size
                    let default_cube_size: f32 = 200.0; // 2 meters
                    let new_cube_index: i32 = heidic_create_cube(0.0, 0.0, 0.0, default_cube_size, default_cube_size, default_cube_size);
                    // Select the newly created cube (indices start from 2.0 for created cubes)
                    // Convert index to float and add 2.0 offset
                    selected_cube_index = heidic_int_to_float(new_cube_index) + 2.0;
                    has_selection = 1;
                    // Update selected cube properties for gizmo
                    selected_cube_x = 0.0;
                    selected_cube_y = 0.0;
                    selected_cube_z = 0.0;
                    selected_cube_sx = default_cube_size;
                    selected_cube_sy = default_cube_size;
                    selected_cube_sz = default_cube_size;
                }
                heidic_imgui_end_menu();
            }
            heidic_imgui_end_main_menu_bar();
        }
        
        // Update Camera with Vec3 values
        // Use larger far plane for top-down view to see distant objects
        if camera_mode == 0 {
            // Top-down mode: use 50000 units far plane (500 meters) to see everything
            heidic_update_camera_with_far(camera_pos.x, camera_pos.y, camera_pos.z, camera_rot.x, camera_rot.y, camera_rot.z, 50000.0);
        } else {
            // FPS mode: use default 5000 units far plane (50 meters)
            heidic_update_camera(camera_pos.x, camera_pos.y, camera_pos.z, camera_rot.x, camera_rot.y, camera_rot.z);
        }
        
        // Draw solid ground plane cube: 100m x 100m x 1m thick at y = -5m (-500 units)
        // 100 meters = 10000 units, 1 meter = 100 units, -5 meters = -500 units
        heidic_draw_cube_grey(0.0, -500.0, 0.0, 0.0, 0.0, 0.0, 10000.0, 100.0, 10000.0);
        
        // Draw Ground Plane grid (large grid at y=-300) - only if grid is visible
        if show_grid == 1 {
            heidic_draw_ground_plane(20000.0, 0.5, 0.5, 0.5); // 200 meters, grey color
        }
        
        // Update player cube visibility based on camera mode
        if camera_mode == 1 {
            // Walk mode (FPS): make player cube invisible
            player_cube_visible = INVISIBLE;
        } else {
            // Top-down mode: make player cube visible
            player_cube_visible = VISIBLE;
        }
        
        // Draw Player Cube (only if visible)
        if player_cube_visible == VISIBLE {
            heidic_draw_cube(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, cube_sx, cube_sy, cube_sz);
        }
        
        // Draw Origin Lines (1 meter = 100 cm = 100 units)
        // Player origin lines are invisible (only draw for reference cubes if needed)
        // heidic_draw_model_origin(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, 100.0);
        
        // Starting cubes removed - user can create cubes with Spacebar or Object menu
        
        // Draw Created Cubes (user-created via Spacebar) - Dynamic system
        let cube_draw_index: i32 = 0;
        let total_cubes: i32 = heidic_get_cube_total_count();
        while cube_draw_index < total_cubes {
            if heidic_get_cube_active(cube_draw_index) == 1 {
                let cube_x: f32 = heidic_get_cube_x(cube_draw_index);
                let cube_y: f32 = heidic_get_cube_y(cube_draw_index);
                let cube_z: f32 = heidic_get_cube_z(cube_draw_index);
                let cube_sx: f32 = heidic_get_cube_sx(cube_draw_index);
                let cube_sy: f32 = heidic_get_cube_sy(cube_draw_index);
                let cube_sz: f32 = heidic_get_cube_sz(cube_draw_index);
                let cube_r: f32 = heidic_get_cube_r(cube_draw_index);
                let cube_g: f32 = heidic_get_cube_g(cube_draw_index);
                let cube_b: f32 = heidic_get_cube_b(cube_draw_index);
                heidic_draw_cube_colored(cube_x, cube_y, cube_z, 0.0, 0.0, 0.0, cube_sx, cube_sy, cube_sz, cube_r, cube_g, cube_b);
            }
            cube_draw_index = cube_draw_index + 1;
        }
        
        // ============================================================================
        // RAYCASTING
        // ============================================================================
        
        // Get mouse position
        let mouse_x: f32 = heidic_get_mouse_x(window);
        let mouse_y: f32 = heidic_get_mouse_y(window);
        
        // Get mouse ray
        let ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
        let ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
        
        // Yellow debug line - draw from camera to 50km out along ray
        // This helps visualize where the ray is pointing
        heidic_draw_ray(window, 50000.0, 1.0, 1.0, 0.0);
        
        // Debug: Draw large red cube at ray hit point to visualize where ray intersects geometry
        // Always calculate and draw, regardless of mode
        let debug_ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
        let debug_ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
        let debug_hit_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
        let debug_found_hit: i32 = 0;
        let debug_closest_dist: f32 = 100000000000.0;
        let debug_hit_cube_x: f32 = 0.0;
        let debug_hit_cube_y: f32 = 0.0;
        let debug_hit_cube_z: f32 = 0.0;
        let debug_hit_cube_sx: f32 = 0.0;
        let debug_hit_cube_sy: f32 = 0.0;
        let debug_hit_cube_sz: f32 = 0.0;
        let debug_hit_face: i32 = -1; // -1 = no face, 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
        let debug_is_ground_plane: i32 = 0;
        
        // FIRST: Test the big grey ground plane cube (100m x 100m x 1m at y = -500)
        // This is important geometry and needs to be pickable!
        let ground_cube_x: f32 = 0.0;
        let ground_cube_y: f32 = -500.0;
        let ground_cube_z: f32 = 0.0;
        let ground_cube_sx: f32 = 10000.0; // 100 meters
        let ground_cube_sy: f32 = 100.0;   // 1 meter thick
        let ground_cube_sz: f32 = 10000.0; // 100 meters
        
        let ground_cube_hit: i32 = heidic_raycast_cube_hit(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
        if ground_cube_hit == 1 {
            let ground_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
            let ground_cube_dist: f32 = (ground_cube_hit_point.x - debug_ray_origin.x) * (ground_cube_hit_point.x - debug_ray_origin.x) + (ground_cube_hit_point.y - debug_ray_origin.y) * (ground_cube_hit_point.y - debug_ray_origin.y) + (ground_cube_hit_point.z - debug_ray_origin.z) * (ground_cube_hit_point.z - debug_ray_origin.z);
            if ground_cube_dist < debug_closest_dist {
                debug_closest_dist = ground_cube_dist;
                debug_hit_pos = ground_cube_hit_point;
                debug_hit_cube_x = ground_cube_x;
                debug_hit_cube_y = ground_cube_y;
                debug_hit_cube_z = ground_cube_z;
                debug_hit_cube_sx = ground_cube_sx;
                debug_hit_cube_sy = ground_cube_sy;
                debug_hit_cube_sz = ground_cube_sz;
                debug_is_ground_plane = 1;
                debug_found_hit = 1;
            }
        }
        
        // Test all created cubes to find closest hit
        let debug_cube_index: i32 = 0;
        let debug_total_cubes: i32 = heidic_get_cube_total_count();
        while debug_cube_index < debug_total_cubes {
            if heidic_get_cube_active(debug_cube_index) == 1 {
                let debug_cube_x: f32 = heidic_get_cube_x(debug_cube_index);
                let debug_cube_y: f32 = heidic_get_cube_y(debug_cube_index);
                let debug_cube_z: f32 = heidic_get_cube_z(debug_cube_index);
                let debug_cube_sx: f32 = heidic_get_cube_sx(debug_cube_index);
                let debug_cube_sy: f32 = heidic_get_cube_sy(debug_cube_index);
                let debug_cube_sz: f32 = heidic_get_cube_sz(debug_cube_index);
                
                let debug_cube_hit: i32 = heidic_raycast_cube_hit(window, debug_cube_x, debug_cube_y, debug_cube_z, debug_cube_sx, debug_cube_sy, debug_cube_sz);
                if debug_cube_hit == 1 {
                    let debug_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, debug_cube_x, debug_cube_y, debug_cube_z, debug_cube_sx, debug_cube_sy, debug_cube_sz);
                    let debug_dist: f32 = (debug_hit_point.x - debug_ray_origin.x) * (debug_hit_point.x - debug_ray_origin.x) + (debug_hit_point.y - debug_ray_origin.y) * (debug_hit_point.y - debug_ray_origin.y) + (debug_hit_point.z - debug_ray_origin.z) * (debug_hit_point.z - debug_ray_origin.z);
                    if debug_dist < debug_closest_dist {
                        debug_closest_dist = debug_dist;
                        debug_hit_pos = debug_hit_point;
                        debug_hit_cube_x = debug_cube_x;
                        debug_hit_cube_y = debug_cube_y;
                        debug_hit_cube_z = debug_cube_z;
                        debug_hit_cube_sx = debug_cube_sx;
                        debug_hit_cube_sy = debug_cube_sy;
                        debug_hit_cube_sz = debug_cube_sz;
                        debug_is_ground_plane = 0;
                        debug_found_hit = 1;
                    }
                }
            }
            debug_cube_index = debug_cube_index + 1;
        }
        
        // If still no hit, place debug cube along the ray (5 meters out) so we can always see where the ray is pointing
        if debug_found_hit == 0 {
            debug_hit_pos = heidic_vec3_add(debug_ray_origin, heidic_vec3_mul_scalar(debug_ray_dir, 500.0));
        }
        
        // Always draw red wireframe cube to show where ray is pointing/hitting
        // Unit square (100 units = 1 meter) for better precision
        heidic_draw_cube_wireframe(debug_hit_pos.x, debug_hit_pos.y, debug_hit_pos.z, 0.0, 0.0, 0.0, 100.0, 100.0, 100.0, 1.0, 0.0, 0.0);
        
        // If we hit a cube, determine which face was hit and highlight it
        if debug_found_hit == 1 && debug_is_ground_plane == 0 {
            // Calculate cube bounds
            let debug_cube_min_x: f32 = debug_hit_cube_x - debug_hit_cube_sx / 2.0;
            let debug_cube_max_x: f32 = debug_hit_cube_x + debug_hit_cube_sx / 2.0;
            let debug_cube_min_y: f32 = debug_hit_cube_y - debug_hit_cube_sy / 2.0;
            let debug_cube_max_y: f32 = debug_hit_cube_y + debug_hit_cube_sy / 2.0;
            let debug_cube_min_z: f32 = debug_hit_cube_z - debug_hit_cube_sz / 2.0;
            let debug_cube_max_z: f32 = debug_hit_cube_z + debug_hit_cube_sz / 2.0;
            
            // Calculate distances from hit point to each face
            let debug_dist_to_left: f32 = debug_hit_pos.x - debug_cube_min_x;
            let debug_dist_to_right: f32 = debug_cube_max_x - debug_hit_pos.x;
            let debug_dist_to_bottom: f32 = debug_hit_pos.y - debug_cube_min_y;
            let debug_dist_to_top: f32 = debug_cube_max_y - debug_hit_pos.y;
            let debug_dist_to_back: f32 = debug_hit_pos.z - debug_cube_min_z;
            let debug_dist_to_front: f32 = debug_cube_max_z - debug_hit_pos.z;
            
            // Find the closest face (smallest distance)
            let debug_min_dist: f32 = debug_dist_to_left;
            debug_hit_face = 0; // 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
            
            if debug_dist_to_right < debug_min_dist {
                debug_min_dist = debug_dist_to_right;
                debug_hit_face = 1;
            }
            if debug_dist_to_bottom < debug_min_dist {
                debug_min_dist = debug_dist_to_bottom;
                debug_hit_face = 2;
            }
            if debug_dist_to_top < debug_min_dist {
                debug_min_dist = debug_dist_to_top;
                debug_hit_face = 3;
            }
            if debug_dist_to_back < debug_min_dist {
                debug_min_dist = debug_dist_to_back;
                debug_hit_face = 4;
            }
            if debug_dist_to_front < debug_min_dist {
                debug_min_dist = debug_dist_to_front;
                debug_hit_face = 5;
            }
            
            // Draw highlighted outline on the hit face (bright yellow/green)
            let highlight_offset: f32 = 1.0; // Small offset to avoid z-fighting
            if debug_hit_face == 0 {
                // Left face (negative X) - draw rectangle on left face
                let y1: f32 = debug_cube_min_y;
                let y2: f32 = debug_cube_max_y;
                let z1: f32 = debug_cube_min_z;
                let z2: f32 = debug_cube_max_z;
                let x: f32 = debug_cube_min_x - highlight_offset;
                heidic_draw_line(x, y1, z1, x, y2, z1, 0.0, 1.0, 0.0); // Bottom edge
                heidic_draw_line(x, y2, z1, x, y2, z2, 0.0, 1.0, 0.0); // Right edge
                heidic_draw_line(x, y2, z2, x, y1, z2, 0.0, 1.0, 0.0); // Top edge
                heidic_draw_line(x, y1, z2, x, y1, z1, 0.0, 1.0, 0.0); // Left edge
            } else {
                if debug_hit_face == 1 {
                    // Right face (positive X) - draw rectangle on right face
                    let y1: f32 = debug_cube_min_y;
                    let y2: f32 = debug_cube_max_y;
                    let z1: f32 = debug_cube_min_z;
                    let z2: f32 = debug_cube_max_z;
                    let x: f32 = debug_cube_max_x + highlight_offset;
                    heidic_draw_line(x, y1, z1, x, y2, z1, 0.0, 1.0, 0.0); // Bottom edge
                    heidic_draw_line(x, y2, z1, x, y2, z2, 0.0, 1.0, 0.0); // Right edge
                    heidic_draw_line(x, y2, z2, x, y1, z2, 0.0, 1.0, 0.0); // Top edge
                    heidic_draw_line(x, y1, z2, x, y1, z1, 0.0, 1.0, 0.0); // Left edge
                } else {
                    if debug_hit_face == 2 {
                        // Bottom face (negative Y) - draw rectangle on bottom face
                        let x1: f32 = debug_cube_min_x;
                        let x2: f32 = debug_cube_max_x;
                        let z1: f32 = debug_cube_min_z;
                        let z2: f32 = debug_cube_max_z;
                        let y: f32 = debug_cube_min_y - highlight_offset;
                        heidic_draw_line(x1, y, z1, x2, y, z1, 0.0, 1.0, 0.0); // Back edge
                        heidic_draw_line(x2, y, z1, x2, y, z2, 0.0, 1.0, 0.0); // Right edge
                        heidic_draw_line(x2, y, z2, x1, y, z2, 0.0, 1.0, 0.0); // Front edge
                        heidic_draw_line(x1, y, z2, x1, y, z1, 0.0, 1.0, 0.0); // Left edge
                    } else {
                        if debug_hit_face == 3 {
                            // Top face (positive Y) - draw rectangle on top face
                            let x1: f32 = debug_cube_min_x;
                            let x2: f32 = debug_cube_max_x;
                            let z1: f32 = debug_cube_min_z;
                            let z2: f32 = debug_cube_max_z;
                            let y: f32 = debug_cube_max_y + highlight_offset;
                            heidic_draw_line(x1, y, z1, x2, y, z1, 0.0, 1.0, 0.0); // Back edge
                            heidic_draw_line(x2, y, z1, x2, y, z2, 0.0, 1.0, 0.0); // Right edge
                            heidic_draw_line(x2, y, z2, x1, y, z2, 0.0, 1.0, 0.0); // Front edge
                            heidic_draw_line(x1, y, z2, x1, y, z1, 0.0, 1.0, 0.0); // Left edge
                        } else {
                            if debug_hit_face == 4 {
                                // Back face (negative Z) - draw rectangle on back face
                                let x1: f32 = debug_cube_min_x;
                                let x2: f32 = debug_cube_max_x;
                                let y1: f32 = debug_cube_min_y;
                                let y2: f32 = debug_cube_max_y;
                                let z: f32 = debug_cube_min_z - highlight_offset;
                                heidic_draw_line(x1, y1, z, x2, y1, z, 0.0, 1.0, 0.0); // Bottom edge
                                heidic_draw_line(x2, y1, z, x2, y2, z, 0.0, 1.0, 0.0); // Right edge
                                heidic_draw_line(x2, y2, z, x1, y2, z, 0.0, 1.0, 0.0); // Top edge
                                heidic_draw_line(x1, y2, z, x1, y1, z, 0.0, 1.0, 0.0); // Left edge
                            } else {
                                // Front face (positive Z) - draw rectangle on front face
                                let x1: f32 = debug_cube_min_x;
                                let x2: f32 = debug_cube_max_x;
                                let y1: f32 = debug_cube_min_y;
                                let y2: f32 = debug_cube_max_y;
                                let z: f32 = debug_cube_max_z + highlight_offset;
                                heidic_draw_line(x1, y1, z, x2, y1, z, 0.0, 1.0, 0.0); // Bottom edge
                                heidic_draw_line(x2, y1, z, x2, y2, z, 0.0, 1.0, 0.0); // Right edge
                                heidic_draw_line(x2, y2, z, x1, y2, z, 0.0, 1.0, 0.0); // Top edge
                                heidic_draw_line(x1, y2, z, x1, y1, z, 0.0, 1.0, 0.0); // Left edge
                            }
                        }
                    }
                }
            }
        }
        
        // Mouse mode toggle: Left-click enables mouse (cursor visible, picking on), Right-click disables (cursor hidden, dolly/look on)
        let mouse_left_pressed: i32 = heidic_is_mouse_button_pressed(window, 0);
        let mouse_right_pressed: i32 = heidic_is_mouse_button_pressed(window, 1);
        
        // Left-click: Enable mouse mode (cursor visible, picking enabled)
        if mouse_left_pressed == 1 {
            if mouse_mode_left_was_pressed == 0 {
                mouse_mode = 1; // Enable mouse mode
                heidic_set_cursor_mode(window, 0); // 0 = normal (visible cursor)
                mouse_mode_left_was_pressed = 1;
            }
        } else {
            mouse_mode_left_was_pressed = 0;
        }
        
        // Right-click: Disable mouse mode (cursor hidden, dolly/look enabled)
        if mouse_right_pressed == 1 {
            if mouse_mode_right_was_pressed == 0 {
                mouse_mode = 0; // Disable mouse mode
                if camera_mode == 1 {
                    // In walk mode, capture cursor for mouse look
                    heidic_set_cursor_mode(window, 2); // 2 = disabled (captured)
                } else {
                    // In top-down mode, just hide cursor
                    heidic_set_cursor_mode(window, 1); // 1 = hidden
                }
                mouse_mode_right_was_pressed = 1;
            }
        } else {
            mouse_mode_right_was_pressed = 0;
        }
        
        // DEBUG: Print ray info on click
        // if mouse_left_pressed == 1 {
        //    if mouse_left_was_pressed == 0 {
        //        heidic_debug_print_ray(window);
        //    }
        // }
        
        // Selection: Click to select cubes - test ALL cubes
        // Only allow selection when mouse_mode is enabled AND Alt is NOT pressed (Alt+Click is for orbit, not selection)
        if mouse_mode == 1 && mouse_left_pressed == 1 && alt_pressed == 0 {
            // Only check gizmo interaction if we're NOT doing a fresh click
            // This allows selection even if gizmo axes are being hovered
            let interacting: i32 = 0;
            if mouse_left_was_pressed == 1 {
                // Already was pressed - check if gizmo is actively being dragged
                interacting = heidic_gizmo_is_interacting();
            }
            
            if interacting == 0 {
                if mouse_left_was_pressed == 0 {
                    // Just clicked - test raycast against all cubes and find closest hit
                    has_selection = 0;
                    selected_cube_index = -1.0;
                    // Initialize closest_dist to a very large number (squared distance)
                    // 100,000,000,000.0 is roughly 316,000 units (3.16 km) distance
                    let closest_dist: f32 = 100000000000.0; 
                    
                    // Player cube is NOT selectable (it's invisible in walk mode and shouldn't interfere)
                    // Skip player cube selection test
                    
                    // Test Created Cubes (Dynamic system - indices start at 2.0)
                    let cube_test_index: i32 = 0;
                    let total_cubes_test: i32 = heidic_get_cube_total_count();
                    while cube_test_index < total_cubes_test {
                        if heidic_get_cube_active(cube_test_index) == 1 {
                            let test_cube_x: f32 = heidic_get_cube_x(cube_test_index);
                            let test_cube_y: f32 = heidic_get_cube_y(cube_test_index);
                            let test_cube_z: f32 = heidic_get_cube_z(cube_test_index);
                            let test_cube_sx: f32 = heidic_get_cube_sx(cube_test_index);
                            let test_cube_sy: f32 = heidic_get_cube_sy(cube_test_index);
                            let test_cube_sz: f32 = heidic_get_cube_sz(cube_test_index);
                            
                            let created_hit: i32 = heidic_raycast_cube_hit(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                            if created_hit == 1 {
                                let hit_point: Vec3 = heidic_raycast_cube_hit_point(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                                let dist: f32 = (hit_point.x - ray_origin.x) * (hit_point.x - ray_origin.x) + (hit_point.y - ray_origin.y) * (hit_point.y - ray_origin.y) + (hit_point.z - ray_origin.z) * (hit_point.z - ray_origin.z);
                                if dist < closest_dist {
                                    closest_dist = dist;
                                    has_selection = 1;
                                    // Map cube index to selected_cube_index: cube index 0 -> selected index 2.0, etc.
                                    let cube_index_f: f32 = heidic_int_to_float(cube_test_index);
                                    selected_cube_index = cube_index_f + 2.0;
                                    selected_cube_x = test_cube_x;
                                    selected_cube_y = test_cube_y;
                                    selected_cube_z = test_cube_z;
                                    selected_cube_sx = test_cube_sx;
                                    selected_cube_sy = test_cube_sy;
                                    selected_cube_sz = test_cube_sz;
                                    
                                    // Initialize dolly orbit state for new selection
                                    let target_pos: Vec3 = heidic_vec3(test_cube_x, test_cube_y, test_cube_z);
                                    let current_cam_pos: Vec3 = camera_pos;
                                    let calculated_distance: f32 = heidic_vec3_distance(current_cam_pos, target_pos);
                                    
                                    // Use calculated distance if reasonable, otherwise use default
                                    if calculated_distance > 10.0 && calculated_distance < 100000.0 {
                                        dolly_orbit_distance = calculated_distance;
                                    } else {
                                        dolly_orbit_distance = 2000.0; // Default: 20 meters (closer than before)
                                    }
                                    dolly_orbit_azimuth = 0.0; // Start from default angle
                                    dolly_orbit_elevation = 45.0; // 45 degree elevation
                                }
                            }
                        }
                        cube_test_index = cube_test_index + 1;
                    }
                    
                    // Player cube is not selectable, so no dolly orbit initialization needed
                    
                    // All starting cubes removed - only dynamically created cubes are selectable
                    
                    mouse_left_was_pressed = 1;
                }
            }
        } else {
            mouse_left_was_pressed = 0;
        }
        
        
        // Show selection and Gizmo
        if has_selection == 1 {
            // Draw wireframe overlay (black)
            heidic_draw_cube_wireframe(selected_cube_x, selected_cube_y, selected_cube_z, 0.0, 0.0, 0.0, selected_cube_sx * 1.01, selected_cube_sy * 1.01, selected_cube_sz * 1.01, 0.0, 0.0, 0.0);
            
            // Gizmo: Move selected object
            let new_pos: Vec3 = heidic_gizmo_translate(window, selected_cube_x, selected_cube_y, selected_cube_z);
            
            // Update selected position (the ghost)
            selected_cube_x = new_pos.x;
            selected_cube_y = new_pos.y;
            selected_cube_z = new_pos.z;
            
            // Player cube is not selectable, so only update created cubes
            // If moving Created Cubes (selected_cube_index >= 2.0)
            // Map: selected_cube_index 2.0 -> cube index 0, 3.0 -> 1, etc.
            if selected_cube_index >= 2.0 {
                let cube_storage_index: f32 = selected_cube_index - 2.0;
                heidic_set_cube_pos_f(cube_storage_index, selected_cube_x, selected_cube_y, selected_cube_z);
            }
        }
        
        // Test window for docking
        if show_debug == 1 {
            heidic_imgui_begin("Test Window");
            heidic_imgui_text("=== TEST WINDOW ===");
            heidic_imgui_text("This is a test window for docking!");
            heidic_imgui_text("Try docking this to the Debug Panel.");
            heidic_imgui_text_float("Selected Index", selected_cube_index);
            heidic_imgui_text_float("Selected X", selected_cube_x);
            heidic_imgui_text_float("Selected Y", selected_cube_y);
            heidic_imgui_text_float("Selected Z", selected_cube_z);
            
            heidic_imgui_text("=== CREATED CUBES ===");
            let active_cube_count: i32 = heidic_get_cube_count();
            let total_cube_count: i32 = heidic_get_cube_total_count();
            heidic_imgui_text_float("Active Cubes", heidic_int_to_float(active_cube_count));
            heidic_imgui_text_float("Total Cubes", heidic_int_to_float(total_cube_count));
            heidic_imgui_end();
        }
        
        // Player cube is not selectable, so no position syncing needed
        
        // Ground detection for player
        let ground_check_distance: f32 = 200.0; // 2 meters down
        is_grounded = heidic_raycast_ground_hit(player_pos.x, player_pos.y, player_pos.z, ground_check_distance);
        
        // Visual feedback: Draw ray from player to ground
        if is_grounded == 1 {
            let ground_hit: Vec3 = heidic_raycast_ground_hit_point(player_pos.x, player_pos.y, player_pos.z, ground_check_distance);
            // Draw green line from player to ground (grounded)
            heidic_draw_line(player_pos.x, player_pos.y, player_pos.z, ground_hit.x, ground_hit.y, ground_hit.z, 0.0, 1.0, 0.0);
        } else {
            // Draw red line straight down (not grounded)
            let ground_check_end: Vec3 = heidic_vec3(player_pos.x, player_pos.y - ground_check_distance, player_pos.z);
            heidic_draw_line(player_pos.x, player_pos.y, player_pos.z, ground_check_end.x, ground_check_end.y, ground_check_end.z, 1.0, 0.0, 0.0);
        }
        
        // ImGui
        if show_debug == 1 {
            heidic_imgui_begin("Debug Panel (F1 to Toggle)");
            
            // Display FPS
            let fps: f32 = heidic_get_fps();
            heidic_imgui_text_float("FPS", fps);
            
            heidic_imgui_text("Camera Mode (C to Toggle): ");
            if camera_mode == 0 {
                heidic_imgui_text("Top-Down");
            } else {
                heidic_imgui_text("FPS");
            }
            
            heidic_imgui_text("Camera Transform (1 unit = 1 cm)");
            camera_pos.x = heidic_imgui_drag_float("Cam X", camera_pos.x, 1.0);
            camera_pos.y = heidic_imgui_drag_float("Cam Y", camera_pos.y, 1.0);
            camera_pos.z = heidic_imgui_drag_float("Cam Z", camera_pos.z, 1.0);
            camera_rot.x = heidic_imgui_drag_float("Cam Rot X", camera_rot.x, 1.0);
            camera_rot.y = heidic_imgui_drag_float("Cam Rot Y", camera_rot.y, 1.0);
            camera_rot.z = heidic_imgui_drag_float("Cam Rot Z", camera_rot.z, 1.0);
            
            heidic_imgui_text("Player Transform");
            player_pos.x = heidic_imgui_drag_float("Player X", player_pos.x, 1.0);
            player_pos.y = heidic_imgui_drag_float("Player Y", player_pos.y, 1.0);
            player_pos.z = heidic_imgui_drag_float("Player Z", player_pos.z, 1.0);
            player_rot.x = heidic_imgui_drag_float("Player Rot X", player_rot.x, 1.0);
            player_rot.y = heidic_imgui_drag_float("Player Rot Y", player_rot.y, 1.0);
            player_rot.z = heidic_imgui_drag_float("Player Rot Z", player_rot.z, 1.0);
            
            cube_sx = heidic_imgui_drag_float("Cube Scale X", cube_sx, 1.0);
            cube_sy = heidic_imgui_drag_float("Cube Scale Y", cube_sy, 1.0);
            cube_sz = heidic_imgui_drag_float("Cube Scale Z", cube_sz, 1.0);
            
            // Display direction vectors
            heidic_imgui_text("Direction Vectors (W moves in Forward direction)");
            let debug_rot_y_rad: f32 = heidic_convert_degrees_to_radians(player_rot.y);
            let debug_forward_x: f32 = -heidic_sin(debug_rot_y_rad);
            let debug_forward_z: f32 = -heidic_cos(debug_rot_y_rad);
            let debug_right_x: f32 = heidic_cos(debug_rot_y_rad);
            let debug_right_z: f32 = -heidic_sin(debug_rot_y_rad);
            heidic_imgui_text_float("Forward X", debug_forward_x);
            heidic_imgui_text_float("Forward Z", debug_forward_z);
            heidic_imgui_text_float("Right X", debug_right_x);
            heidic_imgui_text_float("Right Z", debug_right_z);
            
            // Raycasting Info
            heidic_imgui_text("=== Raycasting ===");
            heidic_imgui_text("Mouse Screen Coords:");
            heidic_imgui_text_float("  Mouse X (screen)", mouse_x);
            heidic_imgui_text_float("  Mouse Y (screen)", mouse_y);
            
            heidic_imgui_text("Ray Origin (world):");
            heidic_imgui_text_float("  Ray Origin X", ray_origin.x);
            heidic_imgui_text_float("  Ray Origin Y", ray_origin.y);
            heidic_imgui_text_float("  Ray Origin Z", ray_origin.z);
            
            heidic_imgui_text("Ray Direction (normalized):");
            heidic_imgui_text_float("  Ray Dir X", ray_dir.x);
            heidic_imgui_text_float("  Ray Dir Y", ray_dir.y);
            heidic_imgui_text_float("  Ray Dir Z", ray_dir.z);

            heidic_imgui_text("Camera to Origin Dist:");
            let dist_camera_to_origin: f32 = (ray_origin.x - camera_pos.x) * (ray_origin.x - camera_pos.x) + (ray_origin.y - camera_pos.y) * (ray_origin.y - camera_pos.y) + (ray_origin.z - camera_pos.z) * (ray_origin.z - camera_pos.z);
            heidic_imgui_text_float("  Distance", dist_camera_to_origin);
            
            heidic_imgui_text("Selection:");
            if has_selection == 1 {
                heidic_imgui_text("  Selected Cube");
                heidic_imgui_text_float("  Index", selected_cube_index);
                heidic_imgui_text_float("  X", selected_cube_x);
                heidic_imgui_text_float("  Y", selected_cube_y);
                heidic_imgui_text_float("  Z", selected_cube_z);
            } else {
                heidic_imgui_text("  No Selection (Click to select)");
            }
            
            heidic_imgui_text("Ground Detection:");
            if is_grounded == 1 {
                heidic_imgui_text("  GROUNDED");
            } else {
                heidic_imgui_text("  IN AIR");
            }
            
            heidic_imgui_end();
        }
        
        heidic_end_frame();
    }
    
    // Save ImGui layout on shutdown
    heidic_imgui_save_layout("");
    
    heidic_cleanup_renderer();
    heidic_destroy_window(window);
    heidic_glfw_terminate();
}

