// EDEN ENGINE - Gateway Editor v1
// Features: ImGui, Programmatic Cube, FPS Camera, Frame Control

// Include EDEN Engine standard library
include "stdlib/eden.hd";

fn main(): void {
    // Visibility constants
    let VISIBLE: i32 = 1;
    let INVISIBLE: i32 = 0;
    print("Initializing GLFW...\n");
    if heidic_glfw_init() == 0 {
        return;
    }
    
    heidic_glfw_vulkan_hints();
    let window: GLFWwindow = heidic_create_window(1280, 720, "EDEN ENGINE - Gateway Editor v1");
    
    if heidic_init_renderer(window) == 0 {
        heidic_glfw_terminate();
        return;
    }
    
    // Load ImGui layout on startup
    let default_ini_path_load: string = "";
    heidic_imgui_load_layout(default_ini_path_load);
    
    // Start in windowed mode (1 = windowed)
    // Video mode: 0 = fullscreen, 1 = windowed
    
    // Player (Cube) Transform - using Vec3 for position and rotation
    // Spawn player away from the reference cubes (3000 units = 30 meters away)
    let player_pos: Vec3 = heidic_vec3(3000.0, 100.0, 3000.0); // 30m away, 1m above ground
    let player_rot: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
    
    // Camera Transform - will follow player with offset
    // Initial position will be set in loop with offset
    let camera_pos: Vec3 = heidic_vec3(0.0, 100.0, 0.0); // Will be updated in loop
    let camera_rot: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
    
    // Legacy variables for drawing (will be updated from Vec3)
    let cube_x: f32 = 0.0;
    let cube_y: f32 = 0.0;
    let cube_z: f32 = 0.0;
    let cube_rx: f32 = 0.0;
    let cube_ry: f32 = 0.0;
    let cube_rz: f32 = 0.0;
    
    // Cube Size (100 cm = 1 meter)
    let cube_sx: f32 = 100.0;
    let cube_sy: f32 = 100.0;
    let cube_sz: f32 = 100.0;
    
    // Movement Speed (cm per frame)
    let move_speed: f32 = 15.0; // Increased from 5.0 for faster movement
    
    // Rotation Speed (degrees per frame) - for Q/E keys (optional, mouse look is primary)
    let rot_speed: f32 = 2.0;
    
    // Mouse Look Sensitivity (degrees per pixel)
    let mouse_sensitivity: f32 = 0.1;
    
    // Pitch clamp limits (for camera rotation)
    let pitch_max: f32 = 90.0;
    let pitch_min: f32 = -90.0;
    
    // Debug UI State
    let show_debug: i32 = 1;
    let f1_was_pressed: i32 = 0;
    
    // Camera Mode: 0 = Top-Down, 1 = FPS
    let camera_mode: i32 = 1; // Start in Walk mode (FPS)
    let tab_was_pressed: i32 = 0;  // Tab key for camera toggle
    
    // Player cube visibility: INVISIBLE in walk mode, VISIBLE in top-down mode
    let player_cube_visible: i32 = VISIBLE;
    
    // Mouse mode: 0 = disabled (cursor captured, mouse look/dolly enabled), 1 = enabled (cursor visible, picking enabled)
    let mouse_mode: i32 = 1; // Start with mouse enabled (visible cursor) for top-down mode
    let mouse_mode_left_was_pressed: i32 = 0;
    let mouse_mode_right_was_pressed: i32 = 0;
    
    // Set cursor mode based on initial mouse mode
    heidic_set_cursor_mode(window, 0); // 0 = normal (visible) for top-down mode
    
    // Grid visibility toggle
    let show_grid: i32 = 1; // Start with grid visible
    let g_was_pressed: i32 = 0;
    
    // Video Mode: 0 = fullscreen, 1 = windowed
    let video_mode: i32 = 1; // Start in windowed mode
    let shift_enter_was_pressed: i32 = 0;
    
    // Selection state
    let selected_cube_x: f32 = 0.0;
    let selected_cube_y: f32 = 0.0;
    let selected_cube_z: f32 = 0.0;
    let selected_cube_sx: f32 = 0.0;
    let selected_cube_sy: f32 = 0.0;
    let selected_cube_sz: f32 = 0.0;
    let has_selection: i32 = 0; // 0 = no selection, 1 = has selection
    
    // Stored preview position (calculated every frame, used for actual placement)
    let stored_preview_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
    let stored_preview_valid: i32 = 0; // 1 = preview position is valid and ready to use
    let selected_cube_index: f32 = -1.0; // -1.0 = none, 0.0 = player, >= 2.0 = created cubes, >= 10000.0 = mesh instances
    
    // Mesh selection state
        let selected_mesh_instance_id: i32 = -1; // -1 = none, >= 0 = mesh instance ID
    let selected_mesh_x: f32 = 0.0;
    let selected_mesh_y: f32 = 0.0;
    let selected_mesh_z: f32 = 0.0;
    let has_mesh_selection: i32 = 0; // 0 = no mesh selection, 1 = has mesh selection
    
    // Wedge selection state
    let selected_wedge_index: i32 = -1; // -1 = none, >= 0 = wedge index
    let selected_wedge_x: f32 = 0.0;
    let selected_wedge_y: f32 = 0.0;
    let selected_wedge_z: f32 = 0.0;
    let selected_wedge_sx: f32 = 0.0;
    let selected_wedge_sy: f32 = 0.0;
    let selected_wedge_sz: f32 = 0.0;
    let has_wedge_selection: i32 = 0; // 0 = no wedge selection, 1 = has wedge selection
    
    // Ground detection
    let is_grounded: i32 = 0;
    
    // Mouse button state tracking
    let mouse_left_was_pressed: i32 = 0;
    let mouse_middle_was_pressed: i32 = 0;
    
    // Delete key state tracking
    let delete_was_pressed: i32 = 0;
    let key_0_was_pressed: i32 = 0;  // Key '0' for wedge creation (deprecated - now use build mode)
    
    // Build mode: 0 = cube mode, 1 = wedge mode
    let build_mode: i32 = 0; // Default to cube mode
    let key_1_was_pressed: i32 = 0; // Key '1' to switch to cube mode
    let key_2_was_pressed: i32 = 0; // Key '2' to switch to wedge mode
    
    // Wedge preview rotation (0-11, cycling through 12 custom orientations)
    // Custom rotation values for each position:
    // pos 0 = 270, 180, 90
    // pos 1 = 180, 90, 270
    // pos 2 = 90, 270, 180
    // pos 3 = 180, 0, 270
    // pos 4 = 180, 180, 90
    // pos 5 = 180, 90, 90
    // pos 6 = 180, 270, 90
    // pos 7 = 180, 0, 90
    // pos 8 = 180, 90, 180
    // pos 9 = 90, 270, 270
    // pos 10 = 90, 270, 90
    // pos 11 = 180, 0, 180
    let wedge_preview_rotation: i32 = 0;  // Start at position 0
    let last_wedge_preview_rotation: i32 = -1; // Track previous rotation to detect changes
    
    // C key state tracking (for combining cubes - separate from camera toggle C key)
    let combine_c_was_pressed: i32 = 0;
    let smooth_s_was_pressed: i32 = 0;
    
    // Level name buffer for input (managed by C++ side)
    // We'll use heidic_get_level_name() to get the current name
    
    // Top-down camera position (high up, looking down)
    let topdown_cam_height: f32 = 10000.0; // 100 meters up (zoom level)
    let topdown_cam_pan_x: f32 = 0.0; // Pan offset X
    let topdown_cam_pan_z: f32 = 0.0; // Pan offset Z
    let topdown_cam_pos: Vec3 = heidic_vec3(0.0, topdown_cam_height, 0.0); // 100 meters up
    let topdown_cam_rot: Vec3 = heidic_vec3(-90.0, 0.0, 0.0); // Looking straight down
    
    // Dolly orbit state (for orbiting around selected object)
    let dolly_orbit_azimuth: f32 = 0.0; // Horizontal angle around target
    let dolly_orbit_elevation: f32 = 45.0; // Vertical angle (0 = horizontal, 90 = straight up)
    let dolly_orbit_distance: f32 = 2000.0; // Distance from target (reduced from 5000 to 20 meters)
    let in_orbit_mode: i32 = 0; // Flag to prevent pan from overwriting orbit position
    let alt_was_pressed: i32 = 0; // Track Alt key state to detect when dolly starts
    
    // Reference Cube 1 removed - all cubes are now created dynamically
    
    // Spacebar state
    let space_was_pressed: i32 = 0;
    
    // Created cube size (2 meters = 200 units)
    let created_cube_size: f32 = 200.0;
    
    print("Starting loop...\n");
    
    while heidic_window_should_close(window) == 0 {
        heidic_poll_events();
        
        // Check if we're editing a combination name - if so, block all input except Enter/Escape
        let is_editing_combination: i32 = heidic_get_editing_combination_id();
        let block_input: i32 = 0;
        if is_editing_combination >= 0 {
            block_input = 1;
        }
        
        // Get mouse position and ray (always available for debug panel)
        let mouse_x: f32 = heidic_get_mouse_x(window);
        let mouse_y: f32 = heidic_get_mouse_y(window);
        
        // Get mouse ray
        let ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
        let ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
        
        // ESC always works (to close window)
        if heidic_is_key_pressed(window, 256) == 1 { // ESC
            // If editing, stop editing instead of closing window
            if is_editing_combination >= 0 {
                heidic_stop_editing_combination_name();
            } else {
                heidic_set_window_should_close(window, 1);
            }
        }
        
        // Alt + Mouse Drag for Camera Dolly (works in both modes)
        // Left Alt = 342, Right Alt = 346
        // Define alt_pressed outside block_input check so it's available everywhere
        let left_alt_pressed: i32 = heidic_is_key_pressed(window, 342);
        let right_alt_pressed: i32 = heidic_is_key_pressed(window, 346);
        let alt_pressed: i32 = 0;
        if left_alt_pressed == 1 {
            alt_pressed = 1;
        }
        if right_alt_pressed == 1 {
            alt_pressed = 1;
        }
        
        // Skip all other input if we're editing
        if block_input == 0 {
        
        // F1 Toggle Logic (290 is F1)
        let f1_is_pressed: i32 = heidic_is_key_pressed(window, 290);
        if f1_is_pressed == 1 {
            if f1_was_pressed == 0 {
                if show_debug == 1 {
                    show_debug = 0;
                } else {
                    show_debug = 1;
                }
                f1_was_pressed = 1;
            }
        } else {
            f1_was_pressed = 0;
        }
        
        // Component Mode Toggle (Key '1' = component mode, Key '2' = object mode)
        // Key code 49 = '1', 50 = '2'
        // Tab Key Toggle Logic (258 is Tab) - Switch between Top-Down and FPS camera
        let tab_is_pressed: i32 = heidic_is_key_pressed(window, 258);
        if tab_is_pressed == 1 {
            if tab_was_pressed == 0 {
                if camera_mode == 0 {
                    camera_mode = 1; // Switch to FPS
                    // Set cursor mode based on mouse_mode
                    if mouse_mode == 0 {
                        heidic_set_cursor_mode(window, 2); // 2 = disabled (captured)
                    } else {
                        heidic_set_cursor_mode(window, 0); // 0 = normal (visible)
                    }
                } else {
                    camera_mode = 0; // Switch to Top-Down
                    // Set cursor mode based on mouse_mode
                    if mouse_mode == 0 {
                        heidic_set_cursor_mode(window, 1); // 1 = hidden
                    } else {
                        heidic_set_cursor_mode(window, 0); // 0 = normal (visible)
                    }
                }
                tab_was_pressed = 1;
            }
        } else {
            tab_was_pressed = 0;
        }
        
        // Only allow dolly/look when mouse_mode is disabled
        if alt_pressed == 1 && mouse_mode == 0 {
            // Dolly orbit around selected object (if there's a selection)
            if has_selection == 1 {
                // Initialize orbit angles from current camera position when Alt is first pressed
                if alt_was_pressed == 0 {
                    // Calculate current camera position relative to target
                    let target_pos: Vec3 = heidic_vec3(selected_cube_x, selected_cube_y, selected_cube_z);
                    let current_cam_pos: Vec3 = camera_pos;
                    let to_camera: Vec3 = heidic_vec3_sub(current_cam_pos, target_pos);
                    let dist: f32 = heidic_vec3_distance(current_cam_pos, target_pos);
                    
                    if dist > 0.001 {
                        // Normalize direction vector
                        let dir_x: f32 = to_camera.x / dist;
                        let dir_y: f32 = to_camera.y / dist;
                        let dir_z: f32 = to_camera.z / dist;
                        
                        // Calculate azimuth from XZ components (horizontal angle)
                        let azimuth_rad: f32 = heidic_atan2(dir_x, dir_z);
                        dolly_orbit_azimuth = heidic_convert_radians_to_degrees(azimuth_rad);
                        
                        // Calculate elevation from Y component (vertical angle)
                        let elevation_rad: f32 = heidic_asin(dir_y);
                        dolly_orbit_elevation = heidic_convert_radians_to_degrees(elevation_rad);
                        
                        // Update distance to match current camera distance
                        if dist > 10.0 && dist < 100000.0 {
                            dolly_orbit_distance = dist;
                        }
                    }
                }
                
                // Get mouse delta for orbit movement
                let dolly_delta_x: f32 = heidic_get_mouse_delta_x(window);
                let dolly_delta_y: f32 = heidic_get_mouse_delta_y(window);
                
                // Orbit sensitivity (degrees per pixel) - LearnOpenGL style
                let orbit_sensitivity: f32 = 0.3; // Reduced for smoother feel
                
                // Update orbit angles (Track/Orbit)
                dolly_orbit_azimuth = dolly_orbit_azimuth - dolly_delta_x * orbit_sensitivity; // Horizontal rotation (yaw)
                dolly_orbit_elevation = dolly_orbit_elevation + dolly_delta_y * orbit_sensitivity; // Vertical rotation (pitch)
                
                // Clamp elevation to prevent gimbal lock (LearnOpenGL standard)
                if dolly_orbit_elevation > 89.0 {
                    dolly_orbit_elevation = 89.0;
                }
                if dolly_orbit_elevation < -89.0 {
                    dolly_orbit_elevation = -89.0;
                }
                
                // Target position (selected object)
                let target_pos: Vec3 = heidic_vec3(selected_cube_x, selected_cube_y, selected_cube_z);
                
                // Calculate camera position using spherical coordinates (Y-up system)
                // Standard spherical coordinates for orbit camera:
                // - Azimuth: rotation around Y axis (horizontal)
                // - Elevation: angle from horizontal plane (vertical, -90 to +90)
                let azimuth_rad: f32 = heidic_convert_degrees_to_radians(dolly_orbit_azimuth);
                let elevation_rad: f32 = heidic_convert_degrees_to_radians(dolly_orbit_elevation);
                
                // Spherical to Cartesian conversion (Y-up, right-handed)
                // When elevation = 0: camera is at same Y as target (horizontal)
                // When elevation = 90: camera is directly above target
                // When elevation = -90: camera is directly below target
                // X = distance * cos(elevation) * sin(azimuth)
                // Y = distance * sin(elevation)  [This allows negative Y when elevation < 0]
                // Z = distance * cos(elevation) * cos(azimuth)
                let cos_elev: f32 = heidic_cos(elevation_rad);
                let sin_elev: f32 = heidic_sin(elevation_rad);
                let cos_azim: f32 = heidic_cos(azimuth_rad);
                let sin_azim: f32 = heidic_sin(azimuth_rad);
                
                let offset_x: f32 = dolly_orbit_distance * cos_elev * sin_azim;
                let offset_y: f32 = dolly_orbit_distance * sin_elev;  // Can be negative!
                let offset_z: f32 = dolly_orbit_distance * cos_elev * cos_azim;
                
                let offset: Vec3 = heidic_vec3(offset_x, offset_y, offset_z);
                let new_cam_pos: Vec3 = heidic_vec3_add(target_pos, offset);
                
                // NO Y RESTRICTIONS - camera can go anywhere in 3D space
                
                // Track that we're in orbit mode (prevent pan update from overwriting)
                in_orbit_mode = 1;
                
                if camera_mode == 0 {
                    // Top-Down Mode: Update camera position and look at target
                    topdown_cam_pos = new_cam_pos;
                    camera_pos = new_cam_pos;
                    
                    // Calculate direction vector from camera to target
                    let to_target: Vec3 = heidic_vec3_sub(target_pos, new_cam_pos);
                    let dist_to_target: f32 = heidic_vec3_distance(new_cam_pos, target_pos);
                    
                    // Calculate yaw and pitch from direction vector to ensure camera always faces target
                    if dist_to_target > 0.001 {
                        // Normalize direction (we'll calculate components manually)
                        let dir_x: f32 = to_target.x / dist_to_target;
                        let dir_y: f32 = to_target.y / dist_to_target;
                        let dir_z: f32 = to_target.z / dist_to_target;
                        
                        // Yaw: rotation around Y axis (horizontal)
                        // atan2(x, z) gives angle in XZ plane (0째 = +Z, 90째 = +X)
                        let yaw_rad: f32 = heidic_atan2(dir_x, dir_z);
                        let yaw_deg: f32 = heidic_convert_radians_to_degrees(yaw_rad);
                        
                        // Pitch: rotation around X axis (vertical)
                        // asin(y) gives elevation angle (-90째 to +90째)
                        let pitch_rad: f32 = heidic_asin(dir_y);
                        let pitch_deg: f32 = heidic_convert_radians_to_degrees(pitch_rad);
                        
                        topdown_cam_rot.x = pitch_deg;   // Pitch (vertical)
                        topdown_cam_rot.y = yaw_deg;     // Yaw (horizontal)
                        topdown_cam_rot.z = 0.0;         // Roll (no roll)
                    } else {
                        // Too close, use fallback angles
                        topdown_cam_rot.x = -dolly_orbit_elevation;
                        topdown_cam_rot.y = dolly_orbit_azimuth + 180.0;
                        topdown_cam_rot.z = 0.0;
                    }
                    camera_rot = topdown_cam_rot;
                } else {
                    // FPS Mode: Update player position to orbit around target
                    player_pos = new_cam_pos;
                    
                    // Calculate direction vector from camera to target
                    let to_target: Vec3 = heidic_vec3_sub(target_pos, new_cam_pos);
                    let dist_to_target: f32 = heidic_vec3_distance(new_cam_pos, target_pos);
                    
                    // Calculate yaw and pitch from direction vector
                    if dist_to_target > 0.001 {
                        let dir_x: f32 = to_target.x / dist_to_target;
                        let dir_y: f32 = to_target.y / dist_to_target;
                        let dir_z: f32 = to_target.z / dist_to_target;
                        
                        let yaw_rad: f32 = heidic_atan2(dir_x, dir_z);
                        let yaw_deg: f32 = heidic_convert_radians_to_degrees(yaw_rad);
                        
                        let pitch_rad: f32 = heidic_asin(dir_y);
                        let pitch_deg: f32 = heidic_convert_radians_to_degrees(pitch_rad);
                        
                        player_rot.y = yaw_deg;   // Yaw (horizontal)
                        player_rot.x = pitch_deg;  // Pitch (vertical)
                    } else {
                        // Fallback
                        player_rot.y = dolly_orbit_azimuth + 180.0;
                        player_rot.x = -dolly_orbit_elevation;
                    }
                }
            } else {
                // No selection: use general dolly (same logic as walk mode)
                let dolly_delta_x: f32 = heidic_get_mouse_delta_x(window);
                let dolly_delta_y: f32 = heidic_get_mouse_delta_y(window);
                let dolly_speed: f32 = 20.0;
                
                if camera_mode == 0 {
                    // Top-down editor camera: use same dolly logic as walk mode
                    // Calculate forward/right vectors from camera yaw rotation
                    let yaw_rad: f32 = heidic_convert_degrees_to_radians(topdown_cam_rot.y);
                    let forward_x: f32 = heidic_sin(yaw_rad);
                    let forward_z: f32 = heidic_cos(yaw_rad);
                    let right_x: f32 = heidic_cos(yaw_rad);
                    let right_z: f32 = -heidic_sin(yaw_rad);
                    let move_x: f32 = right_x * dolly_delta_x * dolly_speed + forward_x * dolly_delta_y * dolly_speed;
                    let move_z: f32 = right_z * dolly_delta_x * dolly_speed + forward_z * dolly_delta_y * dolly_speed;
                    // Move camera position (pan offset) based on calculated movement
                    topdown_cam_pan_x = topdown_cam_pan_x + move_x;
                    topdown_cam_pan_z = topdown_cam_pan_z + move_z;
                } else {
                    // Walk mode: keep existing perfect dolly logic (DO NOT CHANGE)
                    let yaw_rad: f32 = heidic_convert_degrees_to_radians(player_rot.y);
                    let forward_x: f32 = heidic_sin(yaw_rad);
                    let forward_z: f32 = heidic_cos(yaw_rad);
                    let right_x: f32 = heidic_cos(yaw_rad);
                    let right_z: f32 = -heidic_sin(yaw_rad);
                    let move_x: f32 = right_x * dolly_delta_x * dolly_speed + forward_x * dolly_delta_y * dolly_speed;
                    let move_z: f32 = right_z * dolly_delta_x * dolly_speed + forward_z * dolly_delta_y * dolly_speed;
                    player_pos.x = player_pos.x + move_x;
                    player_pos.z = player_pos.z + move_z;
                }
            }
            alt_was_pressed = 1; // Mark Alt as pressed
        } else {
            alt_was_pressed = 0; // Reset when Alt is released
        }
        
        // Mouse Look (only in FPS mode, only when mouse_mode is disabled, and only when Alt is NOT pressed)
        if camera_mode == 1 && mouse_mode == 0 && alt_pressed == 0 {
            // Get mouse delta
            let mouse_delta_x: f32 = heidic_get_mouse_delta_x(window);
            let mouse_delta_y: f32 = heidic_get_mouse_delta_y(window);
            
            // Update yaw (horizontal rotation) - rotate around Y axis
            // Reversed: mouse right = turn right (natural FPS feel)
            player_rot.y = player_rot.y - mouse_delta_x * mouse_sensitivity;
            
            // Update pitch (vertical rotation) - rotate around X axis
            // Clamp pitch to prevent flipping (typically -90 to +90 degrees)
            player_rot.x = player_rot.x - mouse_delta_y * mouse_sensitivity;
            
            // Clamp pitch to prevent camera flipping
            if player_rot.x > pitch_max {
                player_rot.x = pitch_max;
            }
            // Clamp minimum pitch (check if pitch_min is greater than current - inverted logic)
            let pitch_check: f32 = pitch_min - player_rot.x;
            if pitch_check > 0.0 {
                player_rot.x = pitch_min;
            }
        }
        
        // G Key Toggle Logic (71 is G) - Toggle ground plane grid visibility
        let g_is_pressed: i32 = heidic_is_key_pressed(window, 71);
        if g_is_pressed == 1 {
            if g_was_pressed == 0 {
                if show_grid == 1 {
                    show_grid = 0; // Hide grid
                } else {
                    show_grid = 1; // Show grid
                }
                g_was_pressed = 1;
            }
        } else {
            g_was_pressed = 0;
        }
        
        // Build mode switching: '1' = cube mode, '2' = wedge mode
        let key_1_pressed: i32 = heidic_is_key_pressed(window, 49); // ASCII '1'
        if key_1_pressed == 1 {
            if key_1_was_pressed == 0 {
                build_mode = 0; // Switch to cube mode
                print("Build mode: Cube\n");
            }
            key_1_was_pressed = 1;
        } else {
            key_1_was_pressed = 0;
        }
        
        let key_2_pressed: i32 = heidic_is_key_pressed(window, 50); // ASCII '2'
        if key_2_pressed == 1 {
            if key_2_was_pressed == 0 {
                build_mode = 1; // Switch to wedge mode
                print("Build mode: Wedge\n");
            }
            key_2_was_pressed = 1;
        } else {
            key_2_was_pressed = 0;
        }
        
        // Mouse wheel rotation for wedge preview (only in wedge mode)
        if build_mode == 1 {
            let mouse_scroll: f32 = heidic_get_mouse_scroll_y(window);
            // Use a threshold to handle fractional scroll values (trackpads, high-DPI mice)
            // Accumulate small values until we get a meaningful scroll
            let scroll_threshold: f32 = 0.1; // Minimum scroll amount to trigger rotation
            
            // Process scroll even if ImGui wants mouse - we capture it before ImGui
            // But only if we're not hovering over an ImGui window (to avoid conflicts)
            if heidic_imgui_wants_mouse() == 0 {
                if mouse_scroll > scroll_threshold {
                    // Scroll up (pulling): cycle backward through 12 orientations (0 -> 11 -> ... -> 1 -> 0)
                    wedge_preview_rotation = wedge_preview_rotation - 1;
                    if wedge_preview_rotation < 0 {
                        wedge_preview_rotation = 11;
                    }
                } else {
                    if mouse_scroll < -scroll_threshold {
                        // Scroll down (pushing): cycle forward through 12 orientations (0 -> 1 -> ... -> 11 -> 0)
                        wedge_preview_rotation = wedge_preview_rotation + 1;
                        if wedge_preview_rotation > 11 {
                            wedge_preview_rotation = 0;
                        }
                    }
                }
            }
        }
        
        // Spacebar (32) - Create new cube or wedge at mouse ray hit point (based on build_mode)
        // Works in any mode - always uses mouse ray to find placement position
        // Also try key code 57 as fallback (some systems use different codes)
        let space_is_pressed: i32 = heidic_is_key_pressed(window, 32);
        // Fallback: try key code 57 if 32 doesn't work
        if space_is_pressed == 0 {
            space_is_pressed = heidic_is_key_pressed(window, 57);
        }
        
        if space_is_pressed == 1 {
            if space_was_pressed == 0 {
                print("SPACEBAR PRESSED! Creating cube at ray hit point\n");
                
                // Default cube size (1 meter = 100 units)
                let default_cube_size: f32 = 100.0;
                
                // Use the stored preview position if available (calculated this frame)
                // This ensures exact match between preview and placement
                let create_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
                if stored_preview_valid == 1 {
                    // Use the preview position directly - this is exactly where the red cube is
                    create_pos = stored_preview_pos;
                    print("Using stored preview position for cube placement\n");
                } else {
                    // Fallback: calculate placement (shouldn't happen, but just in case)
                    print("WARNING: No valid preview position, calculating placement\n");
                    
                    // Always use mouse ray to find where to place the cube
                    let create_ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
                    let create_ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
                let found_hit: i32 = 0;
                let closest_dist: f32 = 100000000000.0; // Very large distance
                let hit_cube_x: f32 = 0.0;
                let hit_cube_y: f32 = 0.0;
                let hit_cube_z: f32 = 0.0;
                let hit_cube_sx: f32 = 0.0;
                let hit_cube_sy: f32 = 0.0;
                let hit_cube_sz: f32 = 0.0;
                let hit_point: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
                let is_ground_plane: i32 = 0;
                let is_wedge: i32 = 0; // 1 = hit object is a wedge, 0 = cube or other
                
                // FIRST: Test the big grey ground plane cube (100m x 100m x 1m at y = -500)
                // This is important geometry and needs to be pickable!
                let ground_cube_x: f32 = 0.0;
                let ground_cube_y: f32 = -500.0;
                let ground_cube_z: f32 = 0.0;
                let ground_cube_sx: f32 = 10000.0; // 100 meters
                let ground_cube_sy: f32 = 100.0;   // 1 meter thick
                let ground_cube_sz: f32 = 10000.0; // 100 meters
                
                let ground_cube_hit: i32 = heidic_raycast_cube_hit(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                if ground_cube_hit == 1 {
                    let ground_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                    let ground_cube_dist: f32 = (ground_cube_hit_point.x - create_ray_origin.x) * (ground_cube_hit_point.x - create_ray_origin.x) + (ground_cube_hit_point.y - create_ray_origin.y) * (ground_cube_hit_point.y - create_ray_origin.y) + (ground_cube_hit_point.z - create_ray_origin.z) * (ground_cube_hit_point.z - create_ray_origin.z);
                    if ground_cube_dist < closest_dist {
                        closest_dist = ground_cube_dist;
                        create_pos = ground_cube_hit_point;
                        hit_point = ground_cube_hit_point;
                        hit_cube_x = ground_cube_x;
                        hit_cube_y = ground_cube_y;
                        hit_cube_z = ground_cube_z;
                        hit_cube_sx = ground_cube_sx;
                        hit_cube_sy = ground_cube_sy;
                        hit_cube_sz = ground_cube_sz;
                        is_ground_plane = 1;
                        found_hit = 1;
                    }
                }
                
                // Test all created cubes to find closest hit
                let cube_test_index: i32 = 0;
                let total_cubes_test: i32 = heidic_get_cube_total_count();
                while cube_test_index < total_cubes_test {
                    if heidic_get_cube_active(cube_test_index) == 1 {
                        let test_cube_x: f32 = heidic_get_cube_x(cube_test_index);
                        let test_cube_y: f32 = heidic_get_cube_y(cube_test_index);
                        let test_cube_z: f32 = heidic_get_cube_z(cube_test_index);
                        let test_cube_sx: f32 = heidic_get_cube_sx(cube_test_index);
                        let test_cube_sy: f32 = heidic_get_cube_sy(cube_test_index);
                        let test_cube_sz: f32 = heidic_get_cube_sz(cube_test_index);
                        
                        let cube_hit: i32 = heidic_raycast_cube_hit(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                        if cube_hit == 1 {
                            let test_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                            let dist: f32 = (test_hit_point.x - create_ray_origin.x) * (test_hit_point.x - create_ray_origin.x) + (test_hit_point.y - create_ray_origin.y) * (test_hit_point.y - create_ray_origin.y) + (test_hit_point.z - create_ray_origin.z) * (test_hit_point.z - create_ray_origin.z);
                            if dist < closest_dist {
                                closest_dist = dist;
                                create_pos = test_hit_point;
                                // Store the hit cube's position, size, and hit point for face detection
                                hit_point = test_hit_point;
                                hit_cube_x = test_cube_x;
                                hit_cube_y = test_cube_y;
                                hit_cube_z = test_cube_z;
                                hit_cube_sx = test_cube_sx;
                                hit_cube_sy = test_cube_sy;
                                hit_cube_sz = test_cube_sz;
                                is_ground_plane = 0;
                                found_hit = 1;
                            }
                        }
                    }
                    cube_test_index = cube_test_index + 1;
                }
                
                if found_hit == 1 {
                    // Ray hit a cube or ground plane - use same calculation as preview
                    if is_ground_plane == 1 {
                        // Ground plane: always stack on top
                        let hit_top_y: f32 = hit_cube_y + hit_cube_sy / 2.0;
                        create_pos.y = hit_top_y + default_cube_size / 2.0;
                        create_pos.x = hit_point.x;
                        create_pos.z = hit_point.z;
                        print("Hit ground plane! Stacking on top\n");
                    } else {
                        // Regular cube or wedge: use exact same calculation as preview
                        // Calculate bounds
                        let cube_min_x: f32 = hit_cube_x - hit_cube_sx / 2.0;
                        let cube_max_x: f32 = hit_cube_x + hit_cube_sx / 2.0;
                        let cube_min_y: f32 = hit_cube_y - hit_cube_sy / 2.0;
                        let cube_max_y: f32 = hit_cube_y + hit_cube_sy / 2.0;
                        let cube_min_z: f32 = hit_cube_z - hit_cube_sz / 2.0;
                        let cube_max_z: f32 = hit_cube_z + hit_cube_sz / 2.0;
                        
                        // Calculate distances from hit point to each face
                        let dist_to_left: f32 = hit_point.x - cube_min_x;
                        let dist_to_right: f32 = cube_max_x - hit_point.x;
                        let dist_to_bottom: f32 = hit_point.y - cube_min_y;
                        let dist_to_top: f32 = cube_max_y - hit_point.y;
                        let dist_to_back: f32 = hit_point.z - cube_min_z;
                        let dist_to_front: f32 = cube_max_z - hit_point.z;
                        
                        // Find the closest face (same logic as preview)
                        // For both cubes and wedges, check all 6 faces of the bounding box
                        // (Wedges are inscribed in a cube, so we treat them the same as cubes)
                        let min_dist: f32 = dist_to_left;
                        let hit_face: i32 = 0; // 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
                        
                        // Check all faces (works for both cubes and wedges)
                        if dist_to_right < min_dist {
                            min_dist = dist_to_right;
                            hit_face = 1;
                        }
                        if dist_to_bottom < min_dist {
                            min_dist = dist_to_bottom;
                            hit_face = 2;
                        }
                        if dist_to_top < min_dist {
                            min_dist = dist_to_top;
                            hit_face = 3;
                        }
                        if dist_to_back < min_dist {
                            min_dist = dist_to_back;
                            hit_face = 4;
                        }
                        if dist_to_front < min_dist {
                            min_dist = dist_to_front;
                            hit_face = 5;
                        }
                        
                        // Calculate placement position (exact same logic as preview)
                        if hit_face == 0 {
                            // Left face (negative X) - stack to the left
                            create_pos.x = cube_min_x - default_cube_size / 2.0;
                            create_pos.y = hit_cube_y;
                            create_pos.z = hit_cube_z;
                            print("Hit left face! Stacking to the left\n");
                        } else {
                            if hit_face == 1 {
                                // Right face (positive X) - stack to the right
                                create_pos.x = cube_max_x + default_cube_size / 2.0;
                                create_pos.y = hit_cube_y;
                                create_pos.z = hit_cube_z;
                                print("Hit right face! Stacking to the right\n");
                            } else {
                                if hit_face == 2 {
                                    // Bottom face (negative Y) - stack below
                                    create_pos.x = hit_cube_x;
                                    create_pos.y = cube_min_y - default_cube_size / 2.0;
                                    create_pos.z = hit_cube_z;
                                    print("Hit bottom face! Stacking below\n");
                                } else {
                                    if hit_face == 3 {
                                        // Top face (positive Y) - stack on top
                                        create_pos.x = hit_cube_x;
                                        create_pos.y = cube_max_y + default_cube_size / 2.0;
                                        create_pos.z = hit_cube_z;
                                        print("Hit top face! Stacking on top\n");
                                    } else {
                                        if hit_face == 4 {
                                            // Back face (negative Z) - stack to the back
                                            create_pos.x = hit_cube_x;
                                            create_pos.y = hit_cube_y;
                                            create_pos.z = cube_min_z - default_cube_size / 2.0;
                                            print("Hit back face! Stacking to the back\n");
                                        } else {
                                            // Front face (positive Z) - stack to the front
                                            create_pos.x = hit_cube_x;
                                            create_pos.y = hit_cube_y;
                                            create_pos.z = cube_max_z + default_cube_size / 2.0;
                                            print("Hit front face! Stacking to the front\n");
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // No hit - place cube 5 meters (500 units) along the ray
                    create_pos = heidic_vec3_add(create_ray_origin, heidic_vec3_mul_scalar(create_ray_dir, 500.0));
                    print("No hit, placing cube along ray\n");
                }
                } // End of fallback calculation (if stored_preview_valid == 0)
                
                // Generate random color for the new block
                // Use white color (1,1,1) so texture displays at full brightness
                let block_r: f32 = 1.0;
                let block_g: f32 = 1.0;
                let block_b: f32 = 1.0;
                
                // Create block based on build mode
                let block_index: i32 = -1;
                if build_mode == 0 {
                    // Cube mode: create cube
                    block_index = heidic_create_cube_with_color(create_pos.x, create_pos.y, create_pos.z, default_cube_size, default_cube_size, default_cube_size, block_r, block_g, block_b);
                    print("Created cube at index: ");
                } else {
                    // Wedge mode: create wedge with rotation
                    // Custom rotation values for each of the 12 positions
                    let wedge_rot_x: f32 = 0.0;
                    let wedge_rot_y: f32 = 0.0;
                    let wedge_rot_z: f32 = 0.0;
                    
                    if wedge_preview_rotation == 0 {
                        wedge_rot_x = 270.0;
                        wedge_rot_y = 180.0;
                        wedge_rot_z = 90.0;
                    } else {
                        if wedge_preview_rotation == 1 {
                            wedge_rot_x = 180.0;
                            wedge_rot_y = 90.0;
                            wedge_rot_z = 270.0;
                        } else {
                            if wedge_preview_rotation == 2 {
                                wedge_rot_x = 90.0;
                                wedge_rot_y = 270.0;
                                wedge_rot_z = 180.0;
                            } else {
                                if wedge_preview_rotation == 3 {
                                    wedge_rot_x = 180.0;
                                    wedge_rot_y = 0.0;
                                    wedge_rot_z = 270.0;
                                } else {
                                    if wedge_preview_rotation == 4 {
                                        wedge_rot_x = 180.0;
                                        wedge_rot_y = 180.0;
                                        wedge_rot_z = 90.0;
                                    } else {
                                        if wedge_preview_rotation == 5 {
                                            wedge_rot_x = 180.0;
                                            wedge_rot_y = 90.0;
                                            wedge_rot_z = 90.0;
                                        } else {
                                            if wedge_preview_rotation == 6 {
                                                wedge_rot_x = 180.0;
                                                wedge_rot_y = 270.0;
                                                wedge_rot_z = 90.0;
                                            } else {
                                                if wedge_preview_rotation == 7 {
                                                    wedge_rot_x = 180.0;
                                                    wedge_rot_y = 0.0;
                                                    wedge_rot_z = 90.0;
                                                } else {
                                                    if wedge_preview_rotation == 8 {
                                                        wedge_rot_x = 180.0;
                                                        wedge_rot_y = 90.0;
                                                        wedge_rot_z = 180.0;
                                                    } else {
                                                        if wedge_preview_rotation == 9 {
                                                            wedge_rot_x = 90.0;
                                                            wedge_rot_y = 270.0;
                                                            wedge_rot_z = 270.0;
                                                        } else {
                                                            if wedge_preview_rotation == 10 {
                                                                wedge_rot_x = 90.0;
                                                                wedge_rot_y = 270.0;
                                                                wedge_rot_z = 90.0;
                                                            } else {
                                                                if wedge_preview_rotation == 11 {
                                                                    wedge_rot_x = 180.0;
                                                                    wedge_rot_y = 0.0;
                                                                    wedge_rot_z = 180.0;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    block_index = heidic_create_wedge_with_color(create_pos.x, create_pos.y, create_pos.z, default_cube_size, default_cube_size, default_cube_size, block_r, block_g, block_b);
                    // Set the wedge rotation
                    heidic_set_wedge_rotation(block_index, wedge_rot_x, wedge_rot_y, wedge_rot_z);
                    print("Created wedge at index: ");
                }
                
                if block_index >= 0 {
                    print(block_index);
                    print("\n");
                    
                    // Select the newly created block
                    has_selection = 1;
                    // Convert index to float and add 2.0 offset
                    selected_cube_index = heidic_int_to_float(block_index) + 2.0;
                    // Update selected cube properties for gizmo
                    selected_cube_x = create_pos.x;
                    selected_cube_y = create_pos.y;
                    selected_cube_z = create_pos.z;
                    selected_cube_sx = default_cube_size;
                    selected_cube_sy = default_cube_size;
                    selected_cube_sz = default_cube_size;
                } else {
                    if build_mode == 0 {
                        print("Failed to create cube\n");
                    } else {
                        print("Failed to create wedge\n");
                    }
                }
                
                space_was_pressed = 1;
            }
            } else {
                space_was_pressed = 0;
            }
            
            // Key '0' (48) - Create wedge at mouse ray hit point (simplified - just stack on top)
            let key_0_pressed: i32 = heidic_is_key_pressed(window, 48);
            if key_0_pressed == 1 {
                if key_0_was_pressed == 0 {
                    print("KEY '0' PRESSED! Creating wedge at ray hit point\n");
                    
                    // Default wedge size (1 meter = 100 units, same as cube)
                    let default_wedge_size: f32 = 100.0;
                    
                    // Always use mouse ray to find where to place the wedge
                    let create_ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
                    let create_ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
                    
                    // Simple: just test ground plane and place wedge on top
                    let create_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
                    let found_hit: i32 = 0;
                    
                    // Test ground plane
                    let ground_cube_x: f32 = 0.0;
                    let ground_cube_y: f32 = -500.0;
                    let ground_cube_z: f32 = 0.0;
                    let ground_cube_sx: f32 = 10000.0;
                    let ground_cube_sy: f32 = 100.0;
                    let ground_cube_sz: f32 = 10000.0;
                    
                    let ground_cube_hit: i32 = heidic_raycast_cube_hit(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                    if ground_cube_hit == 1 {
                        let ground_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                        create_pos.y = ground_cube_y + ground_cube_sy / 2.0 + default_wedge_size / 2.0;
                        create_pos.x = ground_cube_hit_point.x;
                        create_pos.z = ground_cube_hit_point.z;
                        found_hit = 1;
                    } else {
                        // No hit - place wedge 5 meters (500 units) along the ray
                        create_pos = heidic_vec3_add(create_ray_origin, heidic_vec3_mul_scalar(create_ray_dir, 500.0));
                    }
                    
                    // Create wedge with white color (full texture brightness)
                    let wedge_r: f32 = 1.0;
                    let wedge_g: f32 = 1.0;
                    let wedge_b: f32 = 1.0;
                    
                    let wedge_index: i32 = heidic_create_wedge_with_color(create_pos.x, create_pos.y, create_pos.z, default_wedge_size, default_wedge_size, default_wedge_size, wedge_r, wedge_g, wedge_b);
                    
                    if wedge_index >= 0 {
                        print("Created wedge at index: ");
                        print(wedge_index);
                        print("\n");
                    }
                    
                    key_0_was_pressed = 1;
                }
            } else {
                key_0_was_pressed = 0;
            }
            
            // Ctrl+M (77 is 'M') - Combine selected cubes into mesh and save as .hdm
            let m_is_pressed: i32 = heidic_is_key_pressed(window, 77);
            let ctrl_is_down: i32 = heidic_ctrl_down(window);
            if m_is_pressed == 1 && ctrl_is_down == 1 {
                let selected_count: i32 = heidic_get_selection_count();
                if selected_count > 0 {
                    // Save to meshes directory (create if doesn't exist)
                    // For now, save to "meshes/combined_mesh.hdm" in current directory
                    let mesh_filepath: string = "meshes/combined_mesh.hdm";
                    let result: i32 = heidic_combine_selected_cubes_to_mesh(mesh_filepath);
                    if result == 1 {
                        print("Successfully combined selected cubes into mesh: ");
                        print(mesh_filepath);
                        print("\n");
                        // Optionally clear selection after combining
                        // heidic_clear_selection();
                    } else {
                        print("Failed to combine cubes into mesh\n");
                    }
                }
            }
        
        // Shift+S (83 is 'S') - Smooth selected cubes
        // Check shift state (reuse same logic as Shift+Enter)
        let s_is_pressed: i32 = heidic_is_key_pressed(window, 83);
        let s_shift_is_pressed: i32 = 0;
        let s_left_shift: i32 = heidic_is_key_pressed(window, 340);
        let s_right_shift: i32 = heidic_is_key_pressed(window, 344);
        if s_left_shift == 1 {
            s_shift_is_pressed = 1;
        }
        if s_right_shift == 1 {
            s_shift_is_pressed = 1;
        }
        
        if s_is_pressed == 1 && s_shift_is_pressed == 1 {
            if smooth_s_was_pressed == 0 {
                let selected_count: i32 = heidic_get_selection_count();
                if selected_count > 0 {
                    let result: i32 = heidic_smooth_selected_cubes();
                    if result == 1 {
                        print("Successfully smoothed selected cubes\n");
                    } else {
                        print("Failed to smooth cubes\n");
                    }
                } else {
                    print("No cubes selected for smoothing\n");
                }
                smooth_s_was_pressed = 1;
            }
        } else {
            smooth_s_was_pressed = 0;
        }
        
        // C key (67) - Combine selected cubes
        let c_is_pressed: i32 = heidic_is_key_pressed(window, 67);
        
        if c_is_pressed == 1 {
            if combine_c_was_pressed == 0 {
                // Check if we have any cubes selected
                let selection_count: i32 = heidic_get_selection_count();
                if selection_count > 0 {
                    print("C pressed - Combining selected cubes\n");
                    heidic_combine_selected_cubes();
                    print("Combination complete\n");
                } else {
                    // No selection, silently fail (do nothing)
                }
            }
            combine_c_was_pressed = 1;
        } else {
            combine_c_was_pressed = 0;
        }
        
        // Delete key (261) - Delete selected cube
        let delete_is_pressed: i32 = heidic_is_key_pressed(window, 261);
        if delete_is_pressed == 1 {
            if delete_was_pressed == 0 {
                // Only delete if we have a selection and it's a created cube (not player)
                if has_selection == 1 && selected_cube_index >= 2.0 {
                    // Convert float index to int (created cubes: index = vector_index + 2.0)
                    let cube_vector_index: i32 = heidic_float_to_int(selected_cube_index - 2.0);
                    heidic_delete_cube(cube_vector_index);
                    print("Deleted cube at index ");
                    print("\n");
                    
                    // Clear selection after deletion
                    has_selection = 0;
                    selected_cube_index = -1.0;
                }
                delete_was_pressed = 1;
            }
        } else {
            delete_was_pressed = 0;
        }
        
        // Shift+Enter Toggle Logic - Switch between Fullscreen and Windowed
        // Enter = 257, Left Shift = 340, Right Shift = 344
        let enter_is_pressed: i32 = heidic_is_key_pressed(window, 257);
        let left_shift_is_pressed: i32 = heidic_is_key_pressed(window, 340);
        let right_shift_is_pressed: i32 = heidic_is_key_pressed(window, 344);
        let shift_is_pressed: i32 = 0;
        if left_shift_is_pressed == 1 {
            shift_is_pressed = 1;
        }
        if right_shift_is_pressed == 1 {
            shift_is_pressed = 1;
        }
        
        if enter_is_pressed == 1 && shift_is_pressed == 1 {
            if shift_enter_was_pressed == 0 {
                if video_mode == 1 {
                    video_mode = 0; // Switch to fullscreen
                    heidic_set_video_mode(0);
                } else {
                    video_mode = 1; // Switch to windowed
                    heidic_set_video_mode(1);
                }
                shift_enter_was_pressed = 1;
            }
        } else {
            shift_enter_was_pressed = 0;
        }
        
        // Calculate forward and right direction vectors based on Y rotation
        // Forward should follow the yellow line (Z-axis) direction
        // At 0째: forward = (0, 0, -1) = negative Z (model's forward at start)
        let rot_y_rad: f32 = heidic_convert_degrees_to_radians(player_rot.y);
        // Forward follows the rotated negative Z-axis (yellow line direction)
        // Try: forward = (-sin(angle), 0, -cos(angle))
        let forward_x: f32 = -heidic_sin(rot_y_rad);
        let forward_z: f32 = -heidic_cos(rot_y_rad);
        // Right = (cos(angle), 0, -sin(angle))
        let right_x: f32 = heidic_cos(rot_y_rad);
        let right_z: f32 = -heidic_sin(rot_y_rad);
        
        // WASD Movement Controls (relative to rotation)
        // W = 87: move forward (in direction player is facing)
        if heidic_is_key_pressed(window, 87) == 1 {
            player_pos.x = player_pos.x + forward_x * move_speed;
            player_pos.z = player_pos.z + forward_z * move_speed;
        }
        // S = 83: move backward (opposite of forward)
        if heidic_is_key_pressed(window, 83) == 1 {
            player_pos.x = player_pos.x - forward_x * move_speed;
            player_pos.z = player_pos.z - forward_z * move_speed;
        }
        // A = 65: move left (negative right direction)
        if heidic_is_key_pressed(window, 65) == 1 {
            player_pos.x = player_pos.x - right_x * move_speed;
            player_pos.z = player_pos.z - right_z * move_speed;
        }
        // D = 68: move right (positive right direction)
        if heidic_is_key_pressed(window, 68) == 1 {
            player_pos.x = player_pos.x + right_x * move_speed;
            player_pos.z = player_pos.z + right_z * move_speed;
        }
        
        // Q = 81: Raise player (move up in Y)
        if heidic_is_key_pressed(window, 81) == 1 {
            player_pos.y = player_pos.y + move_speed;
        }
        // E = 69: Lower player (move down in Y)
        if heidic_is_key_pressed(window, 69) == 1 {
            player_pos.y = player_pos.y - move_speed;
        }
        
        // Update camera based on mode
        if camera_mode == 1 {
            // FPS Mode: Make camera follow player with offset
            // Add offset to player position (100 units above player = eye height)
            let offset: Vec3 = heidic_vec3(0.0, 100.0, 0.0);
            let offset_pos: Vec3 = heidic_vec3_add(player_pos, offset);
            
            // Copy offset position to camera position
            camera_pos = heidic_attach_camera_translation(offset_pos);
            // Copy player rotation to camera rotation
            camera_rot = heidic_attach_camera_rotation(player_rot);
        } else {
            // Top-Down Mode: Use fixed top-down camera with zoom and pan
            // Ctrl+RMB drag for zoom (ZBrush style)
            // Left Ctrl = 341, Right Ctrl = 345, Right Mouse Button = 1
            let left_ctrl_pressed: i32 = heidic_is_key_pressed(window, 341);
            let right_ctrl_pressed: i32 = heidic_is_key_pressed(window, 345);
            let ctrl_pressed: i32 = 0;
            if left_ctrl_pressed == 1 {
                ctrl_pressed = 1;
            }
            if right_ctrl_pressed == 1 {
                ctrl_pressed = 1;
            }
            
            let right_mouse_pressed: i32 = heidic_is_mouse_button_pressed(window, 1);
            
            if ctrl_pressed == 1 && right_mouse_pressed == 1 {
                // Get mouse delta Y for zoom/dolly
                let mouse_delta_y: f32 = heidic_get_mouse_delta_y(window);
                if mouse_delta_y != 0.0 {
                    // If actively orbiting (Alt pressed) AND has selection: Adjust dolly distance
                    // Otherwise: Always adjust zoom (camera height) - zoom should always work
                    if alt_pressed == 1 && has_selection == 1 {
                        // Dolly: Adjust distance to target (only when actively orbiting)
                        // Negative delta = move closer (dolly in), positive = move away (dolly out)
                        let dolly_speed: f32 = 50.0; // Units per pixel
                        dolly_orbit_distance = dolly_orbit_distance - mouse_delta_y * dolly_speed;
                        
                        // Clamp distance to reasonable range (allow very close and very far)
                        if dolly_orbit_distance < 10.0 {
                            dolly_orbit_distance = 10.0; // Min: 10cm (very close)
                        }
                        if dolly_orbit_distance > 100000.0 {
                            dolly_orbit_distance = 100000.0; // Max: 1km
                        }
                    } else {
                        // Zoom: Adjust camera height (FOV-style zoom for top-down) - ALWAYS available
                        // Speed proportional to camera height for consistent feel
                        let zoom_speed_factor: f32 = topdown_cam_height / 10000.0; // Normalize to base height
                        let zoom_speed: f32 = 50.0 * zoom_speed_factor; // Base speed multiplier
                        topdown_cam_height = topdown_cam_height - mouse_delta_y * zoom_speed;
                        
                        // Clamp zoom level (allow going below ground if needed, but reasonable limits)
                        if topdown_cam_height < 10.0 {
                            topdown_cam_height = 10.0; // Min: 10cm (very close)
                        }
                        if topdown_cam_height > 100000.0 {
                            topdown_cam_height = 100000.0; // Max: 1km
                        }
                    }
                }
            }
            
            // [ and ] keys for zoom (backup/alternative)
            // [ = zoom in (lower height), ] = zoom out (higher height)
            if heidic_is_key_pressed(window, 91) == 1 {
                // Zoom in
                let zoom_speed: f32 = 100.0; // Reduced speed for finer control
                topdown_cam_height = topdown_cam_height - zoom_speed;
                
                // Clamp zoom level (min 100 units = 1 meter, max 50000 units = 500 meters)
                if topdown_cam_height < 100.0 {
                    topdown_cam_height = 100.0;
                }
            }
            if heidic_is_key_pressed(window, 93) == 1 {
                // Zoom out
                let zoom_speed: f32 = 100.0; // Reduced speed for finer control
                topdown_cam_height = topdown_cam_height + zoom_speed;
                
                // Clamp zoom level (min 1000 units = 10 meters, max 50000 units = 500 meters)
                if topdown_cam_height > 50000.0 {
                    topdown_cam_height = 50000.0;
                }
            }
            
            // MMB button press + drag for panning (translating camera across XZ plane)
            let mouse_middle_pressed: i32 = heidic_is_mouse_button_pressed(window, 2);
            if mouse_middle_pressed == 1 {
                // Get mouse delta for panning
                let mouse_delta_x: f32 = heidic_get_mouse_delta_x(window);
                let mouse_delta_y: f32 = heidic_get_mouse_delta_y(window);
                
                if mouse_delta_x != 0.0 || mouse_delta_y != 0.0 {
                    // Pan speed proportional to camera height for consistent feel
                    // Higher camera = move faster, lower camera = move slower
                    let pan_speed_factor: f32 = topdown_cam_height / 10000.0; // Normalize to base height
                    let pan_speed: f32 = 4.0 * pan_speed_factor; // Increased base speed to 4.0
                    
                    // Mouse X moves camera X (reversed: drag right = move left, drag left = move right)
                    topdown_cam_pan_x = topdown_cam_pan_x - mouse_delta_x * pan_speed;
                    // Mouse Y moves camera Z (reversed: drag down = move forward, drag up = move back)
                    topdown_cam_pan_z = topdown_cam_pan_z - mouse_delta_y * pan_speed;
                }
                mouse_middle_was_pressed = 1;
            } else {
                mouse_middle_was_pressed = 0;
            }
            
            // Update top-down camera position with new height and pan offset
            // BUT: Skip this if we're in orbit mode (orbit code already set camera_pos)
            if in_orbit_mode == 0 {
                topdown_cam_pos = heidic_vec3(topdown_cam_pan_x, topdown_cam_height, topdown_cam_pan_z);
                camera_pos = topdown_cam_pos;
                camera_rot = topdown_cam_rot;
            }
            // Reset orbit flag for next frame
            in_orbit_mode = 0;
        }
        
        // Update legacy variables for drawing
        cube_x = player_pos.x;
        cube_y = player_pos.y;
        cube_z = player_pos.z;
        cube_rx = player_rot.x;
        cube_ry = player_rot.y;
        cube_rz = player_rot.z;
        
        heidic_begin_frame();
        // print("[HEIDIC DEBUG] After heidic_begin_frame()\n");  // Debug: uncomment when needed
        
        // Setup dockspace (enables docking for all windows)
        heidic_imgui_setup_dockspace();
        // print("[HEIDIC DEBUG] After heidic_imgui_setup_dockspace()\n");  // Debug: uncomment when needed
        
        // Main Menu Bar
        // print("[HEIDIC DEBUG] About to begin main menu bar\n");  // Debug: uncomment when needed
        if heidic_imgui_begin_main_menu_bar() == 1 {
            // print("[HEIDIC DEBUG] Inside main menu bar\n");  // Debug: uncomment when needed
            // print("[HEIDIC DEBUG] About to begin File menu\n");  // Debug: uncomment when needed
            if heidic_imgui_begin_menu("File") == 1 {
                // print("[HEIDIC DEBUG] Inside File menu\n");  // Debug: uncomment when needed
                // print("[HEIDIC DEBUG] About to check Save Level As menu item\n");  // Debug: uncomment when needed
                if heidic_imgui_menu_item("Save Level As...") == 1 {
                    // Show native save dialog
                    let save_result: i32 = heidic_show_save_dialog();
                    if save_result == 1 {
                        // Success - level saved via dialog
                    }
                }
                if heidic_imgui_menu_item("Open Level...") == 1 {
                    // Show native open dialog
                    let load_result: i32 = heidic_show_open_dialog();
                    if load_result == 1 {
                        // Success - level loaded via dialog
                    }
                }
                heidic_imgui_separator();
                if heidic_imgui_menu_item("Exit") == 1 {
                    heidic_set_window_should_close(window, 1);
                }
                heidic_imgui_end_menu();
                // print("[HEIDIC DEBUG] After File menu\n");  // Debug: uncomment when needed
            }
            // print("[HEIDIC DEBUG] About to begin Object menu\n");  // Debug: uncomment when needed
            if heidic_imgui_begin_menu("Object") == 1 {
                // print("[HEIDIC DEBUG] Inside Object menu\n");  // Debug: uncomment when needed
                if heidic_imgui_menu_item("Add Cube") == 1 {
                    // Create cube at origin (0, 0, 0) with default size
                    let default_cube_size: f32 = 200.0; // 2 meters
                    let new_cube_index: i32 = heidic_create_cube(0.0, 0.0, 0.0, default_cube_size, default_cube_size, default_cube_size);
                    // Select the newly created cube (indices start from 2.0 for created cubes)
                    // Convert index to float and add 2.0 offset
                    selected_cube_index = heidic_int_to_float(new_cube_index) + 2.0;
                    has_selection = 1;
                    // Update selected cube properties for gizmo
                    selected_cube_x = 0.0;
                    selected_cube_y = 0.0;
                    selected_cube_z = 0.0;
                    selected_cube_sx = default_cube_size;
                    selected_cube_sy = default_cube_size;
                    selected_cube_sz = default_cube_size;
                }
                if heidic_imgui_menu_item("Load Mesh") == 1 {
                    let mesh_id: i32 = heidic_show_open_mesh_dialog();
                    if mesh_id >= 0 {
                        print("Successfully loaded mesh with ID: ");
                        print(mesh_id);
                        print("\n");
                    } else {
                        print("Failed to load mesh or user cancelled\n");
                    }
                }
                // print("[HEIDIC DEBUG] About to end Object menu\n");  // Debug: uncomment when needed
                heidic_imgui_end_menu();
                // print("[HEIDIC DEBUG] After Object menu\n");  // Debug: uncomment when needed
            }
            // print("[HEIDIC DEBUG] About to end main menu bar\n");  // Debug: uncomment when needed
            heidic_imgui_end_main_menu_bar();
            // print("[HEIDIC DEBUG] After ending main menu bar (HEIDIC)\n");  // Debug: uncomment when needed
        }
        // print("[HEIDIC DEBUG] After main menu bar block\n");  // Debug: uncomment when needed
        
        // Update Camera with Vec3 values
        // print("[HEIDIC DEBUG] Before camera update\n");  // Debug: uncomment when needed
        // Use larger far plane for top-down view to see distant objects
        // print("[HEIDIC DEBUG] About to check camera_mode\n");  // Debug: uncomment when needed
        if camera_mode == 0 {
            // print("[HEIDIC DEBUG] camera_mode is 0 (top-down), calling heidic_update_camera_with_far\n");  // Debug: uncomment when needed
            // Top-down mode: use 50000 units far plane (500 meters) to see everything
            heidic_update_camera_with_far(camera_pos.x, camera_pos.y, camera_pos.z, camera_rot.x, camera_rot.y, camera_rot.z, 50000.0);
            // print("[HEIDIC DEBUG] After heidic_update_camera_with_far\n");  // Debug: uncomment when needed
        } else {
            // print("[HEIDIC DEBUG] camera_mode is not 0 (FPS), calling heidic_update_camera\n");  // Debug: uncomment when needed
            // FPS mode: use default 5000 units far plane (50 meters)
            heidic_update_camera(camera_pos.x, camera_pos.y, camera_pos.z, camera_rot.x, camera_rot.y, camera_rot.z);
            // print("[HEIDIC DEBUG] After heidic_update_camera\n");  // Debug: uncomment when needed
        }
        // print("[HEIDIC DEBUG] After camera update block\n");  // Debug: uncomment when needed
        
        // Draw solid ground plane cube: 100m x 100m x 1m thick at y = -5m (-500 units)
        // 100 meters = 10000 units, 1 meter = 100 units, -5 meters = -500 units
        // Ensure default white texture is loaded before drawing non-textured geometry
        // This prevents texture color from tinting the ground plane
        // print("[HEIDIC DEBUG] Before ground plane drawing\n");  // Debug: uncomment when needed
        heidic_load_texture_for_rendering("default.bmp");
        // print("[HEIDIC DEBUG] After heidic_load_texture_for_rendering\n");  // Debug: uncomment when needed
        heidic_draw_cube_grey(0.0, -500.0, 0.0, 0.0, 0.0, 0.0, 10000.0, 100.0, 10000.0);
        // print("[HEIDIC DEBUG] After heidic_draw_cube_grey\n");  // Debug: uncomment when needed
        
        // Draw Ground Plane grid (large grid at y=-300) - only if grid is visible
        if show_grid == 1 {
            heidic_draw_ground_plane(20000.0, 0.5, 0.5, 0.5); // 200 meters, grey color
        }
        // print("[HEIDIC DEBUG] After ground plane grid\n");  // Debug: uncomment when needed
        
        // Update player cube visibility based on camera mode
        if camera_mode == 1 {
            // Walk mode (FPS): make player cube invisible
            player_cube_visible = INVISIBLE;
        } else {
            // Top-down mode: make player cube visible
            player_cube_visible = VISIBLE;
        }
        
        // Draw Player Cube (only if visible)
        if player_cube_visible == VISIBLE {
            heidic_draw_cube(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, cube_sx, cube_sy, cube_sz);
        }
        // print("[HEIDIC DEBUG] After player cube drawing\n");  // Debug: uncomment when needed
        
        // Draw Origin Lines (1 meter = 100 cm = 100 units)
        // Player origin lines are invisible (only draw for reference cubes if needed)
        // heidic_draw_model_origin(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, 100.0);
        
        // Starting cubes removed - user can create cubes with Spacebar or Object menu
        
        // Draw Created Cubes (user-created via Spacebar) - Dynamic system
        // Batch cubes by texture: when texture changes, flush current batch and start new one
        // This ensures each cube gets the correct texture while maintaining efficient batching
        // print("[HEIDIC DEBUG] Before cube drawing loop\n");  // Debug: uncomment when needed
        let cube_draw_index: i32 = 0;
        let total_cubes: i32 = heidic_get_cube_total_count();
        // print("[HEIDIC DEBUG] Got total_cubes, starting loop\n");  // Debug: uncomment when needed
        let current_texture: string = "";
        let first_cube: i32 = 1;
        
        while cube_draw_index < total_cubes {
            // if cube_draw_index == 0 {
            //     print("[HEIDIC DEBUG] First iteration of cube loop\n");  // Debug: uncomment when needed
            // }
            if heidic_get_cube_active(cube_draw_index) == 1 {
                // if cube_draw_index == 0 {
                //     print("[HEIDIC DEBUG] First cube is active\n");  // Debug: uncomment when needed
                // }
                let cube_texture_name: string = heidic_get_cube_texture_name(cube_draw_index);
                // Use default texture if empty
                if cube_texture_name == "" {
                    cube_texture_name = "default.bmp";
                }
                
                // If texture changed, flush previous batch and start new one
                if first_cube == 0 && cube_texture_name != current_texture {
                    // Flush current batch (draw all cubes with current_texture)
                    heidic_flush_colored_cubes();
                    // Load new texture
                    heidic_load_texture_for_rendering(cube_texture_name);
                    current_texture = cube_texture_name;
                } else {
                    if first_cube == 1 {
                        // First cube - load its texture
                        heidic_load_texture_for_rendering(cube_texture_name);
                        current_texture = cube_texture_name;
                        first_cube = 0;
                    }
                }
                
                let cube_x: f32 = heidic_get_cube_x(cube_draw_index);
                let cube_y: f32 = heidic_get_cube_y(cube_draw_index);
                let cube_z: f32 = heidic_get_cube_z(cube_draw_index);
                let cube_sx: f32 = heidic_get_cube_sx(cube_draw_index);
                let cube_sy: f32 = heidic_get_cube_sy(cube_draw_index);
                let cube_sz: f32 = heidic_get_cube_sz(cube_draw_index);
                let cube_rx: f32 = heidic_get_cube_rx(cube_draw_index);
                let cube_ry: f32 = heidic_get_cube_ry(cube_draw_index);
                let cube_rz: f32 = heidic_get_cube_rz(cube_draw_index);
                
                // Draw cube with white color (1,1,1) so texture displays at full brightness without tinting
                heidic_draw_cube_colored(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, cube_sx, cube_sy, cube_sz, 1.0, 1.0, 1.0);
                
                // Draw wireframe outline for selected cubes
                if heidic_is_cube_selected(cube_draw_index) == 1 {
                    // Draw wireframe outline (slightly larger than cube, white color)
                    heidic_draw_cube_wireframe(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, cube_sx * 1.01, cube_sy * 1.01, cube_sz * 1.01, 1.0, 1.0, 1.0);
                }
            }
            cube_draw_index = cube_draw_index + 1;
        }
        // print("[HEIDIC DEBUG] After cube drawing loop\n");  // Debug: uncomment when needed
        
        // Flush any remaining batched cubes at the end (draw final texture group)
        heidic_flush_colored_cubes();
        // print("[HEIDIC DEBUG] After flushing colored cubes\n");  // Debug: uncomment when needed
        
        // Draw Created Wedges (user-created via '0' key)
        // print("[HEIDIC DEBUG] Before wedge drawing\n");  // Debug: uncomment when needed
        let wedge_total_count: i32 = heidic_get_wedge_total_count();
        // print("[HEIDIC DEBUG] Got wedge_total_count, starting wedge loop\n");  // Debug: uncomment when needed
        let wedge_draw_index: i32 = 0;
        let first_wedge: i32 = 1;
        let current_wedge_texture: string = "";
        
        while wedge_draw_index < wedge_total_count {
            if heidic_get_wedge_active(wedge_draw_index) == 1 {
                let wedge_texture_name: string = heidic_get_wedge_texture_name(wedge_draw_index);
                if wedge_texture_name == "" {
                    wedge_texture_name = "default.bmp";
                }
                
                if first_wedge == 0 && wedge_texture_name != current_wedge_texture {
                    heidic_flush_colored_cubes();
                    heidic_load_texture_for_rendering(wedge_texture_name);
                    current_wedge_texture = wedge_texture_name;
                } else {
                    if first_wedge == 1 {
                        heidic_load_texture_for_rendering(wedge_texture_name);
                        current_wedge_texture = wedge_texture_name;
                        first_wedge = 0;
                    }
                }
                
                let wedge_x: f32 = heidic_get_wedge_x(wedge_draw_index);
                let wedge_y: f32 = heidic_get_wedge_y(wedge_draw_index);
                let wedge_z: f32 = heidic_get_wedge_z(wedge_draw_index);
                let wedge_sx: f32 = heidic_get_wedge_sx(wedge_draw_index);
                let wedge_sy: f32 = heidic_get_wedge_sy(wedge_draw_index);
                let wedge_sz: f32 = heidic_get_wedge_sz(wedge_draw_index);
                let wedge_rx: f32 = heidic_get_wedge_rx(wedge_draw_index);
                let wedge_ry: f32 = heidic_get_wedge_ry(wedge_draw_index);
                let wedge_rz: f32 = heidic_get_wedge_rz(wedge_draw_index);
                
                // Draw wedge with white color (full texture brightness)
                heidic_draw_wedge_colored(wedge_x, wedge_y, wedge_z, wedge_rx, wedge_ry, wedge_rz, wedge_sx, wedge_sy, wedge_sz, 1.0, 1.0, 1.0);
            }
            wedge_draw_index = wedge_draw_index + 1;
        }
        // print("[HEIDIC DEBUG] After wedge drawing loop\n");  // Debug: uncomment when needed
        
        // Flush any remaining batched wedges
        heidic_flush_colored_cubes();
        // print("[HEIDIC DEBUG] After flushing wedges\n");  // Debug: uncomment when needed
        
        // Draw all loaded mesh instances (from .hdm files)
        // print("[HEIDIC DEBUG] Before mesh instance drawing\n");  // Debug: uncomment when needed
        let mesh_instance_count: i32 = heidic_get_mesh_instance_total_count();
        // print("[HEIDIC DEBUG] Got mesh_instance_count\n");  // Debug: uncomment when needed
        if mesh_instance_count > 0 {
            // print("[HEIDIC DEBUG] mesh_instance_count > 0, entering mesh instance loop\n");  // Debug: uncomment when needed
            // Ensure default texture is loaded after drawing cubes (in case mesh has no texture)
            heidic_load_texture_for_rendering("default.bmp");
            
            let mesh_instance_index: i32 = 0;
            while mesh_instance_index < mesh_instance_count {
                if heidic_get_mesh_instance_active(mesh_instance_index) == 1 {
                    // Get mesh instance data
                    let instance_mesh_id: i32 = heidic_get_mesh_instance_mesh_id(mesh_instance_index);
                    let instance_x: f32 = heidic_get_mesh_instance_x(mesh_instance_index);
                    let instance_y: f32 = heidic_get_mesh_instance_y(mesh_instance_index);
                    let instance_z: f32 = heidic_get_mesh_instance_z(mesh_instance_index);
                    
                    // Get mesh center, scale, and rotation
                    let mesh_center_x: f32 = heidic_get_mesh_instance_center_x(mesh_instance_index);
                    let mesh_center_y: f32 = heidic_get_mesh_instance_center_y(mesh_instance_index);
                    let mesh_center_z: f32 = heidic_get_mesh_instance_center_z(mesh_instance_index);
                    let mesh_sx: f32 = heidic_get_mesh_instance_sx(mesh_instance_index);
                    let mesh_sy: f32 = heidic_get_mesh_instance_sy(mesh_instance_index);
                    let mesh_sz: f32 = heidic_get_mesh_instance_sz(mesh_instance_index);
                    let mesh_rx: f32 = heidic_get_mesh_instance_rx(mesh_instance_index);
                    let mesh_ry: f32 = heidic_get_mesh_instance_ry(mesh_instance_index);
                    let mesh_rz: f32 = heidic_get_mesh_instance_rz(mesh_instance_index);
                    
                    // Calculate actual world position (instance offset + original center)
                    let world_x: f32 = instance_x + mesh_center_x;
                    let world_y: f32 = instance_y + mesh_center_y;
                    let world_z: f32 = instance_z + mesh_center_z;
                    
                    // Draw mesh at world position with scale and rotation
                    // Note: Mesh vertices are in world space, so we need to scale around the mesh center
                    // to prevent translation when scaling
                    heidic_draw_mesh_scaled_with_center(instance_mesh_id, instance_x, instance_y, instance_z, mesh_rx, mesh_ry, mesh_rz, mesh_sx, mesh_sy, mesh_sz, mesh_center_x, mesh_center_y, mesh_center_z);
                    
                    // Draw wireframe bounding box for selected meshes
                    // NOTE: Bounding box is drawn with rotation to match the mesh transform
                    if heidic_is_mesh_selected(mesh_instance_index) == 1 {
                        // Get bounding box (relative to mesh center)
                        let bbox_min_x: f32 = heidic_get_mesh_instance_bbox_min_x(mesh_instance_index);
                        let bbox_min_y: f32 = heidic_get_mesh_instance_bbox_min_y(mesh_instance_index);
                        let bbox_min_z: f32 = heidic_get_mesh_instance_bbox_min_z(mesh_instance_index);
                        let bbox_max_x: f32 = heidic_get_mesh_instance_bbox_max_x(mesh_instance_index);
                        let bbox_max_y: f32 = heidic_get_mesh_instance_bbox_max_y(mesh_instance_index);
                        let bbox_max_z: f32 = heidic_get_mesh_instance_bbox_max_z(mesh_instance_index);
                        
                        // Scale bounding box by current scale
                        let scaled_min_x: f32 = bbox_min_x * mesh_sx;
                        let scaled_min_y: f32 = bbox_min_y * mesh_sy;
                        let scaled_min_z: f32 = bbox_min_z * mesh_sz;
                        let scaled_max_x: f32 = bbox_max_x * mesh_sx;
                        let scaled_max_y: f32 = bbox_max_y * mesh_sy;
                        let scaled_max_z: f32 = bbox_max_z * mesh_sz;
                        
                        // Calculate bounding box center and size (in world space)
                        // The mesh is drawn with instance_x, instance_y, instance_z as the base position
                        // and mesh_center_x, mesh_center_y, mesh_center_z as the center offset
                        // The final world position of the mesh center is: instance_pos + center
                        // BUT: The mesh drawing function applies transforms in order: T(pos) * T(center) * R * S * T(-center)
                        // So the actual world position of the center after all transforms is: instance_pos + center
                        // This is correct, so we use it for the bounding box too
                        let bbox_center_x: f32 = instance_x + mesh_center_x;
                        let bbox_center_y: f32 = instance_y + mesh_center_y;
                        let bbox_center_z: f32 = instance_z + mesh_center_z;
                        let bbox_size_x: f32 = scaled_max_x - scaled_min_x;
                        let bbox_size_y: f32 = scaled_max_y - scaled_min_y;
                        let bbox_size_z: f32 = scaled_max_z - scaled_min_z;
                        
                        // Draw wireframe bounding box (yellow) with rotation to match mesh
                        // Apply the same rotation as the mesh
                        heidic_draw_cube_wireframe(bbox_center_x, bbox_center_y, bbox_center_z, mesh_rx, mesh_ry, mesh_rz, 
                                                    bbox_size_x, bbox_size_y, bbox_size_z, 1.0, 1.0, 0.0);
                    }
                }
                mesh_instance_index = mesh_instance_index + 1;
            }
            print("[HEIDIC DEBUG] After mesh instance loop\n");
        } else {
            // print("[HEIDIC DEBUG] mesh_instance_count is 0, skipping mesh instance drawing\n");  // Debug: uncomment when needed
        }
        
        // print("[HEIDIC DEBUG] Before raycasting section\n");  // Debug: uncomment when needed
        // ============================================================================
        // RAYCASTING
        // ============================================================================
        // print("[HEIDIC DEBUG] Inside raycasting section, about to draw ray\n");  // Debug: uncomment when needed
        
        // Yellow debug line - draw from camera to 50km out along ray
        // This helps visualize where the ray is pointing
        heidic_draw_ray(window, 50000.0, 1.0, 1.0, 0.0);
        // print("[HEIDIC DEBUG] After heidic_draw_ray\n");  // Debug: uncomment when needed
        
        // Debug: Draw large red cube at ray hit point to visualize where ray intersects geometry
        // print("[HEIDIC DEBUG] About to enter raycast debug block\n");  // Debug: uncomment when needed
        if 1 == 1 {
            // print("[HEIDIC DEBUG] Inside raycast debug block, getting ray origin/dir\n");  // Debug: uncomment when needed
            let debug_ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
            let debug_ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
            // print("[HEIDIC DEBUG] Got ray origin and dir, initializing variables\n");  // Debug: uncomment when needed
            let debug_hit_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
            let debug_found_hit: i32 = 0;
            let debug_closest_dist: f32 = 100000000000.0;
            let debug_hit_cube_x: f32 = 0.0;
            let debug_hit_cube_y: f32 = 0.0;
            let debug_hit_cube_z: f32 = 0.0;
            let debug_hit_cube_sx: f32 = 0.0;
            let debug_hit_cube_sy: f32 = 0.0;
            let debug_hit_cube_sz: f32 = 0.0;
            let debug_hit_face: i32 = -1; // -1 = no face, 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
            let debug_is_ground_plane: i32 = 0;
            let debug_is_wedge: i32 = 0; // 1 = hit object is a wedge, 0 = cube or other
            // print("[HEIDIC DEBUG] Initialized debug variables, about to test ground plane\n");  // Debug: uncomment when needed
            
            // FIRST: Test the big grey ground plane cube (100m x 100m x 1m at y = -500)
        // This is important geometry and needs to be pickable!
        let ground_cube_x: f32 = 0.0;
        let ground_cube_y: f32 = -500.0;
        let ground_cube_z: f32 = 0.0;
        let ground_cube_sx: f32 = 10000.0; // 100 meters
        let ground_cube_sy: f32 = 100.0;   // 1 meter thick
        let ground_cube_sz: f32 = 10000.0; // 100 meters
        
        // print("[HEIDIC DEBUG] About to raycast ground plane\n");  // Debug: uncomment when needed
        let ground_cube_hit: i32 = heidic_raycast_cube_hit(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
        // print("[HEIDIC DEBUG] After ground plane raycast\n");  // Debug: uncomment when needed
        if ground_cube_hit == 1 {
            // print("[HEIDIC DEBUG] Ground plane hit detected\n");  // Debug: uncomment when needed
            let ground_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
            let ground_cube_dist: f32 = (ground_cube_hit_point.x - debug_ray_origin.x) * (ground_cube_hit_point.x - debug_ray_origin.x) + (ground_cube_hit_point.y - debug_ray_origin.y) * (ground_cube_hit_point.y - debug_ray_origin.y) + (ground_cube_hit_point.z - debug_ray_origin.z) * (ground_cube_hit_point.z - debug_ray_origin.z);
            if ground_cube_dist < debug_closest_dist {
                debug_closest_dist = ground_cube_dist;
                debug_hit_pos = ground_cube_hit_point;
                debug_hit_cube_x = ground_cube_x;
                debug_hit_cube_y = ground_cube_y;
                debug_hit_cube_z = ground_cube_z;
                debug_hit_cube_sx = ground_cube_sx;
                debug_hit_cube_sy = ground_cube_sy;
                debug_hit_cube_sz = ground_cube_sz;
                debug_is_ground_plane = 1;
                debug_found_hit = 1;
            }
        }
        // print("[HEIDIC DEBUG] After ground plane raycast logic\n");  // Debug: uncomment when needed
        
        // Test all created cubes to find closest hit
        // print("[HEIDIC DEBUG] About to test cubes for raycast\n");  // Debug: uncomment when needed
        let debug_cube_index: i32 = 0;
        let debug_total_cubes: i32 = heidic_get_cube_total_count();
        // print("[HEIDIC DEBUG] Starting cube raycast loop\n");  // Debug: uncomment when needed
        while debug_cube_index < debug_total_cubes {
            if heidic_get_cube_active(debug_cube_index) == 1 {
                let debug_cube_x: f32 = heidic_get_cube_x(debug_cube_index);
                let debug_cube_y: f32 = heidic_get_cube_y(debug_cube_index);
                let debug_cube_z: f32 = heidic_get_cube_z(debug_cube_index);
                let debug_cube_sx: f32 = heidic_get_cube_sx(debug_cube_index);
                let debug_cube_sy: f32 = heidic_get_cube_sy(debug_cube_index);
                let debug_cube_sz: f32 = heidic_get_cube_sz(debug_cube_index);
                
                let debug_cube_hit: i32 = heidic_raycast_cube_hit(window, debug_cube_x, debug_cube_y, debug_cube_z, debug_cube_sx, debug_cube_sy, debug_cube_sz);
                if debug_cube_hit == 1 {
                    let debug_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, debug_cube_x, debug_cube_y, debug_cube_z, debug_cube_sx, debug_cube_sy, debug_cube_sz);
                    let debug_dist: f32 = (debug_hit_point.x - debug_ray_origin.x) * (debug_hit_point.x - debug_ray_origin.x) + (debug_hit_point.y - debug_ray_origin.y) * (debug_hit_point.y - debug_ray_origin.y) + (debug_hit_point.z - debug_ray_origin.z) * (debug_hit_point.z - debug_ray_origin.z);
                    if debug_dist < debug_closest_dist {
                        debug_closest_dist = debug_dist;
                        debug_hit_pos = debug_hit_point;
                        debug_hit_cube_x = debug_cube_x;
                        debug_hit_cube_y = debug_cube_y;
                        debug_hit_cube_z = debug_cube_z;
                        debug_hit_cube_sx = debug_cube_sx;
                        debug_hit_cube_sy = debug_cube_sy;
                        debug_hit_cube_sz = debug_cube_sz;
                        debug_is_ground_plane = 0;
                        debug_found_hit = 1;
                    }
                }
            }
            debug_cube_index = debug_cube_index + 1;
        }
        // print("[HEIDIC DEBUG] After cube raycast loop\n");  // Debug: uncomment when needed
        
        // Test all created wedges to find closest hit
        // print("[HEIDIC DEBUG] About to test wedges for raycast\n");  // Debug: uncomment when needed
        let debug_wedge_index: i32 = 0;
        let debug_total_wedges: i32 = heidic_get_wedge_total_count();
        // print("[HEIDIC DEBUG] Starting wedge raycast loop\n");  // Debug: uncomment when needed
        while debug_wedge_index < debug_total_wedges {
            if debug_wedge_index == 0 {
                print("[HEIDIC DEBUG] First iteration of wedge raycast loop\n");
            }
            if heidic_get_wedge_active(debug_wedge_index) == 1 {
                if debug_wedge_index == 0 {
                    print("[HEIDIC DEBUG] First wedge is active, getting position\n");
                }
                let debug_wedge_x: f32 = heidic_get_wedge_x(debug_wedge_index);
                let debug_wedge_y: f32 = heidic_get_wedge_y(debug_wedge_index);
                let debug_wedge_z: f32 = heidic_get_wedge_z(debug_wedge_index);
                let debug_wedge_sx: f32 = heidic_get_wedge_sx(debug_wedge_index);
                let debug_wedge_sy: f32 = heidic_get_wedge_sy(debug_wedge_index);
                let debug_wedge_sz: f32 = heidic_get_wedge_sz(debug_wedge_index);
                
                if debug_wedge_index == 0 {
                    print("[HEIDIC DEBUG] About to raycast wedge\n");
                }
                let debug_wedge_hit: i32 = heidic_raycast_cube_hit(window, debug_wedge_x, debug_wedge_y, debug_wedge_z, debug_wedge_sx, debug_wedge_sy, debug_wedge_sz);
                if debug_wedge_index == 0 {
                    print("[HEIDIC DEBUG] After wedge raycast call\n");
                }
                if debug_wedge_hit == 1 {
                    let debug_wedge_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, debug_wedge_x, debug_wedge_y, debug_wedge_z, debug_wedge_sx, debug_wedge_sy, debug_wedge_sz);
                    let debug_wedge_dist: f32 = (debug_wedge_hit_point.x - debug_ray_origin.x) * (debug_wedge_hit_point.x - debug_ray_origin.x) + (debug_wedge_hit_point.y - debug_ray_origin.y) * (debug_wedge_hit_point.y - debug_ray_origin.y) + (debug_wedge_hit_point.z - debug_ray_origin.z) * (debug_wedge_hit_point.z - debug_ray_origin.z);
                    if debug_wedge_dist < debug_closest_dist {
                        debug_closest_dist = debug_wedge_dist;
                        debug_hit_pos = debug_wedge_hit_point;
                        debug_hit_cube_x = debug_wedge_x;
                        debug_hit_cube_y = debug_wedge_y;
                        debug_hit_cube_z = debug_wedge_z;
                        debug_hit_cube_sx = debug_wedge_sx;
                        debug_hit_cube_sy = debug_wedge_sy;
                        debug_hit_cube_sz = debug_wedge_sz;
                        debug_is_ground_plane = 0;
                        debug_is_wedge = 1; // Mark as wedge
                        debug_found_hit = 1;
                    }
                }
            }
            debug_wedge_index = debug_wedge_index + 1;
        }
        // print("[HEIDIC DEBUG] After wedge raycast loop\n");  // Debug: uncomment when needed
        
        // Test all mesh instances to find closest hit (for debug cube positioning)
        // print("[HEIDIC DEBUG] About to test mesh instances for raycast\n");  // Debug: uncomment when needed
        let debug_mesh_instance_index: i32 = 0;
        let debug_total_mesh_instances: i32 = heidic_get_mesh_instance_total_count();
        while debug_mesh_instance_index < debug_total_mesh_instances {
            if heidic_get_mesh_instance_active(debug_mesh_instance_index) == 1 {
                let debug_mesh_hit: i32 = heidic_raycast_mesh_bbox_hit(window, debug_mesh_instance_index);
                if debug_mesh_hit == 1 {
                    let debug_mesh_hit_point: Vec3 = heidic_raycast_mesh_bbox_hit_point(window, debug_mesh_instance_index);
                    let debug_mesh_dist: f32 = (debug_mesh_hit_point.x - debug_ray_origin.x) * (debug_mesh_hit_point.x - debug_ray_origin.x) + (debug_mesh_hit_point.y - debug_ray_origin.y) * (debug_mesh_hit_point.y - debug_ray_origin.y) + (debug_mesh_hit_point.z - debug_ray_origin.z) * (debug_mesh_hit_point.z - debug_ray_origin.z);
                    if debug_mesh_dist < debug_closest_dist {
                        debug_closest_dist = debug_mesh_dist;
                        debug_hit_pos = debug_mesh_hit_point;
                        // For meshes, we don't have cube dimensions, so use a default size
                        debug_hit_cube_x = debug_mesh_hit_point.x;
                        debug_hit_cube_y = debug_mesh_hit_point.y;
                        debug_hit_cube_z = debug_mesh_hit_point.z;
                        debug_hit_cube_sx = 100.0;
                        debug_hit_cube_sy = 100.0;
                        debug_hit_cube_sz = 100.0;
                        debug_is_ground_plane = 0;
                        debug_found_hit = 1;
                    }
                }
            }
            debug_mesh_instance_index = debug_mesh_instance_index + 1;
        }
        // print("[HEIDIC DEBUG] After mesh instance raycast loop\n");  // Debug: uncomment when needed
        
        // Calculate where the cube would actually be placed (not just the hit point)
        // print("[HEIDIC DEBUG] About to calculate placement position\n");  // Debug: uncomment when needed
        // Declare this early so it can be used in all code paths
        let debug_placement_pos: Vec3 = debug_hit_pos; // Default: same as hit point
        let debug_default_cube_size: f32 = 100.0; // Same as cube creation size
        
        // If still no hit, place debug cube along the ray (5 meters out) so we can always see where the ray is pointing
        if debug_found_hit == 0 {
            debug_hit_pos = heidic_vec3_add(debug_ray_origin, heidic_vec3_mul_scalar(debug_ray_dir, 500.0));
            debug_placement_pos = debug_hit_pos; // No hit, so placement is same as hit point
            stored_preview_pos = debug_placement_pos;
            stored_preview_valid = 1;
        }
        
        // If we hit a cube or wedge, calculate the actual placement position
        if debug_found_hit == 1 && debug_is_ground_plane == 0 {
            // Calculate bounds
            let debug_cube_min_x: f32 = debug_hit_cube_x - debug_hit_cube_sx / 2.0;
            let debug_cube_max_x: f32 = debug_hit_cube_x + debug_hit_cube_sx / 2.0;
            let debug_cube_min_y: f32 = debug_hit_cube_y - debug_hit_cube_sy / 2.0;
            let debug_cube_max_y: f32 = debug_hit_cube_y + debug_hit_cube_sy / 2.0;
            let debug_cube_min_z: f32 = debug_hit_cube_z - debug_hit_cube_sz / 2.0;
            let debug_cube_max_z: f32 = debug_hit_cube_z + debug_hit_cube_sz / 2.0;
            
            // Calculate distances from hit point to each face
            let debug_dist_to_left: f32 = debug_hit_pos.x - debug_cube_min_x;
            let debug_dist_to_right: f32 = debug_cube_max_x - debug_hit_pos.x;
            let debug_dist_to_bottom: f32 = debug_hit_pos.y - debug_cube_min_y;
            let debug_dist_to_top: f32 = debug_cube_max_y - debug_hit_pos.y;
            let debug_dist_to_back: f32 = debug_hit_pos.z - debug_cube_min_z;
            let debug_dist_to_front: f32 = debug_cube_max_z - debug_hit_pos.z;
            
            // Find the closest face (same logic as placement)
            // For both cubes and wedges, check all 6 faces of the bounding box
            // (Wedges are inscribed in a cube, so we treat them the same as cubes)
            let debug_min_dist: f32 = debug_dist_to_left;
            debug_hit_face = 0; // 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
            
            // Check all faces (works for both cubes and wedges)
            if debug_dist_to_right < debug_min_dist {
                debug_min_dist = debug_dist_to_right;
                debug_hit_face = 1;
            }
            if debug_dist_to_bottom < debug_min_dist {
                debug_min_dist = debug_dist_to_bottom;
                debug_hit_face = 2;
            }
            if debug_dist_to_top < debug_min_dist {
                debug_min_dist = debug_dist_to_top;
                debug_hit_face = 3;
            }
            if debug_dist_to_back < debug_min_dist {
                debug_min_dist = debug_dist_to_back;
                debug_hit_face = 4;
            }
            if debug_dist_to_front < debug_min_dist {
                debug_min_dist = debug_dist_to_front;
                debug_hit_face = 5;
            }
            
            // Calculate placement position based on hit face (same logic as actual placement)
            if debug_hit_face == 0 {
                // Left face (negative X) - stack to the left
                debug_placement_pos.x = debug_cube_min_x - debug_default_cube_size / 2.0;
                debug_placement_pos.y = debug_hit_cube_y;
                debug_placement_pos.z = debug_hit_cube_z;
            } else {
                if debug_hit_face == 1 {
                    // Right face (positive X) - stack to the right
                    debug_placement_pos.x = debug_cube_max_x + debug_default_cube_size / 2.0;
                    debug_placement_pos.y = debug_hit_cube_y;
                    debug_placement_pos.z = debug_hit_cube_z;
                } else {
                    if debug_hit_face == 2 {
                        // Bottom face (negative Y) - stack below
                        debug_placement_pos.x = debug_hit_cube_x;
                        debug_placement_pos.y = debug_cube_min_y - debug_default_cube_size / 2.0;
                        debug_placement_pos.z = debug_hit_cube_z;
                    } else {
                        if debug_hit_face == 3 {
                            // Top face (positive Y) - stack on top
                            debug_placement_pos.x = debug_hit_cube_x;
                            debug_placement_pos.y = debug_cube_max_y + debug_default_cube_size / 2.0;
                            debug_placement_pos.z = debug_hit_cube_z;
                        } else {
                            if debug_hit_face == 4 {
                                // Back face (negative Z) - stack to the back
                                debug_placement_pos.x = debug_hit_cube_x;
                                debug_placement_pos.y = debug_hit_cube_y;
                                debug_placement_pos.z = debug_cube_min_z - debug_default_cube_size / 2.0;
                            } else {
                                // Front face (positive Z) - stack to the front
                                debug_placement_pos.x = debug_hit_cube_x;
                                debug_placement_pos.y = debug_hit_cube_y;
                                debug_placement_pos.z = debug_cube_max_z + debug_default_cube_size / 2.0;
                            }
                        }
                    }
                }
            }
        } else {
            if debug_found_hit == 1 && debug_is_ground_plane == 1 {
                // Ground plane: stack on top
                let hit_top_y: f32 = debug_hit_cube_y + debug_hit_cube_sy / 2.0;
                debug_placement_pos.y = hit_top_y + debug_default_cube_size / 2.0;
                debug_placement_pos.x = debug_hit_pos.x;
                debug_placement_pos.z = debug_hit_pos.z;
            }
        }
        
        // Store the preview position for actual placement to use (update every frame)
        stored_preview_pos = debug_placement_pos;
        stored_preview_valid = 1; // Mark as valid
        
        // Draw preview wireframe at the actual placement position (where block will be placed)
        // Show cube wireframe in cube mode, wedge wireframe in wedge mode
        // Unit square (100 units = 1 meter) for better precision
        if build_mode == 0 {
            // Cube mode: draw red cube wireframe
            heidic_draw_cube_wireframe(debug_placement_pos.x, debug_placement_pos.y, debug_placement_pos.z, 0.0, 0.0, 0.0, 100.0, 100.0, 100.0, 1.0, 0.0, 0.0);
        } else {
            // Wedge mode: draw red wedge wireframe with rotation
            // Custom rotation values for each of the 12 positions
            let wedge_rot_x: f32 = 0.0;
            let wedge_rot_y: f32 = 0.0;
            let wedge_rot_z: f32 = 0.0;
            
            if wedge_preview_rotation == 0 {
                wedge_rot_x = 270.0;
                wedge_rot_y = 180.0;
                wedge_rot_z = 90.0;
            } else {
                if wedge_preview_rotation == 1 {
                    wedge_rot_x = 180.0;
                    wedge_rot_y = 90.0;
                    wedge_rot_z = 270.0;
                } else {
                    if wedge_preview_rotation == 2 {
                        wedge_rot_x = 90.0;
                        wedge_rot_y = 270.0;
                        wedge_rot_z = 180.0;
                    } else {
                        if wedge_preview_rotation == 3 {
                            wedge_rot_x = 180.0;
                            wedge_rot_y = 0.0;
                            wedge_rot_z = 270.0;
                        } else {
                            if wedge_preview_rotation == 4 {
                                wedge_rot_x = 180.0;
                                wedge_rot_y = 180.0;
                                wedge_rot_z = 90.0;
                            } else {
                                if wedge_preview_rotation == 5 {
                                    wedge_rot_x = 180.0;
                                    wedge_rot_y = 90.0;
                                    wedge_rot_z = 90.0;
                                } else {
                                    if wedge_preview_rotation == 6 {
                                        wedge_rot_x = 180.0;
                                        wedge_rot_y = 270.0;
                                        wedge_rot_z = 90.0;
                                    } else {
                                        if wedge_preview_rotation == 7 {
                                            wedge_rot_x = 180.0;
                                            wedge_rot_y = 0.0;
                                            wedge_rot_z = 90.0;
                                        } else {
                                            if wedge_preview_rotation == 8 {
                                                wedge_rot_x = 180.0;
                                                wedge_rot_y = 90.0;
                                                wedge_rot_z = 180.0;
                                            } else {
                                                if wedge_preview_rotation == 9 {
                                                    wedge_rot_x = 90.0;
                                                    wedge_rot_y = 270.0;
                                                    wedge_rot_z = 270.0;
                                                } else {
                                                    if wedge_preview_rotation == 10 {
                                                        wedge_rot_x = 90.0;
                                                        wedge_rot_y = 270.0;
                                                        wedge_rot_z = 90.0;
                                                    } else {
                                                        if wedge_preview_rotation == 11 {
                                                            wedge_rot_x = 180.0;
                                                            wedge_rot_y = 0.0;
                                                            wedge_rot_z = 180.0;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Update last rotation index after calculating (but before drawing)
            last_wedge_preview_rotation = wedge_preview_rotation;
            
            heidic_draw_wedge_wireframe(debug_placement_pos.x, debug_placement_pos.y, debug_placement_pos.z, wedge_rot_x, wedge_rot_y, wedge_rot_z, 100.0, 100.0, 100.0, 1.0, 0.0, 0.0);
        }
        
        // If we hit a cube, highlight the face (debug_hit_face was already calculated above)
        if debug_found_hit == 1 && debug_is_ground_plane == 0 {
            // Recalculate bounds for highlighting (already calculated above, but need for drawing)
            let debug_cube_min_x: f32 = debug_hit_cube_x - debug_hit_cube_sx / 2.0;
            let debug_cube_max_x: f32 = debug_hit_cube_x + debug_hit_cube_sx / 2.0;
            let debug_cube_min_y: f32 = debug_hit_cube_y - debug_hit_cube_sy / 2.0;
            let debug_cube_max_y: f32 = debug_hit_cube_y + debug_hit_cube_sy / 2.0;
            let debug_cube_min_z: f32 = debug_hit_cube_z - debug_hit_cube_sz / 2.0;
            let debug_cube_max_z: f32 = debug_hit_cube_z + debug_hit_cube_sz / 2.0;
            
            // Draw highlighted filled face (bright yellow/green)
            // Show green on ALL valid attachment faces, not just the closest one
            let highlight_offset: f32 = 1.0; // Small offset to avoid z-fighting
            let grid_density: f32 = 10.0; // Number of grid lines per face dimension
            
            // Draw green grid on all valid attachment faces
            // For cubes: all 6 faces (0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front)
            // For wedges: all 6 faces of the bounding cube (wedges are inscribed in a cube)
            
            // Both cubes and wedges show green on all 6 faces of their bounding box
            // (Wedges are inscribed in a cube, so we treat them the same as cubes for attachment)
                // Cube: draw green on all 6 faces
                // Face 0 (left)
                let y1: f32 = debug_cube_min_y;
                let y2: f32 = debug_cube_max_y;
                let z1: f32 = debug_cube_min_z;
                let z2: f32 = debug_cube_max_z;
                let x_left: f32 = debug_cube_min_x - highlight_offset;
                
                // Draw outline
                heidic_draw_line(x_left, y1, z1, x_left, y2, z1, 0.0, 1.0, 0.0);
                heidic_draw_line(x_left, y2, z1, x_left, y2, z2, 0.0, 1.0, 0.0);
                heidic_draw_line(x_left, y2, z2, x_left, y1, z2, 0.0, 1.0, 0.0);
                heidic_draw_line(x_left, y1, z2, x_left, y1, z1, 0.0, 1.0, 0.0);
                
                // Fill with grid pattern
                let grid_step_y: f32 = (y2 - y1) / grid_density;
                let grid_i: i32 = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_y: f32 = y1 + heidic_int_to_float(grid_i) * grid_step_y;
                    heidic_draw_line(x_left, grid_y, z1, x_left, grid_y, z2, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                let grid_step_z: f32 = (z2 - z1) / grid_density;
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_z: f32 = z1 + heidic_int_to_float(grid_i) * grid_step_z;
                    heidic_draw_line(x_left, y1, grid_z, x_left, y2, grid_z, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                
                // Face 1 (right)
                let x_right: f32 = debug_cube_max_x + highlight_offset;
                
                // Draw outline
                heidic_draw_line(x_right, y1, z1, x_right, y2, z1, 0.0, 1.0, 0.0);
                heidic_draw_line(x_right, y2, z1, x_right, y2, z2, 0.0, 1.0, 0.0);
                heidic_draw_line(x_right, y2, z2, x_right, y1, z2, 0.0, 1.0, 0.0);
                heidic_draw_line(x_right, y1, z2, x_right, y1, z1, 0.0, 1.0, 0.0);
                
                // Fill with grid pattern
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_y: f32 = y1 + heidic_int_to_float(grid_i) * grid_step_y;
                    heidic_draw_line(x_right, grid_y, z1, x_right, grid_y, z2, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_z: f32 = z1 + heidic_int_to_float(grid_i) * grid_step_z;
                    heidic_draw_line(x_right, y1, grid_z, x_right, y2, grid_z, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                
                // Face 2 (bottom)
                let x1: f32 = debug_cube_min_x;
                let x2: f32 = debug_cube_max_x;
                let y_bottom: f32 = debug_cube_min_y - highlight_offset;
                
                // Draw outline
                heidic_draw_line(x1, y_bottom, z1, x2, y_bottom, z1, 0.0, 1.0, 0.0);
                heidic_draw_line(x2, y_bottom, z1, x2, y_bottom, z2, 0.0, 1.0, 0.0);
                heidic_draw_line(x2, y_bottom, z2, x1, y_bottom, z2, 0.0, 1.0, 0.0);
                heidic_draw_line(x1, y_bottom, z2, x1, y_bottom, z1, 0.0, 1.0, 0.0);
                
                // Fill with grid pattern
                let grid_step_x: f32 = (x2 - x1) / grid_density;
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_x: f32 = x1 + heidic_int_to_float(grid_i) * grid_step_x;
                    heidic_draw_line(grid_x, y_bottom, z1, grid_x, y_bottom, z2, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_z: f32 = z1 + heidic_int_to_float(grid_i) * grid_step_z;
                    heidic_draw_line(x1, y_bottom, grid_z, x2, y_bottom, grid_z, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                
                // Face 3 (top)
                let y_top: f32 = debug_cube_max_y + highlight_offset;
                
                // Draw outline
                heidic_draw_line(x1, y_top, z1, x2, y_top, z1, 0.0, 1.0, 0.0);
                heidic_draw_line(x2, y_top, z1, x2, y_top, z2, 0.0, 1.0, 0.0);
                heidic_draw_line(x2, y_top, z2, x1, y_top, z2, 0.0, 1.0, 0.0);
                heidic_draw_line(x1, y_top, z2, x1, y_top, z1, 0.0, 1.0, 0.0);
                
                // Fill with grid pattern
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_x: f32 = x1 + heidic_int_to_float(grid_i) * grid_step_x;
                    heidic_draw_line(grid_x, y_top, z1, grid_x, y_top, z2, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_z: f32 = z1 + heidic_int_to_float(grid_i) * grid_step_z;
                    heidic_draw_line(x1, y_top, grid_z, x2, y_top, grid_z, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                
                // Face 4 (back)
                let z_back: f32 = debug_cube_min_z - highlight_offset;
                
                // Draw outline
                heidic_draw_line(x1, y1, z_back, x2, y1, z_back, 0.0, 1.0, 0.0);
                heidic_draw_line(x2, y1, z_back, x2, y2, z_back, 0.0, 1.0, 0.0);
                heidic_draw_line(x2, y2, z_back, x1, y2, z_back, 0.0, 1.0, 0.0);
                heidic_draw_line(x1, y2, z_back, x1, y1, z_back, 0.0, 1.0, 0.0);
                
                // Fill with grid pattern
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_x: f32 = x1 + heidic_int_to_float(grid_i) * grid_step_x;
                    heidic_draw_line(grid_x, y1, z_back, grid_x, y2, z_back, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_y: f32 = y1 + heidic_int_to_float(grid_i) * grid_step_y;
                    heidic_draw_line(x1, grid_y, z_back, x2, grid_y, z_back, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                
                // Face 5 (front)
                let z_front: f32 = debug_cube_max_z + highlight_offset;
                
                // Draw outline
                heidic_draw_line(x1, y1, z_front, x2, y1, z_front, 0.0, 1.0, 0.0);
                heidic_draw_line(x2, y1, z_front, x2, y2, z_front, 0.0, 1.0, 0.0);
                heidic_draw_line(x2, y2, z_front, x1, y2, z_front, 0.0, 1.0, 0.0);
                heidic_draw_line(x1, y2, z_front, x1, y1, z_front, 0.0, 1.0, 0.0);
                
                // Fill with grid pattern
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_x: f32 = x1 + heidic_int_to_float(grid_i) * grid_step_x;
                    heidic_draw_line(grid_x, y1, z_front, grid_x, y2, z_front, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_y: f32 = y1 + heidic_int_to_float(grid_i) * grid_step_y;
                    heidic_draw_line(x1, grid_y, z_front, x2, grid_y, z_front, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
            }
        }
        // print("[HEIDIC DEBUG] End of raycast debug block\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] After closing raycast debug block, before input handling\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to start input handling\n");  // Debug: uncomment when needed
        
        // Mouse mode toggle: Left-click enables mouse (cursor visible, picking on), Right-click disables (cursor hidden, dolly/look on)
        // print("[HEIDIC DEBUG] About to get mouse button states\n");  // Debug: uncomment when needed
        let mouse_left_pressed: i32 = heidic_is_mouse_button_pressed(window, 0);
        // print("[HEIDIC DEBUG] Got mouse_left_pressed\n");  // Debug: uncomment when needed
        let mouse_right_pressed: i32 = heidic_is_mouse_button_pressed(window, 1);
        // print("[HEIDIC DEBUG] Got mouse_right_pressed\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to handle mouse mode toggle\n");  // Debug: uncomment when needed
        
        // Left-click: Enable mouse mode (cursor visible, picking enabled)
        // print("[HEIDIC DEBUG] About to check mouse_left_pressed\n");  // Debug: uncomment when needed
        if mouse_left_pressed == 1 {
            // print("[HEIDIC DEBUG] mouse_left_pressed is 1\n");  // Debug: uncomment when needed
            if mouse_mode_left_was_pressed == 0 {
                // print("[HEIDIC DEBUG] mouse_mode_left_was_pressed is 0, enabling mouse mode\n");  // Debug: uncomment when needed
                mouse_mode = 1; // Enable mouse mode
                // print("[HEIDIC DEBUG] About to call heidic_set_cursor_mode\n");  // Debug: uncomment when needed
                heidic_set_cursor_mode(window, 0); // 0 = normal (visible cursor)
                // print("[HEIDIC DEBUG] After heidic_set_cursor_mode\n");  // Debug: uncomment when needed
                mouse_mode_left_was_pressed = 1;
            }
        } else {
            mouse_mode_left_was_pressed = 0;
        }
        // print("[HEIDIC DEBUG] After mouse_left_pressed handling\n");  // Debug: uncomment when needed
        
        // Right-click: Disable mouse mode (cursor hidden, dolly/look enabled)
        // print("[HEIDIC DEBUG] About to check mouse_right_pressed\n");  // Debug: uncomment when needed
        if mouse_right_pressed == 1 {
            // print("[HEIDIC DEBUG] mouse_right_pressed is 1\n");  // Debug: uncomment when needed
            if mouse_mode_right_was_pressed == 0 {
                // print("[HEIDIC DEBUG] mouse_mode_right_was_pressed is 0, disabling mouse mode\n");  // Debug: uncomment when needed
                mouse_mode = 0; // Disable mouse mode
                if camera_mode == 1 {
                    // In walk mode, capture cursor for mouse look
                    // print("[HEIDIC DEBUG] camera_mode is 1, setting cursor to captured\n");  // Debug: uncomment when needed
                    heidic_set_cursor_mode(window, 2); // 2 = disabled (captured)
                    // print("[HEIDIC DEBUG] After heidic_set_cursor_mode(2)\n");  // Debug: uncomment when needed
                } else {
                    // In top-down mode, just hide cursor
                    // print("[HEIDIC DEBUG] camera_mode is not 1, setting cursor to hidden\n");  // Debug: uncomment when needed
                    heidic_set_cursor_mode(window, 1); // 1 = hidden
                    // print("[HEIDIC DEBUG] After heidic_set_cursor_mode(1)\n");  // Debug: uncomment when needed
                }
                mouse_mode_right_was_pressed = 1;
            } else {
                // print("[HEIDIC DEBUG] mouse_mode_right_was_pressed is not 0, skipping\n");  // Debug: uncomment when needed
            }
        } else {
            // print("[HEIDIC DEBUG] mouse_right_pressed is not 1\n");  // Debug: uncomment when needed
            mouse_mode_right_was_pressed = 0;
        }
        // print("[HEIDIC DEBUG] After mouse_right_pressed handling\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to continue after mouse mode handling\n");  // Debug: uncomment when needed
        
        // DEBUG: Print ray info on click
        // if mouse_left_pressed == 1 {
        //    if mouse_left_was_pressed == 0 {
        //        heidic_debug_print_ray(window);
        //    }
        // }
        
        // Check gizmo interaction FIRST (before selection processing)
        // print("[HEIDIC DEBUG] About to check gizmo interaction\n");  // Debug: uncomment when needed
        // This prevents deselection when clicking on gizmos
        // print("[HEIDIC DEBUG] Initializing gizmo_clicked\n");  // Debug: uncomment when needed
        let gizmo_clicked: i32 = 0;
        // print("[HEIDIC DEBUG] After initializing gizmo_clicked\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to check gizmo interaction conditions\n");  // Debug: uncomment when needed
        if mouse_mode == 1 && mouse_left_pressed == 1 && alt_pressed == 0 && has_mesh_selection == 1 && selected_mesh_instance_id >= 0 {
            // print("[HEIDIC DEBUG] Gizmo interaction conditions met, entering block\n");  // Debug: uncomment when needed
            // A mesh is selected - check if gizmo would be clicked
            let mesh_center_x: f32 = heidic_get_mesh_instance_center_x(selected_mesh_instance_id);
            let mesh_center_y: f32 = heidic_get_mesh_instance_center_y(selected_mesh_instance_id);
            let mesh_center_z: f32 = heidic_get_mesh_instance_center_z(selected_mesh_instance_id);
            let gizmo_x: f32 = selected_mesh_x + mesh_center_x;
            let gizmo_y: f32 = selected_mesh_y + mesh_center_y;
            let gizmo_z: f32 = selected_mesh_z + mesh_center_z;
            let current_scale: f32 = heidic_get_mesh_instance_sx(selected_mesh_instance_id);
            
            // Check if translation gizmo would be clicked (by calling it, but we'll check interaction state)
            // We need to call it to update its internal state, but we'll check if it becomes active
            let temp_pos: Vec3 = heidic_gizmo_translate(window, gizmo_x, gizmo_y, gizmo_z);
            let translate_interacting: i32 = heidic_gizmo_is_interacting();
            
            // Check if scale gizmo would be clicked
            let bbox_min_x: f32 = heidic_get_mesh_instance_bbox_min_x(selected_mesh_instance_id);
            let bbox_min_y: f32 = heidic_get_mesh_instance_bbox_min_y(selected_mesh_instance_id);
            let bbox_min_z: f32 = heidic_get_mesh_instance_bbox_min_z(selected_mesh_instance_id);
            let bbox_max_x: f32 = heidic_get_mesh_instance_bbox_max_x(selected_mesh_instance_id);
            let bbox_max_y: f32 = heidic_get_mesh_instance_bbox_max_y(selected_mesh_instance_id);
            let bbox_max_z: f32 = heidic_get_mesh_instance_bbox_max_z(selected_mesh_instance_id);
            let temp_scale: f32 = heidic_gizmo_scale(window, gizmo_x, gizmo_y, gizmo_z,
                                                     bbox_min_x, bbox_min_y, bbox_min_z,
                                                     bbox_max_x, bbox_max_y, bbox_max_z,
                                                     current_scale);
            let scale_interacting: i32 = heidic_gizmo_scale_is_interacting();
            
            if translate_interacting == 1 || scale_interacting == 1 {
                gizmo_clicked = 1;
            }
        } else {
            // print("[HEIDIC DEBUG] Gizmo interaction conditions not met\n");  // Debug: uncomment when needed
        }
        // print("[HEIDIC DEBUG] After gizmo interaction check\n");  // Debug: uncomment when needed
        
        // Selection: Click to select cubes - test ALL cubes
        // Only allow selection when mouse_mode is enabled AND Alt is NOT pressed (Alt+Click is for orbit, not selection)
        // print("[HEIDIC DEBUG] About to check selection conditions\n");  // Debug: uncomment when needed
        if mouse_mode == 1 && mouse_left_pressed == 1 && alt_pressed == 0 {
            // print("[HEIDIC DEBUG] Selection conditions met, entering block\n");  // Debug: uncomment when needed
            // Check if Ctrl is pressed for multi-select
            let ctrl_left_pressed: i32 = heidic_is_key_pressed(window, 341);
            let ctrl_right_pressed: i32 = heidic_is_key_pressed(window, 345);
            let ctrl_pressed: i32 = 0;
            if ctrl_left_pressed == 1 || ctrl_right_pressed == 1 {
                ctrl_pressed = 1;
            }
            
            // Only check gizmo interaction if we're NOT doing a fresh click
            // This allows selection even if gizmo axes are being hovered
            let interacting: i32 = 0;
            let scale_interacting: i32 = 0;
            if mouse_left_was_pressed == 1 {
                // Already was pressed - check if gizmo is actively being dragged
                interacting = heidic_gizmo_is_interacting();
                scale_interacting = heidic_gizmo_scale_is_interacting();
            }
            
            // Skip selection processing if gizmo was clicked
            if gizmo_clicked == 0 && (interacting == 0 && scale_interacting == 0) {
                if mouse_left_was_pressed == 0 {
                    // Just clicked - test raycast against all cubes and find closest hit
                    // Initialize closest_dist to a very large number (squared distance)
                    // 100,000,000,000.0 is roughly 316,000 units (3.16 km) distance
                    let closest_dist: f32 = 100000000000.0;
                    let hit_cube_index: i32 = -1;
                    
                    // Player cube is NOT selectable (it's invisible in walk mode and shouldn't interfere)
                    // Skip player cube selection test
                    
                    // Test Created Cubes (Dynamic system - indices start at 2.0)
                    let cube_test_index: i32 = 0;
                    let total_cubes_test: i32 = heidic_get_cube_total_count();
                    while cube_test_index < total_cubes_test {
                        if heidic_get_cube_active(cube_test_index) == 1 {
                            let test_cube_x: f32 = heidic_get_cube_x(cube_test_index);
                            let test_cube_y: f32 = heidic_get_cube_y(cube_test_index);
                            let test_cube_z: f32 = heidic_get_cube_z(cube_test_index);
                            let test_cube_sx: f32 = heidic_get_cube_sx(cube_test_index);
                            let test_cube_sy: f32 = heidic_get_cube_sy(cube_test_index);
                            let test_cube_sz: f32 = heidic_get_cube_sz(cube_test_index);
                            
                            let created_hit: i32 = heidic_raycast_cube_hit(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                            if created_hit == 1 {
                                let hit_point: Vec3 = heidic_raycast_cube_hit_point(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                                let dist: f32 = (hit_point.x - ray_origin.x) * (hit_point.x - ray_origin.x) + (hit_point.y - ray_origin.y) * (hit_point.y - ray_origin.y) + (hit_point.z - ray_origin.z) * (hit_point.z - ray_origin.z);
                                if dist < closest_dist {
                                    closest_dist = dist;
                                    hit_cube_index = cube_test_index;
                                }
                            }
                        }
                        cube_test_index = cube_test_index + 1;
                    }
                    
                    // Test Wedges (similar to cubes)
                    let wedge_test_index: i32 = 0;
                    let total_wedges_test: i32 = heidic_get_wedge_total_count();
                    let hit_wedge_index: i32 = -1;
                    while wedge_test_index < total_wedges_test {
                        if heidic_get_wedge_active(wedge_test_index) == 1 {
                            let test_wedge_x: f32 = heidic_get_wedge_x(wedge_test_index);
                            let test_wedge_y: f32 = heidic_get_wedge_y(wedge_test_index);
                            let test_wedge_z: f32 = heidic_get_wedge_z(wedge_test_index);
                            let test_wedge_sx: f32 = heidic_get_wedge_sx(wedge_test_index);
                            let test_wedge_sy: f32 = heidic_get_wedge_sy(wedge_test_index);
                            let test_wedge_sz: f32 = heidic_get_wedge_sz(wedge_test_index);
                            
                            // Use cube raycast (wedges use bounding box for raycast)
                            let wedge_hit: i32 = heidic_raycast_cube_hit(window, test_wedge_x, test_wedge_y, test_wedge_z, test_wedge_sx, test_wedge_sy, test_wedge_sz);
                            if wedge_hit == 1 {
                                let hit_point: Vec3 = heidic_raycast_cube_hit_point(window, test_wedge_x, test_wedge_y, test_wedge_z, test_wedge_sx, test_wedge_sy, test_wedge_sz);
                                let dist: f32 = (hit_point.x - ray_origin.x) * (hit_point.x - ray_origin.x) + (hit_point.y - ray_origin.y) * (hit_point.y - ray_origin.y) + (hit_point.z - ray_origin.z) * (hit_point.z - ray_origin.z);
                                if dist < closest_dist {
                                    closest_dist = dist;
                                    hit_wedge_index = wedge_test_index;
                                    hit_cube_index = -1; // Clear cube hit if wedge is closer
                                }
                            }
                        }
                        wedge_test_index = wedge_test_index + 1;
                    }
                    
                    // Handle selection based on Ctrl state
                    if hit_wedge_index >= 0 {
                        // Wedge was clicked - select it
                        heidic_clear_selection();
                        heidic_clear_mesh_selection();
                        selected_wedge_index = hit_wedge_index;
                        selected_wedge_x = heidic_get_wedge_x(hit_wedge_index);
                        selected_wedge_y = heidic_get_wedge_y(hit_wedge_index);
                        selected_wedge_z = heidic_get_wedge_z(hit_wedge_index);
                        selected_wedge_sx = heidic_get_wedge_sx(hit_wedge_index);
                        selected_wedge_sy = heidic_get_wedge_sy(hit_wedge_index);
                        selected_wedge_sz = heidic_get_wedge_sz(hit_wedge_index);
                        has_wedge_selection = 1;
                        has_selection = 0;  // Clear cube selection
                        has_mesh_selection = 0;  // Clear mesh selection
                        selected_cube_index = -1.0;
                        selected_mesh_instance_id = -1;
                    } else {
                        if hit_cube_index >= 0 {
                            if ctrl_pressed == 1 {
                            // Ctrl+Click: Toggle multi-select
                            heidic_toggle_selection(hit_cube_index);
                        } else {
                            // Regular click: Clear selection and select only this cube
                            heidic_clear_selection();
                            heidic_add_to_selection(hit_cube_index);
                        }
                        
                        // Update single selection state for gizmo compatibility
                        let cube_index_f: f32 = heidic_int_to_float(hit_cube_index);
                        selected_cube_index = cube_index_f + 2.0;
                        selected_cube_x = heidic_get_cube_x(hit_cube_index);
                        selected_cube_y = heidic_get_cube_y(hit_cube_index);
                        selected_cube_z = heidic_get_cube_z(hit_cube_index);
                        selected_cube_sx = heidic_get_cube_sx(hit_cube_index);
                        selected_cube_sy = heidic_get_cube_sy(hit_cube_index);
                        selected_cube_sz = heidic_get_cube_sz(hit_cube_index);
                        has_selection = 1;
                        
                        // Initialize dolly orbit state for new selection
                        let target_pos: Vec3 = heidic_vec3(selected_cube_x, selected_cube_y, selected_cube_z);
                        let current_cam_pos: Vec3 = camera_pos;
                        let calculated_distance: f32 = heidic_vec3_distance(current_cam_pos, target_pos);
                        
                        // Use calculated distance if reasonable, otherwise use default
                        if calculated_distance > 10.0 && calculated_distance < 100000.0 {
                            dolly_orbit_distance = calculated_distance;
                        } else {
                            dolly_orbit_distance = 2000.0; // Default: 20 meters
                        }
                        dolly_orbit_azimuth = 0.0;
                        dolly_orbit_elevation = 45.0;
                        }
                    }
                    
                    mouse_left_was_pressed = 1;
                }
            } else {
                // Clicked on nothing - clear selection if not Ctrl+Click, not clicking on gizmo, and not clicking on ImGui
                let imgui_wants_mouse: i32 = heidic_imgui_wants_mouse();
                if ctrl_pressed == 0 && gizmo_clicked == 0 && imgui_wants_mouse == 0 {
                    heidic_clear_selection();
                    has_selection = 0;
                    selected_cube_index = -1.0;
                    
                    // Also clear mesh and wedge selection (only if not clicking on gizmo or ImGui)
                    heidic_clear_mesh_selection();
                    has_mesh_selection = 0;
                    selected_mesh_instance_id = -1;
                    has_wedge_selection = 0;
                    selected_wedge_index = -1;
                }
            }
        } else {
            mouse_left_was_pressed = 0;
        }
        // print("[HEIDIC DEBUG] After mouse click handling\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to close block_input check\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] Right before closing brace of block_input\n");  // Debug: uncomment when needed
        
        
        }  // End of block_input check
        // print("[HEIDIC DEBUG] IMMEDIATELY after closing brace\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] After block_input check closes\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to show selection and gizmo\n");  // Debug: uncomment when needed
        
        // Show selection and Gizmo (always show, even when editing)
        // print("[HEIDIC DEBUG] About to check has_selection\n");  // Debug: uncomment when needed
        if has_selection == 1 {
            // print("[HEIDIC DEBUG] has_selection is 1, entering block\n");  // Debug: uncomment when needed
            // Draw wireframe overlay (black)
            heidic_draw_cube_wireframe(selected_cube_x, selected_cube_y, selected_cube_z, 0.0, 0.0, 0.0, selected_cube_sx * 1.01, selected_cube_sy * 1.01, selected_cube_sz * 1.01, 0.0, 0.0, 0.0);
            
            // Gizmo: Move selected object
            // print("[HEIDIC DEBUG] About to call heidic_gizmo_translate\n");  // Debug: uncomment when needed
            let new_pos: Vec3 = heidic_gizmo_translate(window, selected_cube_x, selected_cube_y, selected_cube_z);
            // print("[HEIDIC DEBUG] After heidic_gizmo_translate\n");  // Debug: uncomment when needed
            
            // Update selected position (the ghost)
            selected_cube_x = new_pos.x;
            selected_cube_y = new_pos.y;
            selected_cube_z = new_pos.z;
            
            // Player cube is not selectable, so only update created cubes
            // If moving Created Cubes (selected_cube_index >= 2.0)
            // Map: selected_cube_index 2.0 -> cube index 0, 3.0 -> 1, etc.
            if selected_cube_index >= 2.0 {
                let cube_storage_index: f32 = selected_cube_index - 2.0;
                heidic_set_cube_pos_f(cube_storage_index, selected_cube_x, selected_cube_y, selected_cube_z);
            }
        }
        // print("[HEIDIC DEBUG] After has_selection check\n");  // Debug: uncomment when needed
        
        // Show mesh selection and Gizmo
        // print("[HEIDIC DEBUG] About to check mesh selection\n");  // Debug: uncomment when needed
        if has_mesh_selection == 1 && selected_mesh_instance_id >= 0 {
            // print("[HEIDIC DEBUG] Mesh selection conditions met\n");  // Debug: uncomment when needed
            // Refresh cached position values from instance (in case they were updated via input fields)
            selected_mesh_x = heidic_get_mesh_instance_x(selected_mesh_instance_id);
            selected_mesh_y = heidic_get_mesh_instance_y(selected_mesh_instance_id);
            selected_mesh_z = heidic_get_mesh_instance_z(selected_mesh_instance_id);
            
            // Get mesh center and bounding box for gizmo positioning
            let mesh_center_x: f32 = heidic_get_mesh_instance_center_x(selected_mesh_instance_id);
            let mesh_center_y: f32 = heidic_get_mesh_instance_center_y(selected_mesh_instance_id);
            let mesh_center_z: f32 = heidic_get_mesh_instance_center_z(selected_mesh_instance_id);
            
            // Get current scale
            let current_scale: f32 = heidic_get_mesh_instance_sx(selected_mesh_instance_id);
            
            // Calculate world position of mesh center (instance offset + original center)
            let gizmo_x: f32 = selected_mesh_x + mesh_center_x;
            let gizmo_y: f32 = selected_mesh_y + mesh_center_y;
            let gizmo_z: f32 = selected_mesh_z + mesh_center_z;
            
            // Check if scale gizmo is being used (prevents translation when scaling)
            let scale_interacting: i32 = heidic_gizmo_scale_is_interacting();
            let translate_interacting: i32 = heidic_gizmo_is_interacting();
            
            // Scale gizmo: Scale selected mesh (using bounding box corners)
            // Get bounding box from instance (relative to mesh center)
            let bbox_min_x: f32 = heidic_get_mesh_instance_bbox_min_x(selected_mesh_instance_id);
            let bbox_min_y: f32 = heidic_get_mesh_instance_bbox_min_y(selected_mesh_instance_id);
            let bbox_min_z: f32 = heidic_get_mesh_instance_bbox_min_z(selected_mesh_instance_id);
            let bbox_max_x: f32 = heidic_get_mesh_instance_bbox_max_x(selected_mesh_instance_id);
            let bbox_max_y: f32 = heidic_get_mesh_instance_bbox_max_y(selected_mesh_instance_id);
            let bbox_max_z: f32 = heidic_get_mesh_instance_bbox_max_z(selected_mesh_instance_id);
            
            let new_scale: f32 = heidic_gizmo_scale(window, gizmo_x, gizmo_y, gizmo_z,
                                                     bbox_min_x, bbox_min_y, bbox_min_z,
                                                     bbox_max_x, bbox_max_y, bbox_max_z,
                                                     current_scale);
            
            // Update scale if it changed
            if new_scale != current_scale {
                heidic_set_mesh_instance_scale(selected_mesh_instance_id, new_scale, new_scale, new_scale);
            }
            
            // Translation gizmo: Only update if scale gizmo is not active
            if scale_interacting == 0 {
                // Translation gizmo: Move selected mesh (positioned at mesh center)
                let new_gizmo_pos: Vec3 = heidic_gizmo_translate(window, gizmo_x, gizmo_y, gizmo_z);
                
                // Only update position if translation gizmo is actually being dragged
                if translate_interacting == 1 {
                    // Calculate new instance offset (gizmo position - mesh center)
                    let new_instance_x: f32 = new_gizmo_pos.x - mesh_center_x;
                    let new_instance_y: f32 = new_gizmo_pos.y - mesh_center_y;
                    let new_instance_z: f32 = new_gizmo_pos.z - mesh_center_z;
                    
                    // Update selected mesh position
                    selected_mesh_x = new_instance_x;
                    selected_mesh_y = new_instance_y;
                    selected_mesh_z = new_instance_z;
                    
                    // Update mesh instance position
                    heidic_set_mesh_instance_pos(selected_mesh_instance_id, selected_mesh_x, selected_mesh_y, selected_mesh_z);
                }
            }
        }
        // print("[HEIDIC DEBUG] End of raycasting section\n");  // Debug: uncomment when needed
        
        // print("[HEIDIC DEBUG] Before Codex Of Forms check (after all drawing)\n");  // Debug: uncomment when needed
        // print("[HEIDIC DEBUG] About to render ImGui windows\n");  // Debug: uncomment when needed
        // Codex Of Forms - Show combinations and uncombined cubes
        if show_debug == 1 {
            // print("[HEIDIC DEBUG] About to begin Codex Of Forms window\n");  // Debug: uncomment when needed
            if heidic_imgui_begin("Codex Of Forms") == 1 {
                // print("[HEIDIC DEBUG] Inside Codex Of Forms window\n");  // Debug: uncomment when needed
                let combination_count: i32 = heidic_get_combination_count();
                let total_cube_count: i32 = heidic_get_cube_total_count();
                
                // Global cube display index (sequential across all cubes)
                let global_cube_display_index: i32 = 1;
                
                // First, show all combinations with expand/collapse
                let combo_id: i32 = 0;
                while combo_id < combination_count {
                    // Push unique ID for this combination to avoid ID conflicts
                    heidic_imgui_push_id(combo_id);
                    
                    // Check if we're editing this combination
                    let editing_id: i32 = heidic_get_editing_combination_id();
                    let is_editing_this: i32 = 0;
                    if editing_id == combo_id {
                        is_editing_this = 1;
                    }
                    
                    // Get combination name (e.g., "combination_001")
                    let combo_name: string = heidic_format_combination_name(combo_id);
                    
                    // Show expand/collapse button (with unique ID)
                    let is_expanded: i32 = heidic_is_combination_expanded(combo_id);
                    let expand_button_text: string = "+";
                    if is_expanded == 1 {
                        expand_button_text = "-";
                    }
                    if heidic_imgui_button(expand_button_text) == 1 {
                        heidic_toggle_combination_expanded(combo_id);
                    }
                    heidic_imgui_same_line();
                    
                    // Always show input field next to combination name (no click needed)
                    // This function handles the buffer internally and returns 1 when Enter is pressed
                    let enter_pressed: i32 = heidic_imgui_input_text_combination_simple(combo_id);
                    // Enter pressed is handled inside the function (saves automatically)
                    
                    // If expanded, show cubes in this combination
                    if is_expanded == 1 {
                        let cube_index: i32 = 0;
                        
                        while cube_index < total_cube_count {
                            if heidic_get_cube_active(cube_index) == 1 {
                                if heidic_get_cube_combination_id(cube_index) == combo_id {
                                    // Push unique ID for this cube
                                    heidic_imgui_push_id(cube_index);
                                    
                                    // This cube belongs to this combination
                                    // Use global sequential numbering
                                    let cube_name: string = heidic_format_cube_name_with_index(global_cube_display_index);
                                    
                                    // Make cube name clickable to select it
                                    if heidic_is_cube_selected(cube_index) == 1 {
                                        // Selected: show in bold (yellow)
                                        heidic_imgui_text_bold(cube_name);
                                    } else {
                                        // Not selected: show in red and make clickable
                                        if heidic_imgui_selectable_colored(cube_name, 1.0, 0.0, 0.0, 1.0) == 1 {
                                            // Clicked: select this cube (clear others first if not Ctrl+Click)
                                            // For now, just select this one (can add Ctrl check later)
                                            heidic_clear_selection();
                                            heidic_add_to_selection(cube_index);
                                            
                                            // Update single selection state for gizmo
                                            let cube_index_f: f32 = heidic_int_to_float(cube_index);
                                            selected_cube_index = cube_index_f + 2.0;
                                            selected_cube_x = heidic_get_cube_x(cube_index);
                                            selected_cube_y = heidic_get_cube_y(cube_index);
                                            selected_cube_z = heidic_get_cube_z(cube_index);
                                            selected_cube_sx = heidic_get_cube_sx(cube_index);
                                            selected_cube_sy = heidic_get_cube_sy(cube_index);
                                            selected_cube_sz = heidic_get_cube_sz(cube_index);
                                            has_selection = 1;
                                        }
                                    }
                                    
                                    heidic_imgui_pop_id();
                                    global_cube_display_index = global_cube_display_index + 1;
                                }
                            }
                            cube_index = cube_index + 1;
                        }
                    } else {
                        // Even if collapsed, we need to count the cubes for global numbering
                        let cube_index: i32 = 0;
                        while cube_index < total_cube_count {
                            if heidic_get_cube_active(cube_index) == 1 {
                                if heidic_get_cube_combination_id(cube_index) == combo_id {
                                    global_cube_display_index = global_cube_display_index + 1;
                                }
                            }
                            cube_index = cube_index + 1;
                        }
                    }
                    
                    // Pop combination ID
                    heidic_imgui_pop_id();
                    combo_id = combo_id + 1;
                }
                
                // Then, show uncombined cubes (cubes with combination_id == -1)
                let cube_index: i32 = 0;
                
                while cube_index < total_cube_count {
                    if heidic_get_cube_active(cube_index) == 1 {
                        if heidic_get_cube_combination_id(cube_index) == -1 {
                            // Push unique ID for this cube
                            heidic_imgui_push_id(cube_index);
                            
                            // This cube is not in any combination
                            let cube_name: string = heidic_format_cube_name_with_index(global_cube_display_index);
                            
                            // Make cube name clickable to select it
                            if heidic_is_cube_selected(cube_index) == 1 {
                                // Selected: show in bold (yellow)
                                heidic_imgui_text_bold(cube_name);
                            } else {
                                // Not selected: make clickable
                                if heidic_imgui_selectable_str(cube_name) == 1 {
                                    // Clicked: select this cube (clear others first if not Ctrl+Click)
                                    heidic_clear_selection();
                                    heidic_add_to_selection(cube_index);
                                    
                                    // Update single selection state for gizmo
                                    let cube_index_f: f32 = heidic_int_to_float(cube_index);
                                    selected_cube_index = cube_index_f + 2.0;
                                    selected_cube_x = heidic_get_cube_x(cube_index);
                                    selected_cube_y = heidic_get_cube_y(cube_index);
                                    selected_cube_z = heidic_get_cube_z(cube_index);
                                    selected_cube_sx = heidic_get_cube_sx(cube_index);
                                    selected_cube_sy = heidic_get_cube_sy(cube_index);
                                    selected_cube_sz = heidic_get_cube_sz(cube_index);
                                    has_selection = 1;
                                }
                            }
                            
                            heidic_imgui_pop_id();
                            global_cube_display_index = global_cube_display_index + 1;
                        }
                    }
                    cube_index = cube_index + 1;
                }
                
                // Show mesh instances in outliner
                let mesh_instance_count: i32 = heidic_get_mesh_instance_total_count();
                if mesh_instance_count > 0 {
                    heidic_imgui_separator();
                    heidic_imgui_text("Meshes:");
                    
                    let mesh_instance_index: i32 = 0;
                    while mesh_instance_index < mesh_instance_count {
                        if heidic_get_mesh_instance_active(mesh_instance_index) == 1 {
                            heidic_imgui_push_id(mesh_instance_index + 10000);  // Offset to avoid conflicts
                            
                            let mesh_name: string = heidic_format_mesh_name(mesh_instance_index);
                            
                            // Make mesh name clickable to toggle selection
                            let is_mesh_selected: i32 = heidic_is_mesh_selected(mesh_instance_index);
                            
                            // Always use selectable so it's clickable whether selected or not
                            // Selectable will show visual feedback (highlighted when selected)
                            if heidic_imgui_selectable_str(mesh_name) == 1 {
                                if is_mesh_selected == 1 {
                                    // Already selected: clicking again deselects it
                                    heidic_clear_mesh_selection();
                                    has_mesh_selection = 0;
                                    selected_mesh_instance_id = -1;
                                } else {
                                    // Not selected: clicking selects it
                                    heidic_clear_selection();
                                    heidic_clear_mesh_selection();
                                    heidic_add_mesh_to_selection(mesh_instance_index);
                                    
                                    // Update mesh selection state for gizmo
                                    selected_mesh_instance_id = mesh_instance_index;
                                    selected_mesh_x = heidic_get_mesh_instance_x(mesh_instance_index);
                                    selected_mesh_y = heidic_get_mesh_instance_y(mesh_instance_index);
                                    selected_mesh_z = heidic_get_mesh_instance_z(mesh_instance_index);
                                    has_mesh_selection = 1;
                                    has_selection = 0;  // Clear cube selection
                                    selected_cube_index = -1.0;
                                }
                            }
                            
                            heidic_imgui_pop_id();
                        }
                        mesh_instance_index = mesh_instance_index + 1;
                    }
                }
                
                // Show wedges in outliner
                let wedge_total_count: i32 = heidic_get_wedge_total_count();
                if wedge_total_count > 0 {
                    heidic_imgui_separator();
                    heidic_imgui_text("Wedges:");
                    
                    let wedge_index: i32 = 0;
                    while wedge_index < wedge_total_count {
                        if heidic_get_wedge_active(wedge_index) == 1 {
                            heidic_imgui_push_id(wedge_index + 20000);  // Offset to avoid conflicts
                            
                            let wedge_name: string = heidic_format_wedge_name(wedge_index);
                            
                            // Make wedge name clickable to toggle selection
                            let is_wedge_selected: i32 = 0;
                            if has_wedge_selection == 1 && selected_wedge_index == wedge_index {
                                is_wedge_selected = 1;
                            }
                            
                            if is_wedge_selected == 1 {
                                // Selected: show in bold
                                heidic_imgui_text_bold(wedge_name);
                            } else {
                                // Not selected: make clickable
                                if heidic_imgui_selectable_str(wedge_name) == 1 {
                                    // Clicked: select this wedge
                                    heidic_clear_selection();
                                    heidic_clear_mesh_selection();
                                    selected_wedge_index = wedge_index;
                                    selected_wedge_x = heidic_get_wedge_x(wedge_index);
                                    selected_wedge_y = heidic_get_wedge_y(wedge_index);
                                    selected_wedge_z = heidic_get_wedge_z(wedge_index);
                                    selected_wedge_sx = heidic_get_wedge_sx(wedge_index);
                                    selected_wedge_sy = heidic_get_wedge_sy(wedge_index);
                                    selected_wedge_sz = heidic_get_wedge_sz(wedge_index);
                                    has_wedge_selection = 1;
                                    has_selection = 0;  // Clear cube selection
                                    has_mesh_selection = 0;  // Clear mesh selection
                                    selected_cube_index = -1.0;
                                    selected_mesh_instance_id = -1;
                                }
                            }
                            
                            heidic_imgui_pop_id();
                        }
                        wedge_index = wedge_index + 1;
                    }
                }
                
                heidic_imgui_end();
            }
            
            // Wedge Rotation Position Panel (shows current position and coordinates)
            if build_mode == 1 {
                if heidic_imgui_begin("Wedge Rotation Position") == 1 {
                    // Calculate current rotation values based on position
                    let current_rot_x: f32 = 0.0;
                    let current_rot_y: f32 = 0.0;
                    let current_rot_z: f32 = 0.0;
                    
                    if wedge_preview_rotation == 0 {
                        current_rot_x = 270.0;
                        current_rot_y = 180.0;
                        current_rot_z = 90.0;
                    } else {
                        if wedge_preview_rotation == 1 {
                            current_rot_x = 180.0;
                            current_rot_y = 90.0;
                            current_rot_z = 270.0;
                        } else {
                            if wedge_preview_rotation == 2 {
                                current_rot_x = 90.0;
                                current_rot_y = 270.0;
                                current_rot_z = 180.0;
                            } else {
                                if wedge_preview_rotation == 3 {
                                    current_rot_x = 180.0;
                                    current_rot_y = 0.0;
                                    current_rot_z = 270.0;
                                } else {
                                    if wedge_preview_rotation == 4 {
                                        current_rot_x = 180.0;
                                        current_rot_y = 180.0;
                                        current_rot_z = 90.0;
                                    } else {
                                        if wedge_preview_rotation == 5 {
                                            current_rot_x = 180.0;
                                            current_rot_y = 90.0;
                                            current_rot_z = 90.0;
                                        } else {
                                            if wedge_preview_rotation == 6 {
                                                current_rot_x = 180.0;
                                                current_rot_y = 270.0;
                                                current_rot_z = 90.0;
                                            } else {
                                                if wedge_preview_rotation == 7 {
                                                    current_rot_x = 180.0;
                                                    current_rot_y = 0.0;
                                                    current_rot_z = 90.0;
                                                } else {
                                                    if wedge_preview_rotation == 8 {
                                                        current_rot_x = 180.0;
                                                        current_rot_y = 90.0;
                                                        current_rot_z = 180.0;
                                                    } else {
                                                        if wedge_preview_rotation == 9 {
                                                            current_rot_x = 90.0;
                                                            current_rot_y = 270.0;
                                                            current_rot_z = 270.0;
                                                        } else {
                                                            if wedge_preview_rotation == 10 {
                                                                current_rot_x = 90.0;
                                                                current_rot_y = 270.0;
                                                                current_rot_z = 90.0;
                                                            } else {
                                                                if wedge_preview_rotation == 11 {
                                                                    current_rot_x = 180.0;
                                                                    current_rot_y = 0.0;
                                                                    current_rot_z = 180.0;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    heidic_imgui_text("Current Position:");
                    heidic_imgui_text("Index:");
                    heidic_imgui_same_line();
                    heidic_imgui_text_float("##PosIndex", heidic_int_to_float(wedge_preview_rotation));
                    heidic_imgui_text("(0-11)");
                    
                    heidic_imgui_separator();
                    
                    heidic_imgui_text("Rotation Coordinates:");
                    heidic_imgui_text("X:");
                    heidic_imgui_same_line();
                    heidic_imgui_text_float("##RotX", current_rot_x);
                    heidic_imgui_text("Y:");
                    heidic_imgui_same_line();
                    heidic_imgui_text_float("##RotY", current_rot_y);
                    heidic_imgui_text("Z:");
                    heidic_imgui_same_line();
                    heidic_imgui_text_float("##RotZ", current_rot_z);
                    
                    heidic_imgui_separator();
                    heidic_imgui_text("Use mouse wheel to cycle");
                    heidic_imgui_text("through 12 positions");
                    
                    heidic_imgui_end();
                }
            }
            
            // Transform Control Window for Selected Wedge
            if has_wedge_selection == 1 && selected_wedge_index >= 0 {
                if heidic_imgui_begin("Transform Control") == 1 {
                    // Get current transform values
                    let current_x: f32 = heidic_get_wedge_x(selected_wedge_index);
                    let current_y: f32 = heidic_get_wedge_y(selected_wedge_index);
                    let current_z: f32 = heidic_get_wedge_z(selected_wedge_index);
                    let current_sx: f32 = heidic_get_wedge_sx(selected_wedge_index);
                    let current_sy: f32 = heidic_get_wedge_sy(selected_wedge_index);
                    let current_sz: f32 = heidic_get_wedge_sz(selected_wedge_index);
                    let current_rx: f32 = heidic_get_wedge_rx(selected_wedge_index);
                    let current_ry: f32 = heidic_get_wedge_ry(selected_wedge_index);
                    let current_rz: f32 = heidic_get_wedge_rz(selected_wedge_index);
                    
                    // Translation Inputs
                    heidic_imgui_text("Translation:");
                    heidic_imgui_text("X:");
                    heidic_imgui_same_line();
                    let new_x: f32 = heidic_imgui_input_float("##WedgeTransX", current_x, 1.0, 10.0);
                    heidic_imgui_text("Y:");
                    heidic_imgui_same_line();
                    let new_y: f32 = heidic_imgui_input_float("##WedgeTransY", current_y, 1.0, 10.0);
                    heidic_imgui_text("Z:");
                    heidic_imgui_same_line();
                    let new_z: f32 = heidic_imgui_input_float("##WedgeTransZ", current_z, 1.0, 10.0);
                    if new_x != current_x || new_y != current_y || new_z != current_z {
                        heidic_set_wedge_pos(selected_wedge_index, new_x, new_y, new_z);
                        selected_wedge_x = new_x;
                        selected_wedge_y = new_y;
                        selected_wedge_z = new_z;
                    }
                    
                    heidic_imgui_separator();
                    
                    // Scale Inputs
                    heidic_imgui_text("Scale:");
                    heidic_imgui_text("X:");
                    heidic_imgui_same_line();
                    let new_sx: f32 = heidic_imgui_input_float("##WedgeScaleX", current_sx, 0.1, 1.0);
                    heidic_imgui_text("Y:");
                    heidic_imgui_same_line();
                    let new_sy: f32 = heidic_imgui_input_float("##WedgeScaleY", current_sy, 0.1, 1.0);
                    heidic_imgui_text("Z:");
                    heidic_imgui_same_line();
                    let new_sz: f32 = heidic_imgui_input_float("##WedgeScaleZ", current_sz, 0.1, 1.0);
                    if new_sx < 0.01 {
                        new_sx = 0.01;
                    }
                    if new_sy < 0.01 {
                        new_sy = 0.01;
                    }
                    if new_sz < 0.01 {
                        new_sz = 0.01;
                    }
                    if new_sx != current_sx || new_sy != current_sy || new_sz != current_sz {
                        heidic_set_wedge_scale(selected_wedge_index, new_sx, new_sy, new_sz);
                    }
                    
                    heidic_imgui_separator();
                    
                    // Rotation - Slider and Input (both work independently)
                    heidic_imgui_text("Rotation:");
                    // X Rotation - Slider and Input
                    let new_rx_slider: f32 = heidic_imgui_slider_float("Rotation X", current_rx, 0.0, 360.0);
                    let new_rx_input: f32 = heidic_imgui_input_float("##WedgeRX", current_rx, 1.0, 10.0);
                    let new_rx: f32 = new_rx_slider;
                    if new_rx_input != current_rx {
                        new_rx = new_rx_input;
                    }
                    if new_rx != current_rx {
                        if new_rx < 0.0 {
                            new_rx = 0.0;
                        }
                        if new_rx > 360.0 {
                            new_rx = 360.0;
                        }
                        heidic_set_wedge_rotation(selected_wedge_index, new_rx, current_ry, current_rz);
                    }
                    
                    // Y Rotation - Slider and Input
                    let new_ry_slider: f32 = heidic_imgui_slider_float("Rotation Y", current_ry, 0.0, 360.0);
                    let new_ry_input: f32 = heidic_imgui_input_float("##WedgeRY", current_ry, 1.0, 10.0);
                    let new_ry: f32 = new_ry_slider;
                    if new_ry_input != current_ry {
                        new_ry = new_ry_input;
                    }
                    if new_ry != current_ry {
                        if new_ry < 0.0 {
                            new_ry = 0.0;
                        }
                        if new_ry > 360.0 {
                            new_ry = 360.0;
                        }
                        heidic_set_wedge_rotation(selected_wedge_index, current_rx, new_ry, current_rz);
                    }
                    
                    // Z Rotation - Slider and Input
                    let new_rz_slider: f32 = heidic_imgui_slider_float("Rotation Z", current_rz, 0.0, 360.0);
                    let new_rz_input: f32 = heidic_imgui_input_float("##WedgeRZ", current_rz, 1.0, 10.0);
                    let new_rz: f32 = new_rz_slider;
                    if new_rz_input != current_rz {
                        new_rz = new_rz_input;
                    }
                    if new_rz != current_rz {
                        if new_rz < 0.0 {
                            new_rz = 0.0;
                        }
                        if new_rz > 360.0 {
                            new_rz = 360.0;
                        }
                        heidic_set_wedge_rotation(selected_wedge_index, current_rx, current_ry, new_rz);
                    }
                    
                    heidic_imgui_end();
                }
            }
            
            // Transform Control Window
            if has_mesh_selection == 1 && selected_mesh_instance_id >= 0 {
                print("[HEIDIC DEBUG] About to begin Transform Control window (mesh)\n");
                if heidic_imgui_begin("Transform Control") == 1 {
                    print("[HEIDIC DEBUG] Inside Transform Control window (mesh)\n");
                    // Get current transform values
                    let current_x: f32 = heidic_get_mesh_instance_x(selected_mesh_instance_id);
                    let current_y: f32 = heidic_get_mesh_instance_y(selected_mesh_instance_id);
                    let current_z: f32 = heidic_get_mesh_instance_z(selected_mesh_instance_id);
                    let current_sx: f32 = heidic_get_mesh_instance_sx(selected_mesh_instance_id);
                    let current_sy: f32 = heidic_get_mesh_instance_sy(selected_mesh_instance_id);
                    let current_sz: f32 = heidic_get_mesh_instance_sz(selected_mesh_instance_id);
                    let current_rx: f32 = heidic_get_mesh_instance_rx(selected_mesh_instance_id);
                    let current_ry: f32 = heidic_get_mesh_instance_ry(selected_mesh_instance_id);
                    let current_rz: f32 = heidic_get_mesh_instance_rz(selected_mesh_instance_id);
                    
                    // Translation Inputs
                    heidic_imgui_text("Translation:");
                    heidic_imgui_text("X:");
                    heidic_imgui_same_line();
                    let new_x: f32 = heidic_imgui_input_float("##TransX", current_x, 1.0, 10.0);
                    heidic_imgui_text("Y:");
                    heidic_imgui_same_line();
                    let new_y: f32 = heidic_imgui_input_float("##TransY", current_y, 1.0, 10.0);
                    heidic_imgui_text("Z:");
                    heidic_imgui_same_line();
                    let new_z: f32 = heidic_imgui_input_float("##TransZ", current_z, 1.0, 10.0);
                    if new_x != current_x || new_y != current_y || new_z != current_z {
                        heidic_set_mesh_instance_pos(selected_mesh_instance_id, new_x, new_y, new_z);
                        // Update cached position values so gizmo updates immediately
                        selected_mesh_x = new_x;
                        selected_mesh_y = new_y;
                        selected_mesh_z = new_z;
                    }
                    
                    heidic_imgui_separator();
                    
                    // Scale Inputs
                    heidic_imgui_text("Scale:");
                    heidic_imgui_text("X:");
                    heidic_imgui_same_line();
                    let new_sx: f32 = heidic_imgui_input_float("##ScaleX", current_sx, 0.1, 1.0);
                    heidic_imgui_text("Y:");
                    heidic_imgui_same_line();
                    let new_sy: f32 = heidic_imgui_input_float("##ScaleY", current_sy, 0.1, 1.0);
                    heidic_imgui_text("Z:");
                    heidic_imgui_same_line();
                    let new_sz: f32 = heidic_imgui_input_float("##ScaleZ", current_sz, 0.1, 1.0);
                    // Clamp scale to positive values
                    if new_sx < 0.01 {
                        new_sx = 0.01;
                    }
                    if new_sy < 0.01 {
                        new_sy = 0.01;
                    }
                    if new_sz < 0.01 {
                        new_sz = 0.01;
                    }
                    if new_sx != current_sx || new_sy != current_sy || new_sz != current_sz {
                        heidic_set_mesh_instance_scale(selected_mesh_instance_id, new_sx, new_sy, new_sz);
                    }
                    
                    heidic_imgui_separator();
                    
                    // Rotation - Slider and Input (both work independently)
                    heidic_imgui_text("Rotation:");
                    // X Rotation - Slider and Input (both work independently)
                    let new_rx_slider: f32 = heidic_imgui_slider_float("Rotation X", current_rx, 0.0, 360.0);
                    let new_rx_input: f32 = heidic_imgui_input_float("##RX", current_rx, 1.0, 10.0);
                    // Use input value if it changed, otherwise use slider value
                    let new_rx: f32 = new_rx_slider;
                    if new_rx_input != current_rx {
                        new_rx = new_rx_input;
                    }
                    if new_rx != current_rx {
                        // Clamp to 0-360 range
                        if new_rx < 0.0 {
                            new_rx = 0.0;
                        }
                        if new_rx > 360.0 {
                            new_rx = 360.0;
                        }
                        heidic_set_mesh_instance_rotation(selected_mesh_instance_id, new_rx, current_ry, current_rz);
                    }
                    
                    // Y Rotation - Slider and Input (both work independently)
                    let new_ry_slider: f32 = heidic_imgui_slider_float("Rotation Y", current_ry, 0.0, 360.0);
                    let new_ry_input: f32 = heidic_imgui_input_float("##RY", current_ry, 1.0, 10.0);
                    // Use input value if it changed, otherwise use slider value
                    let new_ry: f32 = new_ry_slider;
                    if new_ry_input != current_ry {
                        new_ry = new_ry_input;
                    }
                    if new_ry != current_ry {
                        // Clamp to 0-360 range
                        if new_ry < 0.0 {
                            new_ry = 0.0;
                        }
                        if new_ry > 360.0 {
                            new_ry = 360.0;
                        }
                        heidic_set_mesh_instance_rotation(selected_mesh_instance_id, current_rx, new_ry, current_rz);
                    }
                    
                    // Z Rotation - Slider and Input (both work independently)
                    let new_rz_slider: f32 = heidic_imgui_slider_float("Rotation Z", current_rz, 0.0, 360.0);
                    let new_rz_input: f32 = heidic_imgui_input_float("##RZ", current_rz, 1.0, 10.0);
                    // Use input value if it changed, otherwise use slider value
                    let new_rz: f32 = new_rz_slider;
                    if new_rz_input != current_rz {
                        new_rz = new_rz_input;
                    }
                    if new_rz != current_rz {
                        // Clamp to 0-360 range
                        if new_rz < 0.0 {
                            new_rz = 0.0;
                        }
                        if new_rz > 360.0 {
                            new_rz = 360.0;
                        }
                        heidic_set_mesh_instance_rotation(selected_mesh_instance_id, current_rx, current_ry, new_rz);
                    }
                    
                    heidic_imgui_end();
                }
            }
            
            // Transform Control Window for Selected Cube
            if has_selection == 1 && selected_cube_index >= 2.0 {
                let cube_storage_index: i32 = heidic_float_to_int(selected_cube_index - 2.0);
                if heidic_get_cube_active(cube_storage_index) == 1 {
                    print("[HEIDIC DEBUG] About to begin Transform Control window (mesh)\n");
                if heidic_imgui_begin("Transform Control") == 1 {
                    print("[HEIDIC DEBUG] Inside Transform Control window (mesh)\n");
                        // Get current transform values
                        let current_x: f32 = heidic_get_cube_x(cube_storage_index);
                        let current_y: f32 = heidic_get_cube_y(cube_storage_index);
                        let current_z: f32 = heidic_get_cube_z(cube_storage_index);
                        let current_sx: f32 = heidic_get_cube_sx(cube_storage_index);
                        let current_sy: f32 = heidic_get_cube_sy(cube_storage_index);
                        let current_sz: f32 = heidic_get_cube_sz(cube_storage_index);
                        let current_rx: f32 = heidic_get_cube_rx(cube_storage_index);
                        let current_ry: f32 = heidic_get_cube_ry(cube_storage_index);
                        let current_rz: f32 = heidic_get_cube_rz(cube_storage_index);
                        
                        // Translation Inputs
                        heidic_imgui_text("Translation:");
                        heidic_imgui_text("X:");
                        heidic_imgui_same_line();
                        let new_x: f32 = heidic_imgui_input_float("##CubeTransX", current_x, 1.0, 10.0);
                        heidic_imgui_text("Y:");
                        heidic_imgui_same_line();
                        let new_y: f32 = heidic_imgui_input_float("##CubeTransY", current_y, 1.0, 10.0);
                        heidic_imgui_text("Z:");
                        heidic_imgui_same_line();
                        let new_z: f32 = heidic_imgui_input_float("##CubeTransZ", current_z, 1.0, 10.0);
                        if new_x != current_x || new_y != current_y || new_z != current_z {
                            heidic_set_cube_pos(cube_storage_index, new_x, new_y, new_z);
                        }
                        
                        heidic_imgui_separator();
                        
                        // Scale Inputs
                        heidic_imgui_text("Scale:");
                        heidic_imgui_text("X:");
                        heidic_imgui_same_line();
                        let new_sx: f32 = heidic_imgui_input_float("##CubeScaleX", current_sx, 0.1, 1.0);
                        heidic_imgui_text("Y:");
                        heidic_imgui_same_line();
                        let new_sy: f32 = heidic_imgui_input_float("##CubeScaleY", current_sy, 0.1, 1.0);
                        heidic_imgui_text("Z:");
                        heidic_imgui_same_line();
                        let new_sz: f32 = heidic_imgui_input_float("##CubeScaleZ", current_sz, 0.1, 1.0);
                        // Clamp scale to positive values
                        if new_sx < 0.01 {
                            new_sx = 0.01;
                        }
                        if new_sy < 0.01 {
                            new_sy = 0.01;
                        }
                        if new_sz < 0.01 {
                            new_sz = 0.01;
                        }
                        if new_sx != current_sx || new_sy != current_sy || new_sz != current_sz {
                            heidic_set_cube_scale(cube_storage_index, new_sx, new_sy, new_sz);
                        }
                        
                        heidic_imgui_separator();
                        
                        // Rotation - Slider and Input (both work independently)
                        heidic_imgui_text("Rotation:");
                        // X Rotation - Slider and Input (both work independently)
                        let new_rx_slider: f32 = heidic_imgui_slider_float("Rotation X", current_rx, 0.0, 360.0);
                        let new_rx_input: f32 = heidic_imgui_input_float("##CubeRX", current_rx, 1.0, 10.0);
                        // Use input value if it changed, otherwise use slider value
                        let new_rx: f32 = new_rx_slider;
                        if new_rx_input != current_rx {
                            new_rx = new_rx_input;
                        }
                        if new_rx != current_rx {
                            // Clamp to 0-360 range
                            if new_rx < 0.0 {
                                new_rx = 0.0;
                            }
                            if new_rx > 360.0 {
                                new_rx = 360.0;
                            }
                            heidic_set_cube_rotation(cube_storage_index, new_rx, current_ry, current_rz);
                        }
                        
                        // Y Rotation - Slider and Input (both work independently)
                        let new_ry_slider: f32 = heidic_imgui_slider_float("Rotation Y", current_ry, 0.0, 360.0);
                        let new_ry_input: f32 = heidic_imgui_input_float("##CubeRY", current_ry, 1.0, 10.0);
                        // Use input value if it changed, otherwise use slider value
                        let new_ry: f32 = new_ry_slider;
                        if new_ry_input != current_ry {
                            new_ry = new_ry_input;
                        }
                        if new_ry != current_ry {
                            // Clamp to 0-360 range
                            if new_ry < 0.0 {
                                new_ry = 0.0;
                            }
                            if new_ry > 360.0 {
                                new_ry = 360.0;
                            }
                            heidic_set_cube_rotation(cube_storage_index, current_rx, new_ry, current_rz);
                        }
                        
                        // Z Rotation - Slider and Input (both work independently)
                        let new_rz_slider: f32 = heidic_imgui_slider_float("Rotation Z", current_rz, 0.0, 360.0);
                        let new_rz_input: f32 = heidic_imgui_input_float("##CubeRZ", current_rz, 1.0, 10.0);
                        // Use input value if it changed, otherwise use slider value
                        let new_rz: f32 = new_rz_slider;
                        if new_rz_input != current_rz {
                            new_rz = new_rz_input;
                        }
                        if new_rz != current_rz {
                            // Clamp to 0-360 range
                            if new_rz < 0.0 {
                                new_rz = 0.0;
                            }
                            if new_rz > 360.0 {
                                new_rz = 360.0;
                            }
                            heidic_set_cube_rotation(cube_storage_index, current_rx, current_ry, new_rz);
                        }
                        
                        heidic_imgui_end();
                    }
                }
            }
            
            // Texture Swatches Window
            // print("[HEIDIC DEBUG] About to begin Texture Swatches window\n");  // Debug: uncomment when needed
            if heidic_imgui_begin("Texture Swatches") == 1 {
                // print("[HEIDIC DEBUG] Inside Texture Swatches window\n");  // Debug: uncomment when needed
                // Load texture list on first frame
                heidic_load_texture_list();
                // print("[HEIDIC DEBUG] After heidic_load_texture_list()\n");  // Debug: uncomment when needed
                
                let texture_count: i32 = heidic_get_texture_count();
                // print("[HEIDIC DEBUG] Got texture_count, starting loop\n");  // Debug: uncomment when needed
                
                // Display textures in a grid as image previews
                let texture_index: i32 = 0;
                let items_per_row: i32 = 6;  // 6 textures per row
                let current_col: i32 = 0;
                let swatch_size: f32 = 64.0;  // 64x64 pixel previews
                
                // print("[HEIDIC DEBUG] Starting texture loop\n");  // Debug: uncomment when needed
                while texture_index < texture_count {
                    // if texture_index == 0 {
                    //     print("[HEIDIC DEBUG] First texture iteration\n");  // Debug: uncomment when needed
                    // }
                    // if texture_index == 10 {
                    //     print("[HEIDIC DEBUG] 10th texture iteration\n");  // Debug: uncomment when needed
                    // }
                    // if texture_index == 20 {
                    //     print("[HEIDIC DEBUG] 20th texture iteration\n");  // Debug: uncomment when needed
                    // }
                    
                    let texture_name: string = heidic_get_texture_name(texture_index);
                    // print("[HEIDIC DEBUG] Got texture_name, about to get preview ID\n");  // Debug: uncomment when needed
                    
                    // Load texture preview and get ID
                    let texture_id: i64 = heidic_get_texture_preview_id(texture_name);
                    // print("[HEIDIC DEBUG] Got texture_id\n");  // Debug: uncomment when needed
                    
                    // Create unique ID for button
                    heidic_imgui_push_id(texture_index);
                    
                    // Check if this texture is selected (get fresh value each iteration)
                    let selected_texture: string = heidic_get_selected_texture();
                    let is_selected: i32 = 0;
                    if selected_texture == texture_name {
                        is_selected = 1;
                    }
                    
                    // Display as image button
                    if texture_id != 0 {
                        // Use tint color to indicate selection (yellow tint if selected)
                        let tint_r: f32 = 1.0;
                        let tint_g: f32 = 1.0;
                        let tint_b: f32 = 1.0;
                        let tint_a: f32 = 1.0;
                        if is_selected == 1 {
                            tint_r = 1.0;
                            tint_g = 1.0;
                            tint_b = 0.5;  // Yellow tint for selected
                        }
                        
                        // Create unique button ID using texture index
                        // Use texture_name as part of ID to ensure uniqueness
                        let button_id: string = texture_name;
                        // Use ImageButton with tint
                        if heidic_imgui_image_button(button_id, texture_id, swatch_size, swatch_size, tint_r, tint_g, tint_b, tint_a) == 1 {
                            // Clicked: select this texture
                            heidic_set_selected_texture(texture_name);
                        }
                    } else {
                        // Fallback to text if texture failed to load
                        heidic_imgui_text_str_wrapper(texture_name);
                    }
                    
                    heidic_imgui_pop_id();
                    
                    // Same line for grid layout
                    current_col = current_col + 1;
                    if current_col < items_per_row {
                        heidic_imgui_same_line();
                    } else {
                        current_col = 0;
                    }
                    
                    texture_index = texture_index + 1;
                }
                
                heidic_imgui_end();
            }
        }
        // print("[HEIDIC DEBUG] After all ImGui windows\n");  // Debug: uncomment when needed
        
        // Player cube is not selectable, so no position syncing needed
        // print("[HEIDIC DEBUG] Before ground detection section\n");  // Debug: uncomment when needed
        
        // Ground detection for player
        let ground_check_distance: f32 = 200.0; // 2 meters down
        // print("[HEIDIC DEBUG] Before ground detection\n");  // Debug: uncomment when needed
        is_grounded = heidic_raycast_ground_hit(player_pos.x, player_pos.y, player_pos.z, ground_check_distance);
        // print("[HEIDIC DEBUG] After ground detection\n");  // Debug: uncomment when needed
        
        // Visual feedback: Draw ray from player to ground
        if is_grounded == 1 {
            let ground_hit: Vec3 = heidic_raycast_ground_hit_point(player_pos.x, player_pos.y, player_pos.z, ground_check_distance);
            // Draw green line from player to ground (grounded)
            heidic_draw_line(player_pos.x, player_pos.y, player_pos.z, ground_hit.x, ground_hit.y, ground_hit.z, 0.0, 1.0, 0.0);
        } else {
            // Draw red line straight down (not grounded)
            let ground_check_end: Vec3 = heidic_vec3(player_pos.x, player_pos.y - ground_check_distance, player_pos.z);
            heidic_draw_line(player_pos.x, player_pos.y, player_pos.z, ground_check_end.x, ground_check_end.y, ground_check_end.z, 1.0, 0.0, 0.0);
        }
        // print("[HEIDIC DEBUG] After drawing ground lines\n");  // Debug: uncomment when needed
        
        // Debug Panel and Outliner removed - will be reimplemented from scratch
        
        // print("[HEIDIC DEBUG] Before calling heidic_end_frame()\n");  // Debug: uncomment when needed
        heidic_end_frame();
        // print("[HEIDIC DEBUG] After calling heidic_end_frame()\n");  // Debug: uncomment when needed
        
        // Save ImGui layout each frame (will save on last frame before window closes)
        // Note: Function accepts empty string for default path
        heidic_imgui_save_layout(default_ini_path_load);
    }
}

