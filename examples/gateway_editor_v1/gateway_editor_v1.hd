// EDEN ENGINE - Gateway Editor v1
// Features: ImGui, Programmatic Cube, FPS Camera, Frame Control

// Include EDEN Engine standard library
include "stdlib/eden.hd";

fn main(): void {
    // Visibility constants
    let VISIBLE: i32 = 1;
    let INVISIBLE: i32 = 0;
    print("Initializing GLFW...\n");
    if heidic_glfw_init() == 0 {
        return;
    }
    
    heidic_glfw_vulkan_hints();
    let window: GLFWwindow = heidic_create_window(1280, 720, "EDEN ENGINE - Gateway Editor v1");
    
    if heidic_init_renderer(window) == 0 {
        heidic_glfw_terminate();
        return;
    }
    
    // Load ImGui layout on startup
    heidic_imgui_load_layout("");
    
    // Start in windowed mode (1 = windowed)
    // Video mode: 0 = fullscreen, 1 = windowed
    
    // Player (Cube) Transform - using Vec3 for position and rotation
    // Spawn player away from the reference cubes (3000 units = 30 meters away)
    let player_pos: Vec3 = heidic_vec3(3000.0, 100.0, 3000.0); // 30m away, 1m above ground
    let player_rot: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
    
    // Camera Transform - will follow player with offset
    // Initial position will be set in loop with offset
    let camera_pos: Vec3 = heidic_vec3(0.0, 100.0, 0.0); // Will be updated in loop
    let camera_rot: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
    
    // Legacy variables for drawing (will be updated from Vec3)
    let cube_x: f32 = 0.0;
    let cube_y: f32 = 0.0;
    let cube_z: f32 = 0.0;
    let cube_rx: f32 = 0.0;
    let cube_ry: f32 = 0.0;
    let cube_rz: f32 = 0.0;
    
    // Cube Size (100 cm = 1 meter)
    let cube_sx: f32 = 100.0;
    let cube_sy: f32 = 100.0;
    let cube_sz: f32 = 100.0;
    
    // Movement Speed (cm per frame)
    let move_speed: f32 = 15.0; // Increased from 5.0 for faster movement
    
    // Rotation Speed (degrees per frame) - for Q/E keys (optional, mouse look is primary)
    let rot_speed: f32 = 2.0;
    
    // Mouse Look Sensitivity (degrees per pixel)
    let mouse_sensitivity: f32 = 0.1;
    
    // Pitch clamp limits (for camera rotation)
    let pitch_max: f32 = 90.0;
    let pitch_min: f32 = -90.0;
    
    // Debug UI State
    let show_debug: i32 = 1;
    let f1_was_pressed: i32 = 0;
    
    // Camera Mode: 0 = Top-Down, 1 = FPS
    let camera_mode: i32 = 1; // Start in Walk mode (FPS)
    let tab_was_pressed: i32 = 0;  // Tab key for camera toggle
    
    // Player cube visibility: INVISIBLE in walk mode, VISIBLE in top-down mode
    let player_cube_visible: i32 = VISIBLE;
    
    // Mouse mode: 0 = disabled (cursor captured, mouse look/dolly enabled), 1 = enabled (cursor visible, picking enabled)
    let mouse_mode: i32 = 1; // Start with mouse enabled (visible cursor) for top-down mode
    let mouse_mode_left_was_pressed: i32 = 0;
    let mouse_mode_right_was_pressed: i32 = 0;
    
    // Set cursor mode based on initial mouse mode
    heidic_set_cursor_mode(window, 0); // 0 = normal (visible) for top-down mode
    
    // Grid visibility toggle
    let show_grid: i32 = 1; // Start with grid visible
    let g_was_pressed: i32 = 0;
    
    // Video Mode: 0 = fullscreen, 1 = windowed
    let video_mode: i32 = 1; // Start in windowed mode
    let shift_enter_was_pressed: i32 = 0;
    
    // Selection state
    let selected_cube_x: f32 = 0.0;
    let selected_cube_y: f32 = 0.0;
    let selected_cube_z: f32 = 0.0;
    let selected_cube_sx: f32 = 0.0;
    let selected_cube_sy: f32 = 0.0;
    let selected_cube_sz: f32 = 0.0;
    let has_selection: i32 = 0; // 0 = no selection, 1 = has selection
    let selected_cube_index: f32 = -1.0; // -1.0 = none, 0.0 = player, >= 2.0 = created cubes, >= 10000.0 = mesh instances
    
    // Mesh selection state
    let selected_mesh_instance_id: i32 = -1; // -1 = none, >= 0 = mesh instance ID
    let selected_mesh_x: f32 = 0.0;
    let selected_mesh_y: f32 = 0.0;
    let selected_mesh_z: f32 = 0.0;
    let has_mesh_selection: i32 = 0; // 0 = no mesh selection, 1 = has mesh selection
    
    // Ground detection
    let is_grounded: i32 = 0;
    
    // Mouse button state tracking
    let mouse_left_was_pressed: i32 = 0;
    let mouse_middle_was_pressed: i32 = 0;
    
    // Delete key state tracking
    let delete_was_pressed: i32 = 0;
    
    // C key state tracking (for combining cubes - separate from camera toggle C key)
    let combine_c_was_pressed: i32 = 0;
    
    // Level name buffer for input (managed by C++ side)
    // We'll use heidic_get_level_name() to get the current name
    
    // Top-down camera position (high up, looking down)
    let topdown_cam_height: f32 = 10000.0; // 100 meters up (zoom level)
    let topdown_cam_pan_x: f32 = 0.0; // Pan offset X
    let topdown_cam_pan_z: f32 = 0.0; // Pan offset Z
    let topdown_cam_pos: Vec3 = heidic_vec3(0.0, topdown_cam_height, 0.0); // 100 meters up
    let topdown_cam_rot: Vec3 = heidic_vec3(-90.0, 0.0, 0.0); // Looking straight down
    
    // Dolly orbit state (for orbiting around selected object)
    let dolly_orbit_azimuth: f32 = 0.0; // Horizontal angle around target
    let dolly_orbit_elevation: f32 = 45.0; // Vertical angle (0 = horizontal, 90 = straight up)
    let dolly_orbit_distance: f32 = 2000.0; // Distance from target (reduced from 5000 to 20 meters)
    let in_orbit_mode: i32 = 0; // Flag to prevent pan from overwriting orbit position
    let alt_was_pressed: i32 = 0; // Track Alt key state to detect when dolly starts
    
    // Reference Cube 1 removed - all cubes are now created dynamically
    
    // Spacebar state
    let space_was_pressed: i32 = 0;
    
    // Created cube size (2 meters = 200 units)
    let created_cube_size: f32 = 200.0;
    
    print("Starting loop...\n");
    
    while heidic_window_should_close(window) == 0 {
        heidic_poll_events();
        
        // Check if we're editing a combination name - if so, block all input except Enter/Escape
        let is_editing_combination: i32 = heidic_get_editing_combination_id();
        let block_input: i32 = 0;
        if is_editing_combination >= 0 {
            block_input = 1;
        }
        
        // Get mouse position and ray (always available for debug panel)
        let mouse_x: f32 = heidic_get_mouse_x(window);
        let mouse_y: f32 = heidic_get_mouse_y(window);
        
        // Get mouse ray
        let ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
        let ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
        
        // ESC always works (to close window)
        if heidic_is_key_pressed(window, 256) == 1 { // ESC
            // If editing, stop editing instead of closing window
            if is_editing_combination >= 0 {
                heidic_stop_editing_combination_name();
            } else {
                heidic_set_window_should_close(window, 1);
            }
        }
        
        // Skip all other input if we're editing
        if block_input == 0 {
        
        // F1 Toggle Logic (290 is F1)
        let f1_is_pressed: i32 = heidic_is_key_pressed(window, 290);
        if f1_is_pressed == 1 {
            if f1_was_pressed == 0 {
                if show_debug == 1 {
                    show_debug = 0;
                } else {
                    show_debug = 1;
                }
                f1_was_pressed = 1;
            }
        } else {
            f1_was_pressed = 0;
        }
        
        // Tab Key Toggle Logic (258 is Tab) - Switch between Top-Down and FPS camera
        let tab_is_pressed: i32 = heidic_is_key_pressed(window, 258);
        if tab_is_pressed == 1 {
            if tab_was_pressed == 0 {
                if camera_mode == 0 {
                    camera_mode = 1; // Switch to FPS
                    // Set cursor mode based on mouse_mode
                    if mouse_mode == 0 {
                        heidic_set_cursor_mode(window, 2); // 2 = disabled (captured)
                    } else {
                        heidic_set_cursor_mode(window, 0); // 0 = normal (visible)
                    }
                } else {
                    camera_mode = 0; // Switch to Top-Down
                    // Set cursor mode based on mouse_mode
                    if mouse_mode == 0 {
                        heidic_set_cursor_mode(window, 1); // 1 = hidden
                    } else {
                        heidic_set_cursor_mode(window, 0); // 0 = normal (visible)
                    }
                }
                tab_was_pressed = 1;
            }
        } else {
            tab_was_pressed = 0;
        }
        
        // Alt + Mouse Drag for Camera Dolly (works in both modes)
        // Left Alt = 342, Right Alt = 346
        let left_alt_pressed: i32 = heidic_is_key_pressed(window, 342);
        let right_alt_pressed: i32 = heidic_is_key_pressed(window, 346);
        let alt_pressed: i32 = 0;
        if left_alt_pressed == 1 {
            alt_pressed = 1;
        }
        if right_alt_pressed == 1 {
            alt_pressed = 1;
        }
        
        // Only allow dolly/look when mouse_mode is disabled
        if alt_pressed == 1 && mouse_mode == 0 {
            // Dolly orbit around selected object (if there's a selection)
            if has_selection == 1 {
                // Initialize orbit angles from current camera position when Alt is first pressed
                if alt_was_pressed == 0 {
                    // Calculate current camera position relative to target
                    let target_pos: Vec3 = heidic_vec3(selected_cube_x, selected_cube_y, selected_cube_z);
                    let current_cam_pos: Vec3 = camera_pos;
                    let to_camera: Vec3 = heidic_vec3_sub(current_cam_pos, target_pos);
                    let dist: f32 = heidic_vec3_distance(current_cam_pos, target_pos);
                    
                    if dist > 0.001 {
                        // Normalize direction vector
                        let dir_x: f32 = to_camera.x / dist;
                        let dir_y: f32 = to_camera.y / dist;
                        let dir_z: f32 = to_camera.z / dist;
                        
                        // Calculate azimuth from XZ components (horizontal angle)
                        let azimuth_rad: f32 = heidic_atan2(dir_x, dir_z);
                        dolly_orbit_azimuth = heidic_convert_radians_to_degrees(azimuth_rad);
                        
                        // Calculate elevation from Y component (vertical angle)
                        let elevation_rad: f32 = heidic_asin(dir_y);
                        dolly_orbit_elevation = heidic_convert_radians_to_degrees(elevation_rad);
                        
                        // Update distance to match current camera distance
                        if dist > 10.0 && dist < 100000.0 {
                            dolly_orbit_distance = dist;
                        }
                    }
                }
                
                // Get mouse delta for orbit movement
                let dolly_delta_x: f32 = heidic_get_mouse_delta_x(window);
                let dolly_delta_y: f32 = heidic_get_mouse_delta_y(window);
                
                // Orbit sensitivity (degrees per pixel) - LearnOpenGL style
                let orbit_sensitivity: f32 = 0.3; // Reduced for smoother feel
                
                // Update orbit angles (Track/Orbit)
                dolly_orbit_azimuth = dolly_orbit_azimuth - dolly_delta_x * orbit_sensitivity; // Horizontal rotation (yaw)
                dolly_orbit_elevation = dolly_orbit_elevation + dolly_delta_y * orbit_sensitivity; // Vertical rotation (pitch)
                
                // Clamp elevation to prevent gimbal lock (LearnOpenGL standard)
                if dolly_orbit_elevation > 89.0 {
                    dolly_orbit_elevation = 89.0;
                }
                if dolly_orbit_elevation < -89.0 {
                    dolly_orbit_elevation = -89.0;
                }
                
                // Target position (selected object)
                let target_pos: Vec3 = heidic_vec3(selected_cube_x, selected_cube_y, selected_cube_z);
                
                // Calculate camera position using spherical coordinates (Y-up system)
                // Standard spherical coordinates for orbit camera:
                // - Azimuth: rotation around Y axis (horizontal)
                // - Elevation: angle from horizontal plane (vertical, -90 to +90)
                let azimuth_rad: f32 = heidic_convert_degrees_to_radians(dolly_orbit_azimuth);
                let elevation_rad: f32 = heidic_convert_degrees_to_radians(dolly_orbit_elevation);
                
                // Spherical to Cartesian conversion (Y-up, right-handed)
                // When elevation = 0: camera is at same Y as target (horizontal)
                // When elevation = 90: camera is directly above target
                // When elevation = -90: camera is directly below target
                // X = distance * cos(elevation) * sin(azimuth)
                // Y = distance * sin(elevation)  [This allows negative Y when elevation < 0]
                // Z = distance * cos(elevation) * cos(azimuth)
                let cos_elev: f32 = heidic_cos(elevation_rad);
                let sin_elev: f32 = heidic_sin(elevation_rad);
                let cos_azim: f32 = heidic_cos(azimuth_rad);
                let sin_azim: f32 = heidic_sin(azimuth_rad);
                
                let offset_x: f32 = dolly_orbit_distance * cos_elev * sin_azim;
                let offset_y: f32 = dolly_orbit_distance * sin_elev;  // Can be negative!
                let offset_z: f32 = dolly_orbit_distance * cos_elev * cos_azim;
                
                let offset: Vec3 = heidic_vec3(offset_x, offset_y, offset_z);
                let new_cam_pos: Vec3 = heidic_vec3_add(target_pos, offset);
                
                // NO Y RESTRICTIONS - camera can go anywhere in 3D space
                
                // Track that we're in orbit mode (prevent pan update from overwriting)
                in_orbit_mode = 1;
                
                if camera_mode == 0 {
                    // Top-Down Mode: Update camera position and look at target
                    topdown_cam_pos = new_cam_pos;
                    camera_pos = new_cam_pos;
                    
                    // Calculate direction vector from camera to target
                    let to_target: Vec3 = heidic_vec3_sub(target_pos, new_cam_pos);
                    let dist_to_target: f32 = heidic_vec3_distance(new_cam_pos, target_pos);
                    
                    // Calculate yaw and pitch from direction vector to ensure camera always faces target
                    if dist_to_target > 0.001 {
                        // Normalize direction (we'll calculate components manually)
                        let dir_x: f32 = to_target.x / dist_to_target;
                        let dir_y: f32 = to_target.y / dist_to_target;
                        let dir_z: f32 = to_target.z / dist_to_target;
                        
                        // Yaw: rotation around Y axis (horizontal)
                        // atan2(x, z) gives angle in XZ plane (0° = +Z, 90° = +X)
                        let yaw_rad: f32 = heidic_atan2(dir_x, dir_z);
                        let yaw_deg: f32 = heidic_convert_radians_to_degrees(yaw_rad);
                        
                        // Pitch: rotation around X axis (vertical)
                        // asin(y) gives elevation angle (-90° to +90°)
                        let pitch_rad: f32 = heidic_asin(dir_y);
                        let pitch_deg: f32 = heidic_convert_radians_to_degrees(pitch_rad);
                        
                        topdown_cam_rot.x = pitch_deg;   // Pitch (vertical)
                        topdown_cam_rot.y = yaw_deg;     // Yaw (horizontal)
                        topdown_cam_rot.z = 0.0;         // Roll (no roll)
                    } else {
                        // Too close, use fallback angles
                        topdown_cam_rot.x = -dolly_orbit_elevation;
                        topdown_cam_rot.y = dolly_orbit_azimuth + 180.0;
                        topdown_cam_rot.z = 0.0;
                    }
                    camera_rot = topdown_cam_rot;
                } else {
                    // FPS Mode: Update player position to orbit around target
                    player_pos = new_cam_pos;
                    
                    // Calculate direction vector from camera to target
                    let to_target: Vec3 = heidic_vec3_sub(target_pos, new_cam_pos);
                    let dist_to_target: f32 = heidic_vec3_distance(new_cam_pos, target_pos);
                    
                    // Calculate yaw and pitch from direction vector
                    if dist_to_target > 0.001 {
                        let dir_x: f32 = to_target.x / dist_to_target;
                        let dir_y: f32 = to_target.y / dist_to_target;
                        let dir_z: f32 = to_target.z / dist_to_target;
                        
                        let yaw_rad: f32 = heidic_atan2(dir_x, dir_z);
                        let yaw_deg: f32 = heidic_convert_radians_to_degrees(yaw_rad);
                        
                        let pitch_rad: f32 = heidic_asin(dir_y);
                        let pitch_deg: f32 = heidic_convert_radians_to_degrees(pitch_rad);
                        
                        player_rot.y = yaw_deg;   // Yaw (horizontal)
                        player_rot.x = pitch_deg;  // Pitch (vertical)
                    } else {
                        // Fallback
                        player_rot.y = dolly_orbit_azimuth + 180.0;
                        player_rot.x = -dolly_orbit_elevation;
                    }
                }
            } else {
                // No selection: use general dolly (same logic as walk mode)
                let dolly_delta_x: f32 = heidic_get_mouse_delta_x(window);
                let dolly_delta_y: f32 = heidic_get_mouse_delta_y(window);
                let dolly_speed: f32 = 20.0;
                
                if camera_mode == 0 {
                    // Top-down editor camera: use same dolly logic as walk mode
                    // Calculate forward/right vectors from camera yaw rotation
                    let yaw_rad: f32 = heidic_convert_degrees_to_radians(topdown_cam_rot.y);
                    let forward_x: f32 = heidic_sin(yaw_rad);
                    let forward_z: f32 = heidic_cos(yaw_rad);
                    let right_x: f32 = heidic_cos(yaw_rad);
                    let right_z: f32 = -heidic_sin(yaw_rad);
                    let move_x: f32 = right_x * dolly_delta_x * dolly_speed + forward_x * dolly_delta_y * dolly_speed;
                    let move_z: f32 = right_z * dolly_delta_x * dolly_speed + forward_z * dolly_delta_y * dolly_speed;
                    // Move camera position (pan offset) based on calculated movement
                    topdown_cam_pan_x = topdown_cam_pan_x + move_x;
                    topdown_cam_pan_z = topdown_cam_pan_z + move_z;
                } else {
                    // Walk mode: keep existing perfect dolly logic (DO NOT CHANGE)
                    let yaw_rad: f32 = heidic_convert_degrees_to_radians(player_rot.y);
                    let forward_x: f32 = heidic_sin(yaw_rad);
                    let forward_z: f32 = heidic_cos(yaw_rad);
                    let right_x: f32 = heidic_cos(yaw_rad);
                    let right_z: f32 = -heidic_sin(yaw_rad);
                    let move_x: f32 = right_x * dolly_delta_x * dolly_speed + forward_x * dolly_delta_y * dolly_speed;
                    let move_z: f32 = right_z * dolly_delta_x * dolly_speed + forward_z * dolly_delta_y * dolly_speed;
                    player_pos.x = player_pos.x + move_x;
                    player_pos.z = player_pos.z + move_z;
                }
            }
            alt_was_pressed = 1; // Mark Alt as pressed
        } else {
            alt_was_pressed = 0; // Reset when Alt is released
        }
        
        // Mouse Look (only in FPS mode, only when mouse_mode is disabled, and only when Alt is NOT pressed)
        if camera_mode == 1 && mouse_mode == 0 && alt_pressed == 0 {
            // Get mouse delta
            let mouse_delta_x: f32 = heidic_get_mouse_delta_x(window);
            let mouse_delta_y: f32 = heidic_get_mouse_delta_y(window);
            
            // Update yaw (horizontal rotation) - rotate around Y axis
            // Reversed: mouse right = turn right (natural FPS feel)
            player_rot.y = player_rot.y - mouse_delta_x * mouse_sensitivity;
            
            // Update pitch (vertical rotation) - rotate around X axis
            // Clamp pitch to prevent flipping (typically -90 to +90 degrees)
            player_rot.x = player_rot.x - mouse_delta_y * mouse_sensitivity;
            
            // Clamp pitch to prevent camera flipping
            if player_rot.x > pitch_max {
                player_rot.x = pitch_max;
            }
            // Clamp minimum pitch (check if pitch_min is greater than current - inverted logic)
            let pitch_check: f32 = pitch_min - player_rot.x;
            if pitch_check > 0.0 {
                player_rot.x = pitch_min;
            }
        }
        
        // G Key Toggle Logic (71 is G) - Toggle ground plane grid visibility
        let g_is_pressed: i32 = heidic_is_key_pressed(window, 71);
        if g_is_pressed == 1 {
            if g_was_pressed == 0 {
                if show_grid == 1 {
                    show_grid = 0; // Hide grid
                } else {
                    show_grid = 1; // Show grid
                }
                g_was_pressed = 1;
            }
        } else {
            g_was_pressed = 0;
        }
        
        // Spacebar (32) - Create new cube at mouse ray hit point
        // Works in any mode - always uses mouse ray to find placement position
        // Also try key code 57 as fallback (some systems use different codes)
        let space_is_pressed: i32 = heidic_is_key_pressed(window, 32);
        // Fallback: try key code 57 if 32 doesn't work
        if space_is_pressed == 0 {
            space_is_pressed = heidic_is_key_pressed(window, 57);
        }
        
        if space_is_pressed == 1 {
            if space_was_pressed == 0 {
                print("SPACEBAR PRESSED! Creating cube at ray hit point\n");
                
                // Default cube size (1 meter = 100 units)
                let default_cube_size: f32 = 100.0;
                
                // Always use mouse ray to find where to place the cube
                let create_ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
                let create_ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
                
                // First, check if ray hits any existing cubes (find closest hit)
                let create_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
                let found_hit: i32 = 0;
                let closest_dist: f32 = 100000000000.0; // Very large distance
                let hit_cube_x: f32 = 0.0;
                let hit_cube_y: f32 = 0.0;
                let hit_cube_z: f32 = 0.0;
                let hit_cube_sx: f32 = 0.0;
                let hit_cube_sy: f32 = 0.0;
                let hit_cube_sz: f32 = 0.0;
                let hit_point: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
                let is_ground_plane: i32 = 0;
                
                // FIRST: Test the big grey ground plane cube (100m x 100m x 1m at y = -500)
                // This is important geometry and needs to be pickable!
                let ground_cube_x: f32 = 0.0;
                let ground_cube_y: f32 = -500.0;
                let ground_cube_z: f32 = 0.0;
                let ground_cube_sx: f32 = 10000.0; // 100 meters
                let ground_cube_sy: f32 = 100.0;   // 1 meter thick
                let ground_cube_sz: f32 = 10000.0; // 100 meters
                
                let ground_cube_hit: i32 = heidic_raycast_cube_hit(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                if ground_cube_hit == 1 {
                    let ground_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
                    let ground_cube_dist: f32 = (ground_cube_hit_point.x - create_ray_origin.x) * (ground_cube_hit_point.x - create_ray_origin.x) + (ground_cube_hit_point.y - create_ray_origin.y) * (ground_cube_hit_point.y - create_ray_origin.y) + (ground_cube_hit_point.z - create_ray_origin.z) * (ground_cube_hit_point.z - create_ray_origin.z);
                    if ground_cube_dist < closest_dist {
                        closest_dist = ground_cube_dist;
                        create_pos = ground_cube_hit_point;
                        hit_point = ground_cube_hit_point;
                        hit_cube_x = ground_cube_x;
                        hit_cube_y = ground_cube_y;
                        hit_cube_z = ground_cube_z;
                        hit_cube_sx = ground_cube_sx;
                        hit_cube_sy = ground_cube_sy;
                        hit_cube_sz = ground_cube_sz;
                        is_ground_plane = 1;
                        found_hit = 1;
                    }
                }
                
                // Test all created cubes to find closest hit
                let cube_test_index: i32 = 0;
                let total_cubes_test: i32 = heidic_get_cube_total_count();
                while cube_test_index < total_cubes_test {
                    if heidic_get_cube_active(cube_test_index) == 1 {
                        let test_cube_x: f32 = heidic_get_cube_x(cube_test_index);
                        let test_cube_y: f32 = heidic_get_cube_y(cube_test_index);
                        let test_cube_z: f32 = heidic_get_cube_z(cube_test_index);
                        let test_cube_sx: f32 = heidic_get_cube_sx(cube_test_index);
                        let test_cube_sy: f32 = heidic_get_cube_sy(cube_test_index);
                        let test_cube_sz: f32 = heidic_get_cube_sz(cube_test_index);
                        
                        let cube_hit: i32 = heidic_raycast_cube_hit(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                        if cube_hit == 1 {
                            let test_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                            let dist: f32 = (test_hit_point.x - create_ray_origin.x) * (test_hit_point.x - create_ray_origin.x) + (test_hit_point.y - create_ray_origin.y) * (test_hit_point.y - create_ray_origin.y) + (test_hit_point.z - create_ray_origin.z) * (test_hit_point.z - create_ray_origin.z);
                            if dist < closest_dist {
                                closest_dist = dist;
                                create_pos = test_hit_point;
                                // Store the hit cube's position, size, and hit point for face detection
                                hit_point = test_hit_point;
                                hit_cube_x = test_cube_x;
                                hit_cube_y = test_cube_y;
                                hit_cube_z = test_cube_z;
                                hit_cube_sx = test_cube_sx;
                                hit_cube_sy = test_cube_sy;
                                hit_cube_sz = test_cube_sz;
                                is_ground_plane = 0;
                                found_hit = 1;
                            }
                        }
                    }
                    cube_test_index = cube_test_index + 1;
                }
                
                if found_hit == 1 {
                    // Ray hit a cube or ground plane - determine which face was hit and stack accordingly
                    if is_ground_plane == 1 {
                        // Ground plane: always stack on top
                        let hit_top_y: f32 = hit_cube_y + hit_cube_sy / 2.0;
                        create_pos.y = hit_top_y + default_cube_size / 2.0;
                        create_pos.x = hit_point.x;
                        create_pos.z = hit_point.z;
                        print("Hit ground plane! Stacking on top\n");
                    } else {
                        // Regular cube: determine which face was hit
                        // Calculate cube bounds
                        let cube_min_x: f32 = hit_cube_x - hit_cube_sx / 2.0;
                        let cube_max_x: f32 = hit_cube_x + hit_cube_sx / 2.0;
                        let cube_min_y: f32 = hit_cube_y - hit_cube_sy / 2.0;
                        let cube_max_y: f32 = hit_cube_y + hit_cube_sy / 2.0;
                        let cube_min_z: f32 = hit_cube_z - hit_cube_sz / 2.0;
                        let cube_max_z: f32 = hit_cube_z + hit_cube_sz / 2.0;
                        
                        // Calculate distances from hit point to each face
                        let dist_to_left: f32 = hit_point.x - cube_min_x;
                        let dist_to_right: f32 = cube_max_x - hit_point.x;
                        let dist_to_bottom: f32 = hit_point.y - cube_min_y;
                        let dist_to_top: f32 = cube_max_y - hit_point.y;
                        let dist_to_back: f32 = hit_point.z - cube_min_z;
                        let dist_to_front: f32 = cube_max_z - hit_point.z;
                        
                        // Find the closest face (smallest distance)
                        let min_dist: f32 = dist_to_left;
                        let hit_face: i32 = 0; // 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
                        
                        if dist_to_right < min_dist {
                            min_dist = dist_to_right;
                            hit_face = 1;
                        }
                        if dist_to_bottom < min_dist {
                            min_dist = dist_to_bottom;
                            hit_face = 2;
                        }
                        if dist_to_top < min_dist {
                            min_dist = dist_to_top;
                            hit_face = 3;
                        }
                        if dist_to_back < min_dist {
                            min_dist = dist_to_back;
                            hit_face = 4;
                        }
                        if dist_to_front < min_dist {
                            min_dist = dist_to_front;
                            hit_face = 5;
                        }
                        
                        // Place new cube adjacent to the hit face
                        if hit_face == 0 {
                            // Left face (negative X) - stack to the left
                            create_pos.x = cube_min_x - default_cube_size / 2.0;
                            create_pos.y = hit_cube_y;
                            create_pos.z = hit_cube_z;
                            print("Hit left face! Stacking to the left\n");
                        } else {
                            if hit_face == 1 {
                                // Right face (positive X) - stack to the right
                                create_pos.x = cube_max_x + default_cube_size / 2.0;
                                create_pos.y = hit_cube_y;
                                create_pos.z = hit_cube_z;
                                print("Hit right face! Stacking to the right\n");
                            } else {
                                if hit_face == 2 {
                                    // Bottom face (negative Y) - stack below
                                    create_pos.x = hit_cube_x;
                                    create_pos.y = cube_min_y - default_cube_size / 2.0;
                                    create_pos.z = hit_cube_z;
                                    print("Hit bottom face! Stacking below\n");
                                } else {
                                    if hit_face == 3 {
                                        // Top face (positive Y) - stack on top
                                        create_pos.x = hit_cube_x;
                                        create_pos.y = cube_max_y + default_cube_size / 2.0;
                                        create_pos.z = hit_cube_z;
                                        print("Hit top face! Stacking on top\n");
                                    } else {
                                        if hit_face == 4 {
                                            // Back face (negative Z) - stack to the back
                                            create_pos.x = hit_cube_x;
                                            create_pos.y = hit_cube_y;
                                            create_pos.z = cube_min_z - default_cube_size / 2.0;
                                            print("Hit back face! Stacking to the back\n");
                                        } else {
                                            // Front face (positive Z) - stack to the front
                                            create_pos.x = hit_cube_x;
                                            create_pos.y = hit_cube_y;
                                            create_pos.z = cube_max_z + default_cube_size / 2.0;
                                            print("Hit front face! Stacking to the front\n");
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // No hit - place cube 5 meters (500 units) along the ray
                    create_pos = heidic_vec3_add(create_ray_origin, heidic_vec3_mul_scalar(create_ray_dir, 500.0));
                    print("No hit, placing cube along ray\n");
                }
                
                // Generate random color for the new cube
                // Use white color (1,1,1) so texture displays at full brightness
                let cube_r: f32 = 1.0;
                let cube_g: f32 = 1.0;
                let cube_b: f32 = 1.0;
                
                // Create cube using dynamic storage system with white color (full texture brightness)
                let cube_index: i32 = heidic_create_cube_with_color(create_pos.x, create_pos.y, create_pos.z, default_cube_size, default_cube_size, default_cube_size, cube_r, cube_g, cube_b);
                
                if cube_index >= 0 {
                    print("Created cube at index: ");
                    print(cube_index);
                    print("\n");
                    
                    // Select the newly created cube
                    has_selection = 1;
                    // Convert index to float and add 2.0 offset
                    selected_cube_index = heidic_int_to_float(cube_index) + 2.0;
                    // Update selected cube properties for gizmo
                    selected_cube_x = create_pos.x;
                    selected_cube_y = create_pos.y;
                    selected_cube_z = create_pos.z;
                    selected_cube_sx = default_cube_size;
                    selected_cube_sy = default_cube_size;
                    selected_cube_sz = default_cube_size;
                } else {
                    print("Failed to create cube\n");
                }
                
                space_was_pressed = 1;
            }
            } else {
                space_was_pressed = 0;
            }
            
            // Ctrl+M (77 is 'M') - Combine selected cubes into mesh and save as .hdm
            let m_is_pressed: i32 = heidic_is_key_pressed(window, 77);
            let ctrl_is_down: i32 = heidic_ctrl_down(window);
            if m_is_pressed == 1 && ctrl_is_down == 1 {
                let selected_count: i32 = heidic_get_selection_count();
                if selected_count > 0 {
                    // Save to meshes directory (create if doesn't exist)
                    // For now, save to "meshes/combined_mesh.hdm" in current directory
                    let mesh_filepath: string = "meshes/combined_mesh.hdm";
                    let result: i32 = heidic_combine_selected_cubes_to_mesh(mesh_filepath);
                    if result == 1 {
                        print("Successfully combined selected cubes into mesh: ");
                        print(mesh_filepath);
                        print("\n");
                        // Optionally clear selection after combining
                        // heidic_clear_selection();
                    } else {
                        print("Failed to combine cubes into mesh\n");
                    }
                }
            }
        
        // C key (67) - Combine selected cubes
        let c_is_pressed: i32 = heidic_is_key_pressed(window, 67);
        
        if c_is_pressed == 1 {
            if combine_c_was_pressed == 0 {
                // Check if we have any cubes selected
                let selection_count: i32 = heidic_get_selection_count();
                if selection_count > 0 {
                    print("C pressed - Combining selected cubes\n");
                    heidic_combine_selected_cubes();
                    print("Combination complete\n");
                } else {
                    // No selection, silently fail (do nothing)
                }
            }
            combine_c_was_pressed = 1;
        } else {
            combine_c_was_pressed = 0;
        }
        
        // Delete key (261) - Delete selected cube
        let delete_is_pressed: i32 = heidic_is_key_pressed(window, 261);
        if delete_is_pressed == 1 {
            if delete_was_pressed == 0 {
                // Only delete if we have a selection and it's a created cube (not player)
                if has_selection == 1 && selected_cube_index >= 2.0 {
                    // Convert float index to int (created cubes: index = vector_index + 2.0)
                    let cube_vector_index: i32 = heidic_float_to_int(selected_cube_index - 2.0);
                    heidic_delete_cube(cube_vector_index);
                    print("Deleted cube at index ");
                    print("\n");
                    
                    // Clear selection after deletion
                    has_selection = 0;
                    selected_cube_index = -1.0;
                }
                delete_was_pressed = 1;
            }
        } else {
            delete_was_pressed = 0;
        }
        
        // Shift+Enter Toggle Logic - Switch between Fullscreen and Windowed
        // Enter = 257, Left Shift = 340, Right Shift = 344
        let enter_is_pressed: i32 = heidic_is_key_pressed(window, 257);
        let left_shift_is_pressed: i32 = heidic_is_key_pressed(window, 340);
        let right_shift_is_pressed: i32 = heidic_is_key_pressed(window, 344);
        let shift_is_pressed: i32 = 0;
        if left_shift_is_pressed == 1 {
            shift_is_pressed = 1;
        }
        if right_shift_is_pressed == 1 {
            shift_is_pressed = 1;
        }
        
        if enter_is_pressed == 1 && shift_is_pressed == 1 {
            if shift_enter_was_pressed == 0 {
                if video_mode == 1 {
                    video_mode = 0; // Switch to fullscreen
                    heidic_set_video_mode(0);
                } else {
                    video_mode = 1; // Switch to windowed
                    heidic_set_video_mode(1);
                }
                shift_enter_was_pressed = 1;
            }
        } else {
            shift_enter_was_pressed = 0;
        }
        
        // Calculate forward and right direction vectors based on Y rotation
        // Forward should follow the yellow line (Z-axis) direction
        // At 0°: forward = (0, 0, -1) = negative Z (model's forward at start)
        let rot_y_rad: f32 = heidic_convert_degrees_to_radians(player_rot.y);
        // Forward follows the rotated negative Z-axis (yellow line direction)
        // Try: forward = (-sin(angle), 0, -cos(angle))
        let forward_x: f32 = -heidic_sin(rot_y_rad);
        let forward_z: f32 = -heidic_cos(rot_y_rad);
        // Right = (cos(angle), 0, -sin(angle))
        let right_x: f32 = heidic_cos(rot_y_rad);
        let right_z: f32 = -heidic_sin(rot_y_rad);
        
        // WASD Movement Controls (relative to rotation)
        // W = 87: move forward (in direction player is facing)
        if heidic_is_key_pressed(window, 87) == 1 {
            player_pos.x = player_pos.x + forward_x * move_speed;
            player_pos.z = player_pos.z + forward_z * move_speed;
        }
        // S = 83: move backward (opposite of forward)
        if heidic_is_key_pressed(window, 83) == 1 {
            player_pos.x = player_pos.x - forward_x * move_speed;
            player_pos.z = player_pos.z - forward_z * move_speed;
        }
        // A = 65: move left (negative right direction)
        if heidic_is_key_pressed(window, 65) == 1 {
            player_pos.x = player_pos.x - right_x * move_speed;
            player_pos.z = player_pos.z - right_z * move_speed;
        }
        // D = 68: move right (positive right direction)
        if heidic_is_key_pressed(window, 68) == 1 {
            player_pos.x = player_pos.x + right_x * move_speed;
            player_pos.z = player_pos.z + right_z * move_speed;
        }
        
        // Q = 81: Raise player (move up in Y)
        if heidic_is_key_pressed(window, 81) == 1 {
            player_pos.y = player_pos.y + move_speed;
        }
        // E = 69: Lower player (move down in Y)
        if heidic_is_key_pressed(window, 69) == 1 {
            player_pos.y = player_pos.y - move_speed;
        }
        
        // Update camera based on mode
        if camera_mode == 1 {
            // FPS Mode: Make camera follow player with offset
            // Add offset to player position (100 units above player = eye height)
            let offset: Vec3 = heidic_vec3(0.0, 100.0, 0.0);
            let offset_pos: Vec3 = heidic_vec3_add(player_pos, offset);
            
            // Copy offset position to camera position
            camera_pos = heidic_attach_camera_translation(offset_pos);
            // Copy player rotation to camera rotation
            camera_rot = heidic_attach_camera_rotation(player_rot);
        } else {
            // Top-Down Mode: Use fixed top-down camera with zoom and pan
            // Ctrl+RMB drag for zoom (ZBrush style)
            // Left Ctrl = 341, Right Ctrl = 345, Right Mouse Button = 1
            let left_ctrl_pressed: i32 = heidic_is_key_pressed(window, 341);
            let right_ctrl_pressed: i32 = heidic_is_key_pressed(window, 345);
            let ctrl_pressed: i32 = 0;
            if left_ctrl_pressed == 1 {
                ctrl_pressed = 1;
            }
            if right_ctrl_pressed == 1 {
                ctrl_pressed = 1;
            }
            
            let right_mouse_pressed: i32 = heidic_is_mouse_button_pressed(window, 1);
            
            if ctrl_pressed == 1 && right_mouse_pressed == 1 {
                // Get mouse delta Y for zoom/dolly
                let mouse_delta_y: f32 = heidic_get_mouse_delta_y(window);
                if mouse_delta_y != 0.0 {
                    // If actively orbiting (Alt pressed) AND has selection: Adjust dolly distance
                    // Otherwise: Always adjust zoom (camera height) - zoom should always work
                    if alt_pressed == 1 && has_selection == 1 {
                        // Dolly: Adjust distance to target (only when actively orbiting)
                        // Negative delta = move closer (dolly in), positive = move away (dolly out)
                        let dolly_speed: f32 = 50.0; // Units per pixel
                        dolly_orbit_distance = dolly_orbit_distance - mouse_delta_y * dolly_speed;
                        
                        // Clamp distance to reasonable range (allow very close and very far)
                        if dolly_orbit_distance < 10.0 {
                            dolly_orbit_distance = 10.0; // Min: 10cm (very close)
                        }
                        if dolly_orbit_distance > 100000.0 {
                            dolly_orbit_distance = 100000.0; // Max: 1km
                        }
                    } else {
                        // Zoom: Adjust camera height (FOV-style zoom for top-down) - ALWAYS available
                        // Speed proportional to camera height for consistent feel
                        let zoom_speed_factor: f32 = topdown_cam_height / 10000.0; // Normalize to base height
                        let zoom_speed: f32 = 50.0 * zoom_speed_factor; // Base speed multiplier
                        topdown_cam_height = topdown_cam_height - mouse_delta_y * zoom_speed;
                        
                        // Clamp zoom level (allow going below ground if needed, but reasonable limits)
                        if topdown_cam_height < 10.0 {
                            topdown_cam_height = 10.0; // Min: 10cm (very close)
                        }
                        if topdown_cam_height > 100000.0 {
                            topdown_cam_height = 100000.0; // Max: 1km
                        }
                    }
                }
            }
            
            // [ and ] keys for zoom (backup/alternative)
            // [ = zoom in (lower height), ] = zoom out (higher height)
            if heidic_is_key_pressed(window, 91) == 1 {
                // Zoom in
                let zoom_speed: f32 = 100.0; // Reduced speed for finer control
                topdown_cam_height = topdown_cam_height - zoom_speed;
                
                // Clamp zoom level (min 100 units = 1 meter, max 50000 units = 500 meters)
                if topdown_cam_height < 100.0 {
                    topdown_cam_height = 100.0;
                }
            }
            if heidic_is_key_pressed(window, 93) == 1 {
                // Zoom out
                let zoom_speed: f32 = 100.0; // Reduced speed for finer control
                topdown_cam_height = topdown_cam_height + zoom_speed;
                
                // Clamp zoom level (min 1000 units = 10 meters, max 50000 units = 500 meters)
                if topdown_cam_height > 50000.0 {
                    topdown_cam_height = 50000.0;
                }
            }
            
            // MMB button press + drag for panning (translating camera across XZ plane)
            let mouse_middle_pressed: i32 = heidic_is_mouse_button_pressed(window, 2);
            if mouse_middle_pressed == 1 {
                // Get mouse delta for panning
                let mouse_delta_x: f32 = heidic_get_mouse_delta_x(window);
                let mouse_delta_y: f32 = heidic_get_mouse_delta_y(window);
                
                if mouse_delta_x != 0.0 || mouse_delta_y != 0.0 {
                    // Pan speed proportional to camera height for consistent feel
                    // Higher camera = move faster, lower camera = move slower
                    let pan_speed_factor: f32 = topdown_cam_height / 10000.0; // Normalize to base height
                    let pan_speed: f32 = 4.0 * pan_speed_factor; // Increased base speed to 4.0
                    
                    // Mouse X moves camera X (reversed: drag right = move left, drag left = move right)
                    topdown_cam_pan_x = topdown_cam_pan_x - mouse_delta_x * pan_speed;
                    // Mouse Y moves camera Z (reversed: drag down = move forward, drag up = move back)
                    topdown_cam_pan_z = topdown_cam_pan_z - mouse_delta_y * pan_speed;
                }
                mouse_middle_was_pressed = 1;
            } else {
                mouse_middle_was_pressed = 0;
            }
            
            // Update top-down camera position with new height and pan offset
            // BUT: Skip this if we're in orbit mode (orbit code already set camera_pos)
            if in_orbit_mode == 0 {
                topdown_cam_pos = heidic_vec3(topdown_cam_pan_x, topdown_cam_height, topdown_cam_pan_z);
                camera_pos = topdown_cam_pos;
                camera_rot = topdown_cam_rot;
            }
            // Reset orbit flag for next frame
            in_orbit_mode = 0;
        }
        
        // Update legacy variables for drawing
        cube_x = player_pos.x;
        cube_y = player_pos.y;
        cube_z = player_pos.z;
        cube_rx = player_rot.x;
        cube_ry = player_rot.y;
        cube_rz = player_rot.z;
        
        heidic_begin_frame();
        
        // Setup dockspace (enables docking for all windows)
        heidic_imgui_setup_dockspace();
        
        // Main Menu Bar
        if heidic_imgui_begin_main_menu_bar() == 1 {
            if heidic_imgui_begin_menu("File") == 1 {
                if heidic_imgui_menu_item("Save Level As...") == 1 {
                    // Show native save dialog
                    let save_result: i32 = heidic_show_save_dialog();
                    if save_result == 1 {
                        // Success - level saved via dialog
                    }
                }
                if heidic_imgui_menu_item("Open Level...") == 1 {
                    // Show native open dialog
                    let load_result: i32 = heidic_show_open_dialog();
                    if load_result == 1 {
                        // Success - level loaded via dialog
                    }
                }
                heidic_imgui_separator();
                if heidic_imgui_menu_item("Exit") == 1 {
                    heidic_set_window_should_close(window, 1);
                }
                heidic_imgui_end_menu();
            }
            if heidic_imgui_begin_menu("Object") == 1 {
                if heidic_imgui_menu_item("Add Cube") == 1 {
                    // Create cube at origin (0, 0, 0) with default size
                    let default_cube_size: f32 = 200.0; // 2 meters
                    let new_cube_index: i32 = heidic_create_cube(0.0, 0.0, 0.0, default_cube_size, default_cube_size, default_cube_size);
                    // Select the newly created cube (indices start from 2.0 for created cubes)
                    // Convert index to float and add 2.0 offset
                    selected_cube_index = heidic_int_to_float(new_cube_index) + 2.0;
                    has_selection = 1;
                    // Update selected cube properties for gizmo
                    selected_cube_x = 0.0;
                    selected_cube_y = 0.0;
                    selected_cube_z = 0.0;
                    selected_cube_sx = default_cube_size;
                    selected_cube_sy = default_cube_size;
                    selected_cube_sz = default_cube_size;
                }
                if heidic_imgui_menu_item("Load Mesh") == 1 {
                    let mesh_id: i32 = heidic_show_open_mesh_dialog();
                    if mesh_id >= 0 {
                        print("Successfully loaded mesh with ID: ");
                        print(mesh_id);
                        print("\n");
                    } else {
                        print("Failed to load mesh or user cancelled\n");
                    }
                }
                heidic_imgui_end_menu();
            }
            heidic_imgui_end_main_menu_bar();
        }
        
        // Update Camera with Vec3 values
        // Use larger far plane for top-down view to see distant objects
        if camera_mode == 0 {
            // Top-down mode: use 50000 units far plane (500 meters) to see everything
            heidic_update_camera_with_far(camera_pos.x, camera_pos.y, camera_pos.z, camera_rot.x, camera_rot.y, camera_rot.z, 50000.0);
        } else {
            // FPS mode: use default 5000 units far plane (50 meters)
            heidic_update_camera(camera_pos.x, camera_pos.y, camera_pos.z, camera_rot.x, camera_rot.y, camera_rot.z);
        }
        
        // Draw solid ground plane cube: 100m x 100m x 1m thick at y = -5m (-500 units)
        // 100 meters = 10000 units, 1 meter = 100 units, -5 meters = -500 units
        // Ensure default white texture is loaded before drawing non-textured geometry
        // This prevents texture color from tinting the ground plane
        heidic_load_texture_for_rendering("default.bmp");
        heidic_draw_cube_grey(0.0, -500.0, 0.0, 0.0, 0.0, 0.0, 10000.0, 100.0, 10000.0);
        
        // Draw Ground Plane grid (large grid at y=-300) - only if grid is visible
        if show_grid == 1 {
            heidic_draw_ground_plane(20000.0, 0.5, 0.5, 0.5); // 200 meters, grey color
        }
        
        // Update player cube visibility based on camera mode
        if camera_mode == 1 {
            // Walk mode (FPS): make player cube invisible
            player_cube_visible = INVISIBLE;
        } else {
            // Top-down mode: make player cube visible
            player_cube_visible = VISIBLE;
        }
        
        // Draw Player Cube (only if visible)
        if player_cube_visible == VISIBLE {
            heidic_draw_cube(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, cube_sx, cube_sy, cube_sz);
        }
        
        // Draw Origin Lines (1 meter = 100 cm = 100 units)
        // Player origin lines are invisible (only draw for reference cubes if needed)
        // heidic_draw_model_origin(cube_x, cube_y, cube_z, cube_rx, cube_ry, cube_rz, 100.0);
        
        // Starting cubes removed - user can create cubes with Spacebar or Object menu
        
        // Draw Created Cubes (user-created via Spacebar) - Dynamic system
        // Batch cubes by texture: when texture changes, flush current batch and start new one
        // This ensures each cube gets the correct texture while maintaining efficient batching
        let cube_draw_index: i32 = 0;
        let total_cubes: i32 = heidic_get_cube_total_count();
        let current_texture: string = "";
        let first_cube: i32 = 1;
        
        while cube_draw_index < total_cubes {
            if heidic_get_cube_active(cube_draw_index) == 1 {
                let cube_texture_name: string = heidic_get_cube_texture_name(cube_draw_index);
                // Use default texture if empty
                if cube_texture_name == "" {
                    cube_texture_name = "default.bmp";
                }
                
                // If texture changed, flush previous batch and start new one
                if first_cube == 0 && cube_texture_name != current_texture {
                    // Flush current batch (draw all cubes with current_texture)
                    heidic_flush_colored_cubes();
                    // Load new texture
                    heidic_load_texture_for_rendering(cube_texture_name);
                    current_texture = cube_texture_name;
                } else {
                    if first_cube == 1 {
                        // First cube - load its texture
                        heidic_load_texture_for_rendering(cube_texture_name);
                        current_texture = cube_texture_name;
                        first_cube = 0;
                    }
                }
                
                let cube_x: f32 = heidic_get_cube_x(cube_draw_index);
                let cube_y: f32 = heidic_get_cube_y(cube_draw_index);
                let cube_z: f32 = heidic_get_cube_z(cube_draw_index);
                let cube_sx: f32 = heidic_get_cube_sx(cube_draw_index);
                let cube_sy: f32 = heidic_get_cube_sy(cube_draw_index);
                let cube_sz: f32 = heidic_get_cube_sz(cube_draw_index);
                
                // Draw cube with white color (1,1,1) so texture displays at full brightness without tinting
                heidic_draw_cube_colored(cube_x, cube_y, cube_z, 0.0, 0.0, 0.0, cube_sx, cube_sy, cube_sz, 1.0, 1.0, 1.0);
                
                // Draw wireframe outline for selected cubes
                if heidic_is_cube_selected(cube_draw_index) == 1 {
                    // Draw wireframe outline (slightly larger than cube, white color)
                    heidic_draw_cube_wireframe(cube_x, cube_y, cube_z, 0.0, 0.0, 0.0, cube_sx * 1.01, cube_sy * 1.01, cube_sz * 1.01, 1.0, 1.0, 1.0);
                }
            }
            cube_draw_index = cube_draw_index + 1;
        }
        
        // Flush any remaining batched cubes at the end (draw final texture group)
        heidic_flush_colored_cubes();
        
        // Draw all loaded mesh instances (from .hdm files)
        let mesh_instance_count: i32 = heidic_get_mesh_instance_total_count();
        if mesh_instance_count > 0 {
            // Ensure default texture is loaded after drawing cubes (in case mesh has no texture)
            heidic_load_texture_for_rendering("default.bmp");
            
            let mesh_instance_index: i32 = 0;
            while mesh_instance_index < mesh_instance_count {
                if heidic_get_mesh_instance_active(mesh_instance_index) == 1 {
                    // Get mesh instance data
                    let instance_mesh_id: i32 = heidic_get_mesh_instance_mesh_id(mesh_instance_index);
                    let instance_x: f32 = heidic_get_mesh_instance_x(mesh_instance_index);
                    let instance_y: f32 = heidic_get_mesh_instance_y(mesh_instance_index);
                    let instance_z: f32 = heidic_get_mesh_instance_z(mesh_instance_index);
                    
                    // Get mesh center, scale, and rotation
                    let mesh_center_x: f32 = heidic_get_mesh_instance_center_x(mesh_instance_index);
                    let mesh_center_y: f32 = heidic_get_mesh_instance_center_y(mesh_instance_index);
                    let mesh_center_z: f32 = heidic_get_mesh_instance_center_z(mesh_instance_index);
                    let mesh_sx: f32 = heidic_get_mesh_instance_sx(mesh_instance_index);
                    let mesh_sy: f32 = heidic_get_mesh_instance_sy(mesh_instance_index);
                    let mesh_sz: f32 = heidic_get_mesh_instance_sz(mesh_instance_index);
                    let mesh_rx: f32 = heidic_get_mesh_instance_rx(mesh_instance_index);
                    let mesh_ry: f32 = heidic_get_mesh_instance_ry(mesh_instance_index);
                    let mesh_rz: f32 = heidic_get_mesh_instance_rz(mesh_instance_index);
                    
                    // Calculate actual world position (instance offset + original center)
                    let world_x: f32 = instance_x + mesh_center_x;
                    let world_y: f32 = instance_y + mesh_center_y;
                    let world_z: f32 = instance_z + mesh_center_z;
                    
                    // Draw mesh at world position with scale and rotation
                    // Note: Mesh vertices are in world space, so we need to scale around the mesh center
                    // to prevent translation when scaling
                    heidic_draw_mesh_scaled_with_center(instance_mesh_id, instance_x, instance_y, instance_z, mesh_rx, mesh_ry, mesh_rz, mesh_sx, mesh_sy, mesh_sz, mesh_center_x, mesh_center_y, mesh_center_z);
                    
                    // Draw wireframe bounding box for selected meshes
                    if heidic_is_mesh_selected(mesh_instance_index) == 1 {
                        // Get bounding box (relative to mesh center)
                        let bbox_min_x: f32 = heidic_get_mesh_instance_bbox_min_x(mesh_instance_index);
                        let bbox_min_y: f32 = heidic_get_mesh_instance_bbox_min_y(mesh_instance_index);
                        let bbox_min_z: f32 = heidic_get_mesh_instance_bbox_min_z(mesh_instance_index);
                        let bbox_max_x: f32 = heidic_get_mesh_instance_bbox_max_x(mesh_instance_index);
                        let bbox_max_y: f32 = heidic_get_mesh_instance_bbox_max_y(mesh_instance_index);
                        let bbox_max_z: f32 = heidic_get_mesh_instance_bbox_max_z(mesh_instance_index);
                        
                        // Scale bounding box by current scale
                        let scaled_min_x: f32 = bbox_min_x * mesh_sx;
                        let scaled_min_y: f32 = bbox_min_y * mesh_sy;
                        let scaled_min_z: f32 = bbox_min_z * mesh_sz;
                        let scaled_max_x: f32 = bbox_max_x * mesh_sx;
                        let scaled_max_y: f32 = bbox_max_y * mesh_sy;
                        let scaled_max_z: f32 = bbox_max_z * mesh_sz;
                        
                        // Calculate bounding box center and size (in world space)
                        let bbox_center_x: f32 = world_x;
                        let bbox_center_y: f32 = world_y;
                        let bbox_center_z: f32 = world_z;
                        let bbox_size_x: f32 = scaled_max_x - scaled_min_x;
                        let bbox_size_y: f32 = scaled_max_y - scaled_min_y;
                        let bbox_size_z: f32 = scaled_max_z - scaled_min_z;
                        
                        // Draw wireframe bounding box (yellow) - this matches where the corner cubes will be
                        heidic_draw_cube_wireframe(bbox_center_x, bbox_center_y, bbox_center_z, 0.0, 0.0, 0.0, 
                                                    bbox_size_x, bbox_size_y, bbox_size_z, 1.0, 1.0, 0.0);
                    }
                }
                mesh_instance_index = mesh_instance_index + 1;
            }
        }
        
        // ============================================================================
        // RAYCASTING
        // ============================================================================
        
        // Yellow debug line - draw from camera to 50km out along ray
        // This helps visualize where the ray is pointing
        heidic_draw_ray(window, 50000.0, 1.0, 1.0, 0.0);
        
        // Debug: Draw large red cube at ray hit point to visualize where ray intersects geometry
        // Always calculate and draw, regardless of mode
        let debug_ray_origin: Vec3 = heidic_get_mouse_ray_origin(window);
        let debug_ray_dir: Vec3 = heidic_get_mouse_ray_dir(window);
        let debug_hit_pos: Vec3 = heidic_vec3(0.0, 0.0, 0.0);
        let debug_found_hit: i32 = 0;
        let debug_closest_dist: f32 = 100000000000.0;
        let debug_hit_cube_x: f32 = 0.0;
        let debug_hit_cube_y: f32 = 0.0;
        let debug_hit_cube_z: f32 = 0.0;
        let debug_hit_cube_sx: f32 = 0.0;
        let debug_hit_cube_sy: f32 = 0.0;
        let debug_hit_cube_sz: f32 = 0.0;
        let debug_hit_face: i32 = -1; // -1 = no face, 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
        let debug_is_ground_plane: i32 = 0;
        
        // FIRST: Test the big grey ground plane cube (100m x 100m x 1m at y = -500)
        // This is important geometry and needs to be pickable!
        let ground_cube_x: f32 = 0.0;
        let ground_cube_y: f32 = -500.0;
        let ground_cube_z: f32 = 0.0;
        let ground_cube_sx: f32 = 10000.0; // 100 meters
        let ground_cube_sy: f32 = 100.0;   // 1 meter thick
        let ground_cube_sz: f32 = 10000.0; // 100 meters
        
        let ground_cube_hit: i32 = heidic_raycast_cube_hit(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
        if ground_cube_hit == 1 {
            let ground_cube_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, ground_cube_x, ground_cube_y, ground_cube_z, ground_cube_sx, ground_cube_sy, ground_cube_sz);
            let ground_cube_dist: f32 = (ground_cube_hit_point.x - debug_ray_origin.x) * (ground_cube_hit_point.x - debug_ray_origin.x) + (ground_cube_hit_point.y - debug_ray_origin.y) * (ground_cube_hit_point.y - debug_ray_origin.y) + (ground_cube_hit_point.z - debug_ray_origin.z) * (ground_cube_hit_point.z - debug_ray_origin.z);
            if ground_cube_dist < debug_closest_dist {
                debug_closest_dist = ground_cube_dist;
                debug_hit_pos = ground_cube_hit_point;
                debug_hit_cube_x = ground_cube_x;
                debug_hit_cube_y = ground_cube_y;
                debug_hit_cube_z = ground_cube_z;
                debug_hit_cube_sx = ground_cube_sx;
                debug_hit_cube_sy = ground_cube_sy;
                debug_hit_cube_sz = ground_cube_sz;
                debug_is_ground_plane = 1;
                debug_found_hit = 1;
            }
        }
        
        // Test all created cubes to find closest hit
        let debug_cube_index: i32 = 0;
        let debug_total_cubes: i32 = heidic_get_cube_total_count();
        while debug_cube_index < debug_total_cubes {
            if heidic_get_cube_active(debug_cube_index) == 1 {
                let debug_cube_x: f32 = heidic_get_cube_x(debug_cube_index);
                let debug_cube_y: f32 = heidic_get_cube_y(debug_cube_index);
                let debug_cube_z: f32 = heidic_get_cube_z(debug_cube_index);
                let debug_cube_sx: f32 = heidic_get_cube_sx(debug_cube_index);
                let debug_cube_sy: f32 = heidic_get_cube_sy(debug_cube_index);
                let debug_cube_sz: f32 = heidic_get_cube_sz(debug_cube_index);
                
                let debug_cube_hit: i32 = heidic_raycast_cube_hit(window, debug_cube_x, debug_cube_y, debug_cube_z, debug_cube_sx, debug_cube_sy, debug_cube_sz);
                if debug_cube_hit == 1 {
                    let debug_hit_point: Vec3 = heidic_raycast_cube_hit_point(window, debug_cube_x, debug_cube_y, debug_cube_z, debug_cube_sx, debug_cube_sy, debug_cube_sz);
                    let debug_dist: f32 = (debug_hit_point.x - debug_ray_origin.x) * (debug_hit_point.x - debug_ray_origin.x) + (debug_hit_point.y - debug_ray_origin.y) * (debug_hit_point.y - debug_ray_origin.y) + (debug_hit_point.z - debug_ray_origin.z) * (debug_hit_point.z - debug_ray_origin.z);
                    if debug_dist < debug_closest_dist {
                        debug_closest_dist = debug_dist;
                        debug_hit_pos = debug_hit_point;
                        debug_hit_cube_x = debug_cube_x;
                        debug_hit_cube_y = debug_cube_y;
                        debug_hit_cube_z = debug_cube_z;
                        debug_hit_cube_sx = debug_cube_sx;
                        debug_hit_cube_sy = debug_cube_sy;
                        debug_hit_cube_sz = debug_cube_sz;
                        debug_is_ground_plane = 0;
                        debug_found_hit = 1;
                    }
                }
            }
            debug_cube_index = debug_cube_index + 1;
        }
        
        // If still no hit, place debug cube along the ray (5 meters out) so we can always see where the ray is pointing
        if debug_found_hit == 0 {
            debug_hit_pos = heidic_vec3_add(debug_ray_origin, heidic_vec3_mul_scalar(debug_ray_dir, 500.0));
        }
        
        // Always draw red wireframe cube to show where ray is pointing/hitting
        // Unit square (100 units = 1 meter) for better precision
        heidic_draw_cube_wireframe(debug_hit_pos.x, debug_hit_pos.y, debug_hit_pos.z, 0.0, 0.0, 0.0, 100.0, 100.0, 100.0, 1.0, 0.0, 0.0);
        
        // If we hit a cube, determine which face was hit and highlight it
        if debug_found_hit == 1 && debug_is_ground_plane == 0 {
            // Calculate cube bounds
            let debug_cube_min_x: f32 = debug_hit_cube_x - debug_hit_cube_sx / 2.0;
            let debug_cube_max_x: f32 = debug_hit_cube_x + debug_hit_cube_sx / 2.0;
            let debug_cube_min_y: f32 = debug_hit_cube_y - debug_hit_cube_sy / 2.0;
            let debug_cube_max_y: f32 = debug_hit_cube_y + debug_hit_cube_sy / 2.0;
            let debug_cube_min_z: f32 = debug_hit_cube_z - debug_hit_cube_sz / 2.0;
            let debug_cube_max_z: f32 = debug_hit_cube_z + debug_hit_cube_sz / 2.0;
            
            // Calculate distances from hit point to each face
            let debug_dist_to_left: f32 = debug_hit_pos.x - debug_cube_min_x;
            let debug_dist_to_right: f32 = debug_cube_max_x - debug_hit_pos.x;
            let debug_dist_to_bottom: f32 = debug_hit_pos.y - debug_cube_min_y;
            let debug_dist_to_top: f32 = debug_cube_max_y - debug_hit_pos.y;
            let debug_dist_to_back: f32 = debug_hit_pos.z - debug_cube_min_z;
            let debug_dist_to_front: f32 = debug_cube_max_z - debug_hit_pos.z;
            
            // Find the closest face (smallest distance)
            let debug_min_dist: f32 = debug_dist_to_left;
            debug_hit_face = 0; // 0=left, 1=right, 2=bottom, 3=top, 4=back, 5=front
            
            if debug_dist_to_right < debug_min_dist {
                debug_min_dist = debug_dist_to_right;
                debug_hit_face = 1;
            }
            if debug_dist_to_bottom < debug_min_dist {
                debug_min_dist = debug_dist_to_bottom;
                debug_hit_face = 2;
            }
            if debug_dist_to_top < debug_min_dist {
                debug_min_dist = debug_dist_to_top;
                debug_hit_face = 3;
            }
            if debug_dist_to_back < debug_min_dist {
                debug_min_dist = debug_dist_to_back;
                debug_hit_face = 4;
            }
            if debug_dist_to_front < debug_min_dist {
                debug_min_dist = debug_dist_to_front;
                debug_hit_face = 5;
            }
            
            // Draw highlighted filled face (bright yellow/green)
            let highlight_offset: f32 = 1.0; // Small offset to avoid z-fighting
            let grid_density: f32 = 10.0; // Number of grid lines per face dimension
            if debug_hit_face == 0 {
                // Left face (negative X) - draw filled rectangle on left face
                let y1: f32 = debug_cube_min_y;
                let y2: f32 = debug_cube_max_y;
                let z1: f32 = debug_cube_min_z;
                let z2: f32 = debug_cube_max_z;
                let x: f32 = debug_cube_min_x - highlight_offset;
                
                // Draw outline
                heidic_draw_line(x, y1, z1, x, y2, z1, 0.0, 1.0, 0.0); // Bottom edge
                heidic_draw_line(x, y2, z1, x, y2, z2, 0.0, 1.0, 0.0); // Right edge
                heidic_draw_line(x, y2, z2, x, y1, z2, 0.0, 1.0, 0.0); // Top edge
                heidic_draw_line(x, y1, z2, x, y1, z1, 0.0, 1.0, 0.0); // Left edge
                
                // Fill with grid pattern (vertical lines)
                let grid_step_y: f32 = (y2 - y1) / grid_density;
                let grid_i: i32 = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_y: f32 = y1 + heidic_int_to_float(grid_i) * grid_step_y;
                    heidic_draw_line(x, grid_y, z1, x, grid_y, z2, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
                
                // Fill with grid pattern (horizontal lines)
                let grid_step_z: f32 = (z2 - z1) / grid_density;
                grid_i = 0;
                while grid_i <= heidic_float_to_int(grid_density) {
                    let grid_z: f32 = z1 + heidic_int_to_float(grid_i) * grid_step_z;
                    heidic_draw_line(x, y1, grid_z, x, y2, grid_z, 0.0, 1.0, 0.0);
                    grid_i = grid_i + 1;
                }
            } else {
                if debug_hit_face == 1 {
                    // Right face (positive X) - draw filled rectangle on right face
                    let y1: f32 = debug_cube_min_y;
                    let y2: f32 = debug_cube_max_y;
                    let z1: f32 = debug_cube_min_z;
                    let z2: f32 = debug_cube_max_z;
                    let x: f32 = debug_cube_max_x + highlight_offset;
                    
                    // Draw outline
                    heidic_draw_line(x, y1, z1, x, y2, z1, 0.0, 1.0, 0.0); // Bottom edge
                    heidic_draw_line(x, y2, z1, x, y2, z2, 0.0, 1.0, 0.0); // Right edge
                    heidic_draw_line(x, y2, z2, x, y1, z2, 0.0, 1.0, 0.0); // Top edge
                    heidic_draw_line(x, y1, z2, x, y1, z1, 0.0, 1.0, 0.0); // Left edge
                    
                    // Fill with grid pattern
                    let grid_step_y: f32 = (y2 - y1) / grid_density;
                    let grid_i: i32 = 0;
                    while grid_i <= heidic_float_to_int(grid_density) {
                        let grid_y: f32 = y1 + heidic_int_to_float(grid_i) * grid_step_y;
                        heidic_draw_line(x, grid_y, z1, x, grid_y, z2, 0.0, 1.0, 0.0);
                        grid_i = grid_i + 1;
                    }
                    let grid_step_z: f32 = (z2 - z1) / grid_density;
                    grid_i = 0;
                    while grid_i <= heidic_float_to_int(grid_density) {
                        let grid_z: f32 = z1 + heidic_int_to_float(grid_i) * grid_step_z;
                        heidic_draw_line(x, y1, grid_z, x, y2, grid_z, 0.0, 1.0, 0.0);
                        grid_i = grid_i + 1;
                    }
                } else {
                    if debug_hit_face == 2 {
                        // Bottom face (negative Y) - draw filled rectangle on bottom face
                        let x1: f32 = debug_cube_min_x;
                        let x2: f32 = debug_cube_max_x;
                        let z1: f32 = debug_cube_min_z;
                        let z2: f32 = debug_cube_max_z;
                        let y: f32 = debug_cube_min_y - highlight_offset;
                        
                        // Draw outline
                        heidic_draw_line(x1, y, z1, x2, y, z1, 0.0, 1.0, 0.0); // Back edge
                        heidic_draw_line(x2, y, z1, x2, y, z2, 0.0, 1.0, 0.0); // Right edge
                        heidic_draw_line(x2, y, z2, x1, y, z2, 0.0, 1.0, 0.0); // Front edge
                        heidic_draw_line(x1, y, z2, x1, y, z1, 0.0, 1.0, 0.0); // Left edge
                        
                        // Fill with grid pattern
                        let grid_step_x: f32 = (x2 - x1) / grid_density;
                        let grid_i: i32 = 0;
                        while grid_i <= heidic_float_to_int(grid_density) {
                            let grid_x: f32 = x1 + heidic_int_to_float(grid_i) * grid_step_x;
                            heidic_draw_line(grid_x, y, z1, grid_x, y, z2, 0.0, 1.0, 0.0);
                            grid_i = grid_i + 1;
                        }
                        let grid_step_z: f32 = (z2 - z1) / grid_density;
                        grid_i = 0;
                        while grid_i <= heidic_float_to_int(grid_density) {
                            let grid_z: f32 = z1 + heidic_int_to_float(grid_i) * grid_step_z;
                            heidic_draw_line(x1, y, grid_z, x2, y, grid_z, 0.0, 1.0, 0.0);
                            grid_i = grid_i + 1;
                        }
                    } else {
                        if debug_hit_face == 3 {
                            // Top face (positive Y) - draw filled rectangle on top face
                            let x1: f32 = debug_cube_min_x;
                            let x2: f32 = debug_cube_max_x;
                            let z1: f32 = debug_cube_min_z;
                            let z2: f32 = debug_cube_max_z;
                            let y: f32 = debug_cube_max_y + highlight_offset;
                            
                            // Draw outline
                            heidic_draw_line(x1, y, z1, x2, y, z1, 0.0, 1.0, 0.0); // Back edge
                            heidic_draw_line(x2, y, z1, x2, y, z2, 0.0, 1.0, 0.0); // Right edge
                            heidic_draw_line(x2, y, z2, x1, y, z2, 0.0, 1.0, 0.0); // Front edge
                            heidic_draw_line(x1, y, z2, x1, y, z1, 0.0, 1.0, 0.0); // Left edge
                            
                            // Fill with grid pattern
                            let grid_step_x: f32 = (x2 - x1) / grid_density;
                            let grid_i: i32 = 0;
                            while grid_i <= heidic_float_to_int(grid_density) {
                                let grid_x: f32 = x1 + heidic_int_to_float(grid_i) * grid_step_x;
                                heidic_draw_line(grid_x, y, z1, grid_x, y, z2, 0.0, 1.0, 0.0);
                                grid_i = grid_i + 1;
                            }
                            let grid_step_z: f32 = (z2 - z1) / grid_density;
                            grid_i = 0;
                            while grid_i <= heidic_float_to_int(grid_density) {
                                let grid_z: f32 = z1 + heidic_int_to_float(grid_i) * grid_step_z;
                                heidic_draw_line(x1, y, grid_z, x2, y, grid_z, 0.0, 1.0, 0.0);
                                grid_i = grid_i + 1;
                            }
                        } else {
                            if debug_hit_face == 4 {
                                // Back face (negative Z) - draw filled rectangle on back face
                                let x1: f32 = debug_cube_min_x;
                                let x2: f32 = debug_cube_max_x;
                                let y1: f32 = debug_cube_min_y;
                                let y2: f32 = debug_cube_max_y;
                                let z: f32 = debug_cube_min_z - highlight_offset;
                                
                                // Draw outline
                                heidic_draw_line(x1, y1, z, x2, y1, z, 0.0, 1.0, 0.0); // Bottom edge
                                heidic_draw_line(x2, y1, z, x2, y2, z, 0.0, 1.0, 0.0); // Right edge
                                heidic_draw_line(x2, y2, z, x1, y2, z, 0.0, 1.0, 0.0); // Top edge
                                heidic_draw_line(x1, y2, z, x1, y1, z, 0.0, 1.0, 0.0); // Left edge
                                
                                // Fill with grid pattern
                                let grid_step_x: f32 = (x2 - x1) / grid_density;
                                let grid_i: i32 = 0;
                                while grid_i <= heidic_float_to_int(grid_density) {
                                    let grid_x: f32 = x1 + heidic_int_to_float(grid_i) * grid_step_x;
                                    heidic_draw_line(grid_x, y1, z, grid_x, y2, z, 0.0, 1.0, 0.0);
                                    grid_i = grid_i + 1;
                                }
                                let grid_step_y: f32 = (y2 - y1) / grid_density;
                                grid_i = 0;
                                while grid_i <= heidic_float_to_int(grid_density) {
                                    let grid_y: f32 = y1 + heidic_int_to_float(grid_i) * grid_step_y;
                                    heidic_draw_line(x1, grid_y, z, x2, grid_y, z, 0.0, 1.0, 0.0);
                                    grid_i = grid_i + 1;
                                }
                            } else {
                                // Front face (positive Z) - draw filled rectangle on front face
                                let x1: f32 = debug_cube_min_x;
                                let x2: f32 = debug_cube_max_x;
                                let y1: f32 = debug_cube_min_y;
                                let y2: f32 = debug_cube_max_y;
                                let z: f32 = debug_cube_max_z + highlight_offset;
                                
                                // Draw outline
                                heidic_draw_line(x1, y1, z, x2, y1, z, 0.0, 1.0, 0.0); // Bottom edge
                                heidic_draw_line(x2, y1, z, x2, y2, z, 0.0, 1.0, 0.0); // Right edge
                                heidic_draw_line(x2, y2, z, x1, y2, z, 0.0, 1.0, 0.0); // Top edge
                                heidic_draw_line(x1, y2, z, x1, y1, z, 0.0, 1.0, 0.0); // Left edge
                                
                                // Fill with grid pattern
                                let grid_step_x: f32 = (x2 - x1) / grid_density;
                                let grid_i: i32 = 0;
                                while grid_i <= heidic_float_to_int(grid_density) {
                                    let grid_x: f32 = x1 + heidic_int_to_float(grid_i) * grid_step_x;
                                    heidic_draw_line(grid_x, y1, z, grid_x, y2, z, 0.0, 1.0, 0.0);
                                    grid_i = grid_i + 1;
                                }
                                let grid_step_y: f32 = (y2 - y1) / grid_density;
                                grid_i = 0;
                                while grid_i <= heidic_float_to_int(grid_density) {
                                    let grid_y: f32 = y1 + heidic_int_to_float(grid_i) * grid_step_y;
                                    heidic_draw_line(x1, grid_y, z, x2, grid_y, z, 0.0, 1.0, 0.0);
                                    grid_i = grid_i + 1;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Mouse mode toggle: Left-click enables mouse (cursor visible, picking on), Right-click disables (cursor hidden, dolly/look on)
        let mouse_left_pressed: i32 = heidic_is_mouse_button_pressed(window, 0);
        let mouse_right_pressed: i32 = heidic_is_mouse_button_pressed(window, 1);
        
        // Left-click: Enable mouse mode (cursor visible, picking enabled)
        if mouse_left_pressed == 1 {
            if mouse_mode_left_was_pressed == 0 {
                mouse_mode = 1; // Enable mouse mode
                heidic_set_cursor_mode(window, 0); // 0 = normal (visible cursor)
                mouse_mode_left_was_pressed = 1;
            }
        } else {
            mouse_mode_left_was_pressed = 0;
        }
        
        // Right-click: Disable mouse mode (cursor hidden, dolly/look enabled)
        if mouse_right_pressed == 1 {
            if mouse_mode_right_was_pressed == 0 {
                mouse_mode = 0; // Disable mouse mode
                if camera_mode == 1 {
                    // In walk mode, capture cursor for mouse look
                    heidic_set_cursor_mode(window, 2); // 2 = disabled (captured)
                } else {
                    // In top-down mode, just hide cursor
                    heidic_set_cursor_mode(window, 1); // 1 = hidden
                }
                mouse_mode_right_was_pressed = 1;
            }
        } else {
            mouse_mode_right_was_pressed = 0;
        }
        
        // DEBUG: Print ray info on click
        // if mouse_left_pressed == 1 {
        //    if mouse_left_was_pressed == 0 {
        //        heidic_debug_print_ray(window);
        //    }
        // }
        
        // Check gizmo interaction FIRST (before selection processing)
        // This prevents deselection when clicking on gizmos
        let gizmo_clicked: i32 = 0;
        if mouse_mode == 1 && mouse_left_pressed == 1 && alt_pressed == 0 && has_mesh_selection == 1 && selected_mesh_instance_id >= 0 {
            // A mesh is selected - check if gizmo would be clicked
            let mesh_center_x: f32 = heidic_get_mesh_instance_center_x(selected_mesh_instance_id);
            let mesh_center_y: f32 = heidic_get_mesh_instance_center_y(selected_mesh_instance_id);
            let mesh_center_z: f32 = heidic_get_mesh_instance_center_z(selected_mesh_instance_id);
            let gizmo_x: f32 = selected_mesh_x + mesh_center_x;
            let gizmo_y: f32 = selected_mesh_y + mesh_center_y;
            let gizmo_z: f32 = selected_mesh_z + mesh_center_z;
            let current_scale: f32 = heidic_get_mesh_instance_sx(selected_mesh_instance_id);
            
            // Check if translation gizmo would be clicked (by calling it, but we'll check interaction state)
            // We need to call it to update its internal state, but we'll check if it becomes active
            let temp_pos: Vec3 = heidic_gizmo_translate(window, gizmo_x, gizmo_y, gizmo_z);
            let translate_interacting: i32 = heidic_gizmo_is_interacting();
            
            // Check if scale gizmo would be clicked
            let bbox_min_x: f32 = heidic_get_mesh_instance_bbox_min_x(selected_mesh_instance_id);
            let bbox_min_y: f32 = heidic_get_mesh_instance_bbox_min_y(selected_mesh_instance_id);
            let bbox_min_z: f32 = heidic_get_mesh_instance_bbox_min_z(selected_mesh_instance_id);
            let bbox_max_x: f32 = heidic_get_mesh_instance_bbox_max_x(selected_mesh_instance_id);
            let bbox_max_y: f32 = heidic_get_mesh_instance_bbox_max_y(selected_mesh_instance_id);
            let bbox_max_z: f32 = heidic_get_mesh_instance_bbox_max_z(selected_mesh_instance_id);
            let temp_scale: f32 = heidic_gizmo_scale(window, gizmo_x, gizmo_y, gizmo_z,
                                                     bbox_min_x, bbox_min_y, bbox_min_z,
                                                     bbox_max_x, bbox_max_y, bbox_max_z,
                                                     current_scale);
            let scale_interacting: i32 = heidic_gizmo_scale_is_interacting();
            
            // Check if rotation gizmo would be clicked
            let current_rx: f32 = heidic_get_mesh_instance_rx(selected_mesh_instance_id);
            let current_ry: f32 = heidic_get_mesh_instance_ry(selected_mesh_instance_id);
            let current_rz: f32 = heidic_get_mesh_instance_rz(selected_mesh_instance_id);
            let temp_rot: Vec3 = heidic_gizmo_rotate(window, gizmo_x, gizmo_y, gizmo_z, current_rx, current_ry, current_rz);
            let rotate_interacting: i32 = heidic_gizmo_rotate_is_interacting();
            
            if translate_interacting == 1 || scale_interacting == 1 || rotate_interacting == 1 {
                gizmo_clicked = 1;
            }
        }
        
        // Selection: Click to select cubes - test ALL cubes
        // Only allow selection when mouse_mode is enabled AND Alt is NOT pressed (Alt+Click is for orbit, not selection)
        if mouse_mode == 1 && mouse_left_pressed == 1 && alt_pressed == 0 {
            // Check if Ctrl is pressed for multi-select
            let ctrl_left_pressed: i32 = heidic_is_key_pressed(window, 341);
            let ctrl_right_pressed: i32 = heidic_is_key_pressed(window, 345);
            let ctrl_pressed: i32 = 0;
            if ctrl_left_pressed == 1 || ctrl_right_pressed == 1 {
                ctrl_pressed = 1;
            }
            
            // Only check gizmo interaction if we're NOT doing a fresh click
            // This allows selection even if gizmo axes are being hovered
            let interacting: i32 = 0;
            let scale_interacting: i32 = 0;
            if mouse_left_was_pressed == 1 {
                // Already was pressed - check if gizmo is actively being dragged
                interacting = heidic_gizmo_is_interacting();
                scale_interacting = heidic_gizmo_scale_is_interacting();
            }
            
            // Skip selection processing if gizmo was clicked
            if gizmo_clicked == 0 && (interacting == 0 && scale_interacting == 0) {
                if mouse_left_was_pressed == 0 {
                    // Just clicked - test raycast against all cubes and find closest hit
                    // Initialize closest_dist to a very large number (squared distance)
                    // 100,000,000,000.0 is roughly 316,000 units (3.16 km) distance
                    let closest_dist: f32 = 100000000000.0;
                    let hit_cube_index: i32 = -1;
                    
                    // Player cube is NOT selectable (it's invisible in walk mode and shouldn't interfere)
                    // Skip player cube selection test
                    
                    // Test Created Cubes (Dynamic system - indices start at 2.0)
                    let cube_test_index: i32 = 0;
                    let total_cubes_test: i32 = heidic_get_cube_total_count();
                    while cube_test_index < total_cubes_test {
                        if heidic_get_cube_active(cube_test_index) == 1 {
                            let test_cube_x: f32 = heidic_get_cube_x(cube_test_index);
                            let test_cube_y: f32 = heidic_get_cube_y(cube_test_index);
                            let test_cube_z: f32 = heidic_get_cube_z(cube_test_index);
                            let test_cube_sx: f32 = heidic_get_cube_sx(cube_test_index);
                            let test_cube_sy: f32 = heidic_get_cube_sy(cube_test_index);
                            let test_cube_sz: f32 = heidic_get_cube_sz(cube_test_index);
                            
                            let created_hit: i32 = heidic_raycast_cube_hit(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                            if created_hit == 1 {
                                let hit_point: Vec3 = heidic_raycast_cube_hit_point(window, test_cube_x, test_cube_y, test_cube_z, test_cube_sx, test_cube_sy, test_cube_sz);
                                let dist: f32 = (hit_point.x - ray_origin.x) * (hit_point.x - ray_origin.x) + (hit_point.y - ray_origin.y) * (hit_point.y - ray_origin.y) + (hit_point.z - ray_origin.z) * (hit_point.z - ray_origin.z);
                                if dist < closest_dist {
                                    closest_dist = dist;
                                    hit_cube_index = cube_test_index;
                                }
                            }
                        }
                        cube_test_index = cube_test_index + 1;
                    }
                    
                    // Handle selection based on Ctrl state
                    if hit_cube_index >= 0 {
                        if ctrl_pressed == 1 {
                            // Ctrl+Click: Toggle multi-select
                            heidic_toggle_selection(hit_cube_index);
                        } else {
                            // Regular click: Clear selection and select only this cube
                            heidic_clear_selection();
                            heidic_add_to_selection(hit_cube_index);
                        }
                        
                        // Update single selection state for gizmo compatibility
                        let cube_index_f: f32 = heidic_int_to_float(hit_cube_index);
                        selected_cube_index = cube_index_f + 2.0;
                        selected_cube_x = heidic_get_cube_x(hit_cube_index);
                        selected_cube_y = heidic_get_cube_y(hit_cube_index);
                        selected_cube_z = heidic_get_cube_z(hit_cube_index);
                        selected_cube_sx = heidic_get_cube_sx(hit_cube_index);
                        selected_cube_sy = heidic_get_cube_sy(hit_cube_index);
                        selected_cube_sz = heidic_get_cube_sz(hit_cube_index);
                        has_selection = 1;
                        
                        // Initialize dolly orbit state for new selection
                        let target_pos: Vec3 = heidic_vec3(selected_cube_x, selected_cube_y, selected_cube_z);
                        let current_cam_pos: Vec3 = camera_pos;
                        let calculated_distance: f32 = heidic_vec3_distance(current_cam_pos, target_pos);
                        
                        // Use calculated distance if reasonable, otherwise use default
                        if calculated_distance > 10.0 && calculated_distance < 100000.0 {
                            dolly_orbit_distance = calculated_distance;
                        } else {
                            dolly_orbit_distance = 2000.0; // Default: 20 meters
                        }
                        dolly_orbit_azimuth = 0.0;
                        dolly_orbit_elevation = 45.0;
                    } else {
                        // Clicked on nothing - clear selection if not Ctrl+Click, not clicking on gizmo, and not clicking on ImGui
                        let imgui_wants_mouse: i32 = heidic_imgui_wants_mouse();
                        if ctrl_pressed == 0 && gizmo_clicked == 0 && imgui_wants_mouse == 0 {
                            heidic_clear_selection();
                            has_selection = 0;
                            selected_cube_index = -1.0;
                            
                            // Also clear mesh selection (only if not clicking on gizmo or ImGui)
                            heidic_clear_mesh_selection();
                            has_mesh_selection = 0;
                            selected_mesh_instance_id = -1;
                        }
                    }
                    
                    mouse_left_was_pressed = 1;
                }
            }
        } else {
            mouse_left_was_pressed = 0;
        }
        
        
        }  // End of block_input check
        
        // Show selection and Gizmo (always show, even when editing)
        if has_selection == 1 {
            // Draw wireframe overlay (black)
            heidic_draw_cube_wireframe(selected_cube_x, selected_cube_y, selected_cube_z, 0.0, 0.0, 0.0, selected_cube_sx * 1.01, selected_cube_sy * 1.01, selected_cube_sz * 1.01, 0.0, 0.0, 0.0);
            
            // Gizmo: Move selected object
            let new_pos: Vec3 = heidic_gizmo_translate(window, selected_cube_x, selected_cube_y, selected_cube_z);
            
            // Update selected position (the ghost)
            selected_cube_x = new_pos.x;
            selected_cube_y = new_pos.y;
            selected_cube_z = new_pos.z;
            
            // Player cube is not selectable, so only update created cubes
            // If moving Created Cubes (selected_cube_index >= 2.0)
            // Map: selected_cube_index 2.0 -> cube index 0, 3.0 -> 1, etc.
            if selected_cube_index >= 2.0 {
                let cube_storage_index: f32 = selected_cube_index - 2.0;
                heidic_set_cube_pos_f(cube_storage_index, selected_cube_x, selected_cube_y, selected_cube_z);
            }
        }
        
        // Show mesh selection and Gizmo
        if has_mesh_selection == 1 && selected_mesh_instance_id >= 0 {
            // Get mesh center and bounding box for gizmo positioning
            let mesh_center_x: f32 = heidic_get_mesh_instance_center_x(selected_mesh_instance_id);
            let mesh_center_y: f32 = heidic_get_mesh_instance_center_y(selected_mesh_instance_id);
            let mesh_center_z: f32 = heidic_get_mesh_instance_center_z(selected_mesh_instance_id);
            
            // Get current scale
            let current_scale: f32 = heidic_get_mesh_instance_sx(selected_mesh_instance_id);
            
            // Calculate world position of mesh center (instance offset + original center)
            let gizmo_x: f32 = selected_mesh_x + mesh_center_x;
            let gizmo_y: f32 = selected_mesh_y + mesh_center_y;
            let gizmo_z: f32 = selected_mesh_z + mesh_center_z;
            
            // Check if scale gizmo is being used (prevents translation when scaling)
            let scale_interacting: i32 = heidic_gizmo_scale_is_interacting();
            let translate_interacting: i32 = heidic_gizmo_is_interacting();
            
            // Scale gizmo: Scale selected mesh (using bounding box corners)
            // Get bounding box from instance (relative to mesh center)
            let bbox_min_x: f32 = heidic_get_mesh_instance_bbox_min_x(selected_mesh_instance_id);
            let bbox_min_y: f32 = heidic_get_mesh_instance_bbox_min_y(selected_mesh_instance_id);
            let bbox_min_z: f32 = heidic_get_mesh_instance_bbox_min_z(selected_mesh_instance_id);
            let bbox_max_x: f32 = heidic_get_mesh_instance_bbox_max_x(selected_mesh_instance_id);
            let bbox_max_y: f32 = heidic_get_mesh_instance_bbox_max_y(selected_mesh_instance_id);
            let bbox_max_z: f32 = heidic_get_mesh_instance_bbox_max_z(selected_mesh_instance_id);
            
            let new_scale: f32 = heidic_gizmo_scale(window, gizmo_x, gizmo_y, gizmo_z,
                                                     bbox_min_x, bbox_min_y, bbox_min_z,
                                                     bbox_max_x, bbox_max_y, bbox_max_z,
                                                     current_scale);
            
            // Update scale if it changed
            if new_scale != current_scale {
                heidic_set_mesh_instance_scale(selected_mesh_instance_id, new_scale, new_scale, new_scale);
            }
            
            // Get current rotation
            let current_rx: f32 = heidic_get_mesh_instance_rx(selected_mesh_instance_id);
            let current_ry: f32 = heidic_get_mesh_instance_ry(selected_mesh_instance_id);
            let current_rz: f32 = heidic_get_mesh_instance_rz(selected_mesh_instance_id);
            
            // Check if rotation gizmo is being used
            let rotate_interacting: i32 = heidic_gizmo_rotate_is_interacting();
            
            // Rotation gizmo: Rotate selected mesh
            let new_rotation: Vec3 = heidic_gizmo_rotate(window, gizmo_x, gizmo_y, gizmo_z, current_rx, current_ry, current_rz);
            
            // Update rotation if it changed
            if new_rotation.x != current_rx || new_rotation.y != current_ry || new_rotation.z != current_rz {
                heidic_set_mesh_instance_rotation(selected_mesh_instance_id, new_rotation.x, new_rotation.y, new_rotation.z);
            }
            
            // Translation gizmo: Only update if scale and rotation gizmos are not active
            if scale_interacting == 0 && rotate_interacting == 0 {
                // Translation gizmo: Move selected mesh (positioned at mesh center)
                let new_gizmo_pos: Vec3 = heidic_gizmo_translate(window, gizmo_x, gizmo_y, gizmo_z);
                
                // Only update position if translation gizmo is actually being dragged
                if translate_interacting == 1 {
                    // Calculate new instance offset (gizmo position - mesh center)
                    let new_instance_x: f32 = new_gizmo_pos.x - mesh_center_x;
                    let new_instance_y: f32 = new_gizmo_pos.y - mesh_center_y;
                    let new_instance_z: f32 = new_gizmo_pos.z - mesh_center_z;
                    
                    // Update selected mesh position
                    selected_mesh_x = new_instance_x;
                    selected_mesh_y = new_instance_y;
                    selected_mesh_z = new_instance_z;
                    
                    // Update mesh instance position
                    heidic_set_mesh_instance_pos(selected_mesh_instance_id, selected_mesh_x, selected_mesh_y, selected_mesh_z);
                }
            }
        }
        
        // Codex Of Forms - Show combinations and uncombined cubes
        if show_debug == 1 {
            if heidic_imgui_begin("Codex Of Forms") == 1 {
                let combination_count: i32 = heidic_get_combination_count();
                let total_cube_count: i32 = heidic_get_cube_total_count();
                
                // Global cube display index (sequential across all cubes)
                let global_cube_display_index: i32 = 1;
                
                // First, show all combinations with expand/collapse
                let combo_id: i32 = 0;
                while combo_id < combination_count {
                    // Push unique ID for this combination to avoid ID conflicts
                    heidic_imgui_push_id(combo_id);
                    
                    // Check if we're editing this combination
                    let editing_id: i32 = heidic_get_editing_combination_id();
                    let is_editing_this: i32 = 0;
                    if editing_id == combo_id {
                        is_editing_this = 1;
                    }
                    
                    // Get combination name (e.g., "combination_001")
                    let combo_name: string = heidic_format_combination_name(combo_id);
                    
                    // Show expand/collapse button (with unique ID)
                    let is_expanded: i32 = heidic_is_combination_expanded(combo_id);
                    let expand_button_text: string = "+";
                    if is_expanded == 1 {
                        expand_button_text = "-";
                    }
                    if heidic_imgui_button(expand_button_text) == 1 {
                        heidic_toggle_combination_expanded(combo_id);
                    }
                    heidic_imgui_same_line();
                    
                    // Always show input field next to combination name (no click needed)
                    // This function handles the buffer internally and returns 1 when Enter is pressed
                    let enter_pressed: i32 = heidic_imgui_input_text_combination_simple(combo_id);
                    // Enter pressed is handled inside the function (saves automatically)
                    
                    // If expanded, show cubes in this combination
                    if is_expanded == 1 {
                        let cube_index: i32 = 0;
                        
                        while cube_index < total_cube_count {
                            if heidic_get_cube_active(cube_index) == 1 {
                                if heidic_get_cube_combination_id(cube_index) == combo_id {
                                    // Push unique ID for this cube
                                    heidic_imgui_push_id(cube_index);
                                    
                                    // This cube belongs to this combination
                                    // Use global sequential numbering
                                    let cube_name: string = heidic_format_cube_name_with_index(global_cube_display_index);
                                    
                                    // Make cube name clickable to select it
                                    if heidic_is_cube_selected(cube_index) == 1 {
                                        // Selected: show in bold (yellow)
                                        heidic_imgui_text_bold(cube_name);
                                    } else {
                                        // Not selected: show in red and make clickable
                                        if heidic_imgui_selectable_colored(cube_name, 1.0, 0.0, 0.0, 1.0) == 1 {
                                            // Clicked: select this cube (clear others first if not Ctrl+Click)
                                            // For now, just select this one (can add Ctrl check later)
                                            heidic_clear_selection();
                                            heidic_add_to_selection(cube_index);
                                            
                                            // Update single selection state for gizmo
                                            let cube_index_f: f32 = heidic_int_to_float(cube_index);
                                            selected_cube_index = cube_index_f + 2.0;
                                            selected_cube_x = heidic_get_cube_x(cube_index);
                                            selected_cube_y = heidic_get_cube_y(cube_index);
                                            selected_cube_z = heidic_get_cube_z(cube_index);
                                            selected_cube_sx = heidic_get_cube_sx(cube_index);
                                            selected_cube_sy = heidic_get_cube_sy(cube_index);
                                            selected_cube_sz = heidic_get_cube_sz(cube_index);
                                            has_selection = 1;
                                        }
                                    }
                                    
                                    heidic_imgui_pop_id();
                                    global_cube_display_index = global_cube_display_index + 1;
                                }
                            }
                            cube_index = cube_index + 1;
                        }
                    } else {
                        // Even if collapsed, we need to count the cubes for global numbering
                        let cube_index: i32 = 0;
                        while cube_index < total_cube_count {
                            if heidic_get_cube_active(cube_index) == 1 {
                                if heidic_get_cube_combination_id(cube_index) == combo_id {
                                    global_cube_display_index = global_cube_display_index + 1;
                                }
                            }
                            cube_index = cube_index + 1;
                        }
                    }
                    
                    // Pop combination ID
                    heidic_imgui_pop_id();
                    combo_id = combo_id + 1;
                }
                
                // Then, show uncombined cubes (cubes with combination_id == -1)
                let cube_index: i32 = 0;
                
                while cube_index < total_cube_count {
                    if heidic_get_cube_active(cube_index) == 1 {
                        if heidic_get_cube_combination_id(cube_index) == -1 {
                            // Push unique ID for this cube
                            heidic_imgui_push_id(cube_index);
                            
                            // This cube is not in any combination
                            let cube_name: string = heidic_format_cube_name_with_index(global_cube_display_index);
                            
                            // Make cube name clickable to select it
                            if heidic_is_cube_selected(cube_index) == 1 {
                                // Selected: show in bold (yellow)
                                heidic_imgui_text_bold(cube_name);
                            } else {
                                // Not selected: make clickable
                                if heidic_imgui_selectable_str(cube_name) == 1 {
                                    // Clicked: select this cube (clear others first if not Ctrl+Click)
                                    heidic_clear_selection();
                                    heidic_add_to_selection(cube_index);
                                    
                                    // Update single selection state for gizmo
                                    let cube_index_f: f32 = heidic_int_to_float(cube_index);
                                    selected_cube_index = cube_index_f + 2.0;
                                    selected_cube_x = heidic_get_cube_x(cube_index);
                                    selected_cube_y = heidic_get_cube_y(cube_index);
                                    selected_cube_z = heidic_get_cube_z(cube_index);
                                    selected_cube_sx = heidic_get_cube_sx(cube_index);
                                    selected_cube_sy = heidic_get_cube_sy(cube_index);
                                    selected_cube_sz = heidic_get_cube_sz(cube_index);
                                    has_selection = 1;
                                }
                            }
                            
                            heidic_imgui_pop_id();
                            global_cube_display_index = global_cube_display_index + 1;
                        }
                    }
                    cube_index = cube_index + 1;
                }
                
                // Show mesh instances in outliner
                let mesh_instance_count: i32 = heidic_get_mesh_instance_total_count();
                if mesh_instance_count > 0 {
                    heidic_imgui_separator();
                    heidic_imgui_text("Meshes:");
                    
                    let mesh_instance_index: i32 = 0;
                    while mesh_instance_index < mesh_instance_count {
                        if heidic_get_mesh_instance_active(mesh_instance_index) == 1 {
                            heidic_imgui_push_id(mesh_instance_index + 10000);  // Offset to avoid conflicts
                            
                            let mesh_name: string = heidic_format_mesh_name(mesh_instance_index);
                            
                            // Make mesh name clickable to toggle selection
                            let is_mesh_selected: i32 = heidic_is_mesh_selected(mesh_instance_index);
                            
                            // Always use selectable so it's clickable whether selected or not
                            // Selectable will show visual feedback (highlighted when selected)
                            if heidic_imgui_selectable_str(mesh_name) == 1 {
                                if is_mesh_selected == 1 {
                                    // Already selected: clicking again deselects it
                                    heidic_clear_mesh_selection();
                                    has_mesh_selection = 0;
                                    selected_mesh_instance_id = -1;
                                } else {
                                    // Not selected: clicking selects it
                                    heidic_clear_selection();
                                    heidic_clear_mesh_selection();
                                    heidic_add_mesh_to_selection(mesh_instance_index);
                                    
                                    // Update mesh selection state for gizmo
                                    selected_mesh_instance_id = mesh_instance_index;
                                    selected_mesh_x = heidic_get_mesh_instance_x(mesh_instance_index);
                                    selected_mesh_y = heidic_get_mesh_instance_y(mesh_instance_index);
                                    selected_mesh_z = heidic_get_mesh_instance_z(mesh_instance_index);
                                    has_mesh_selection = 1;
                                    has_selection = 0;  // Clear cube selection
                                    selected_cube_index = -1.0;
                                }
                            }
                            
                            heidic_imgui_pop_id();
                        }
                        mesh_instance_index = mesh_instance_index + 1;
                    }
                }
                
                heidic_imgui_end();
            }
            
            // Rotation Control Window
            if has_mesh_selection == 1 && selected_mesh_instance_id >= 0 {
                if heidic_imgui_begin("Rotation Control") == 1 {
                    // Get current rotation
                    let current_rx: f32 = heidic_get_mesh_instance_rx(selected_mesh_instance_id);
                    let current_ry: f32 = heidic_get_mesh_instance_ry(selected_mesh_instance_id);
                    let current_rz: f32 = heidic_get_mesh_instance_rz(selected_mesh_instance_id);
                    
                    // X Rotation - Slider and Input (both work independently)
                    let new_rx_slider: f32 = heidic_imgui_slider_float("Rotation X", current_rx, 0.0, 360.0);
                    let new_rx_input: f32 = heidic_imgui_input_float("##RX", current_rx, 1.0, 10.0);
                    // Use input value if it changed, otherwise use slider value
                    let new_rx: f32 = new_rx_slider;
                    if new_rx_input != current_rx {
                        new_rx = new_rx_input;
                    }
                    if new_rx != current_rx {
                        // Clamp to 0-360 range
                        if new_rx < 0.0 {
                            new_rx = 0.0;
                        }
                        if new_rx > 360.0 {
                            new_rx = 360.0;
                        }
                        heidic_set_mesh_instance_rotation(selected_mesh_instance_id, new_rx, current_ry, current_rz);
                    }
                    
                    // Y Rotation - Slider and Input (both work independently)
                    let new_ry_slider: f32 = heidic_imgui_slider_float("Rotation Y", current_ry, 0.0, 360.0);
                    let new_ry_input: f32 = heidic_imgui_input_float("##RY", current_ry, 1.0, 10.0);
                    // Use input value if it changed, otherwise use slider value
                    let new_ry: f32 = new_ry_slider;
                    if new_ry_input != current_ry {
                        new_ry = new_ry_input;
                    }
                    if new_ry != current_ry {
                        // Clamp to 0-360 range
                        if new_ry < 0.0 {
                            new_ry = 0.0;
                        }
                        if new_ry > 360.0 {
                            new_ry = 360.0;
                        }
                        heidic_set_mesh_instance_rotation(selected_mesh_instance_id, current_rx, new_ry, current_rz);
                    }
                    
                    // Z Rotation - Slider and Input (both work independently)
                    let new_rz_slider: f32 = heidic_imgui_slider_float("Rotation Z", current_rz, 0.0, 360.0);
                    let new_rz_input: f32 = heidic_imgui_input_float("##RZ", current_rz, 1.0, 10.0);
                    // Use input value if it changed, otherwise use slider value
                    let new_rz: f32 = new_rz_slider;
                    if new_rz_input != current_rz {
                        new_rz = new_rz_input;
                    }
                    if new_rz != current_rz {
                        // Clamp to 0-360 range
                        if new_rz < 0.0 {
                            new_rz = 0.0;
                        }
                        if new_rz > 360.0 {
                            new_rz = 360.0;
                        }
                        heidic_set_mesh_instance_rotation(selected_mesh_instance_id, current_rx, current_ry, new_rz);
                    }
                    
                    heidic_imgui_end();
                }
            }
            
            // Texture Swatches Window
            if heidic_imgui_begin("Texture Swatches") == 1 {
                // Load texture list on first frame
                heidic_load_texture_list();
                
                let texture_count: i32 = heidic_get_texture_count();
                
                // Display textures in a grid as image previews
                let texture_index: i32 = 0;
                let items_per_row: i32 = 6;  // 6 textures per row
                let current_col: i32 = 0;
                let swatch_size: f32 = 64.0;  // 64x64 pixel previews
                
                while texture_index < texture_count {
                    let texture_name: string = heidic_get_texture_name(texture_index);
                    
                    // Load texture preview and get ID
                    let texture_id: i64 = heidic_get_texture_preview_id(texture_name);
                    
                    // Create unique ID for button
                    heidic_imgui_push_id(texture_index);
                    
                    // Check if this texture is selected (get fresh value each iteration)
                    let selected_texture: string = heidic_get_selected_texture();
                    let is_selected: i32 = 0;
                    if selected_texture == texture_name {
                        is_selected = 1;
                    }
                    
                    // Display as image button
                    if texture_id != 0 {
                        // Use tint color to indicate selection (yellow tint if selected)
                        let tint_r: f32 = 1.0;
                        let tint_g: f32 = 1.0;
                        let tint_b: f32 = 1.0;
                        let tint_a: f32 = 1.0;
                        if is_selected == 1 {
                            tint_r = 1.0;
                            tint_g = 1.0;
                            tint_b = 0.5;  // Yellow tint for selected
                        }
                        
                        // Create unique button ID using texture index
                        // Use texture_name as part of ID to ensure uniqueness
                        let button_id: string = texture_name;
                        // Use ImageButton with tint
                        if heidic_imgui_image_button(button_id, texture_id, swatch_size, swatch_size, tint_r, tint_g, tint_b, tint_a) == 1 {
                            // Clicked: select this texture
                            heidic_set_selected_texture(texture_name);
                        }
                    } else {
                        // Fallback to text if texture failed to load
                        heidic_imgui_text_str_wrapper(texture_name);
                    }
                    
                    heidic_imgui_pop_id();
                    
                    // Same line for grid layout
                    current_col = current_col + 1;
                    if current_col < items_per_row {
                        heidic_imgui_same_line();
                    } else {
                        current_col = 0;
                    }
                    
                    texture_index = texture_index + 1;
                }
                
                heidic_imgui_end();
            }
        }
        
        // Player cube is not selectable, so no position syncing needed
        
        // Ground detection for player
        let ground_check_distance: f32 = 200.0; // 2 meters down
        is_grounded = heidic_raycast_ground_hit(player_pos.x, player_pos.y, player_pos.z, ground_check_distance);
        
        // Visual feedback: Draw ray from player to ground
        if is_grounded == 1 {
            let ground_hit: Vec3 = heidic_raycast_ground_hit_point(player_pos.x, player_pos.y, player_pos.z, ground_check_distance);
            // Draw green line from player to ground (grounded)
            heidic_draw_line(player_pos.x, player_pos.y, player_pos.z, ground_hit.x, ground_hit.y, ground_hit.z, 0.0, 1.0, 0.0);
        } else {
            // Draw red line straight down (not grounded)
            let ground_check_end: Vec3 = heidic_vec3(player_pos.x, player_pos.y - ground_check_distance, player_pos.z);
            heidic_draw_line(player_pos.x, player_pos.y, player_pos.z, ground_check_end.x, ground_check_end.y, ground_check_end.z, 1.0, 0.0, 0.0);
        }
        
        // Debug Panel and Outliner removed - will be reimplemented from scratch
        
        heidic_end_frame();
    }
    
    // Save ImGui layout on shutdown
    heidic_imgui_save_layout("");
    
    heidic_cleanup_renderer();
    heidic_destroy_window(window);
    heidic_glfw_terminate();
}

